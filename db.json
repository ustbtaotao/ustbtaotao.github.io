[{"title":"webpack tsx文件umd打包模块","url":"/webpack/reactwebpack3.html","content":"\n熟悉前端开发的小伙伴，可能会经常遇到代码模块化，代码复用的问题。通常的做法比如es6项目中export，然后import，\ncmd项目中 module.exports 然后require。比如跨项目的话我们可以用node npm发布一个node_module到npm库。\n这里介绍一种更通用的方法。\n\n借助[webpack output 打包模块化组件](https://webpack.docschina.org/configuration/output/#outputlibrary)可以方便的实现，\n\n## demo走起\n我们先typescript写个公共模块\n```\numd.tsx\n-------\nfunction initUmd(){\n    console.log('it is init');\n    return 'back it is init';\n}\nconst umdTest = {\n    constUmd: \"constUmd\",\n    initUmd\n}\nexport default umdTest;\n\n```\n功能很简单，一个公共变量constUmd，一个公共方法initUmd；\n然后我们要在别的项目中使用怎么破？\n\n## webpack 配置\n```\nwebpack.config.umd.js\n------\nconst path = require(\"path\");\n\nmodule.exports = {\n    mode:\"development\",\n    entry: \"./src/umd.tsx\",\n    resolve: {\n        extensions: [\".ts\", \".tsx\", \".js\", \".json\"],\n    },\n    output:{\n        library: \"umdTest\",\n        libraryTarget:\"umd\",\n        path: path.resolve(__dirname,'dist'),\n        filename: 'umdTest.js',\n    },\n    module: {\n        rules: [\n            { test: /\\.(tsx|ts)?$/, loader: \"awesome-typescript-loader\" },\n        ],\n    }\n};\n\n\n```\n 执行 <code>webpack --config webpack/webpack.config.umd.js</code>\n 我们把生成的 umdTest.js拖到git或者自己的服务器上\n \n ## 引用、使用\n \n  在第三方项目里我们直接<script src=\"//youserver.com/umdTest.js?time=13111234324324\"></script>\n\n```\n          <script>\n            const umdTest = window.umdTest.default;\n            console.log(umdTest.constUmd);\n            const result = umdTest.initUmd();\n            console.log(result);\n        </script>\n```\n\n有个问题 const umdTest = window.umdTest.default; 看着不清爽哇，有招，看webpack的out libraryExport配置，\n\n修改webpack配置\n```\nconst path = require(\"path\");\n\nmodule.exports = {\n    mode:\"development\",\n    entry: \"./src/umd.tsx\",\n    resolve: {\n        extensions: [\".ts\", \".tsx\", \".js\", \".json\"],\n    },\n    output:{\n        library: \"umdTest\",\n        libraryTarget:\"umd\",\n        path: path.resolve(__dirname,'dist'),\n        filename: 'umdTest.js',\n        libraryExport: 'default',\n    },\n    module: {\n        rules: [\n            { test: /\\.(tsx|ts)?$/, loader: \"awesome-typescript-loader\" },\n        ],\n    }\n};\n\n```\n然后我们的使用姿势就会变成\n\n```\n          <script>\n            const umdTest = window.umdTest;\n            console.log(umdTest.constUmd);\n            const result = umdTest.initUmd();\n            console.log(result);\n        </script>\n```\n\n## 最后\n\n基于此思路，我们可以实现react vue等前端项目的微服务模块话，我们的被引用部分其实输出的就是 一个方法\n，此方法执行的是类似 <code>ReactDOM.render(<App>,document.getElementById(\"app\"))</code>\n","tags":["webpack"],"categories":["webpack"]},{"title":"react项目中实现音频播放,自定义UI","url":"/reactjs/reactaudio2.html","content":"\n## 说明\n\n[上一篇](/reactjs/reactaudio.html),我们简单的实现了音频的暂停，播放，时间更新等简单的\n音频播放功能，今天我们来个进阶版，在以上基础功能基础上增加了\n* 1、支持设置片段截取播放\n* 2、支持拖动播放\n* 3、支持音量控制\n* 4、支持音频文件下载\n\n## 实现\n本例基于react hook实现，核心原理同[上一篇](/reactjs/reactaudio.html)，拖动音频部分和音量设置部分\n主要是调用了音频api的 audio.volume 和 audio.currentTime 然后更新相对应的ui部分即可\n\n```\nconst onAfterChange = (value, type) => {\n        const myVid = aRef.current;\n        if (type === \"voice\") {\n            myVid.volume = value;\n            setVolume(value);\n        } else {\n            setProcess(value);\n            myVid.currentTime = parseInt(String((myVid.duration * value) / 100));\n        }\n    };\n\n```\n想了解细节的可以留言或者加vo\n## 效果图\n ![audio1](/image/react/audio.jpg)\n \n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"js正则表达式","url":"/javascript/jspattern.html","content":"## 说明\n\njavascript实现字符正则验证,附赠常用的正则表达式,均为项目中实实在在的积累,拿走不用客气。\n\n## 引用\n\n\n```\nvar pattern = /^[\\d()\\-\\s]*$/;\nalert(pattern.test(str))  //true or false\n```\n\n\n## 常用库\n\n```\n pattern:\"^[\\d()\\-\\s]*$\" ,//只输入数字、空格、()\n intege: \"^-?[1-9]\\\\d*$\", //整数\n intege1: \"^[1-9]\\\\d*$\", //正整数\n intege2: \"^-[1-9]\\\\d*$\", //负整数\n num: \"^([+-]?)\\\\d*\\\\.?\\\\d+$\", //数字\n num1: \"^[1-9]\\\\d*|0$\", //正数（正整数 + 0）\n num2: \"^-[1-9]\\\\d*|0$\", //负数（负整数 + 0）\n decmal: \"^([+-]?)\\\\d*\\\\.\\\\d+$\", //浮点数\n decmal1: \"^[1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*$\", //正浮点数\n decmalOrInt: \"^[1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*$|^[1-9]\\\\d*|0$\", //正浮点数\n decmal2: \"^-([1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*)$\", //负浮点数\n decmal3: \"^-?([1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*|0?.0+|0)$\", //浮点数\n decmal4: \"^[1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*|0?.0+|0$\", //非负浮点数（正浮点数 + 0）\n decmal5: \"^(-([1-9]\\\\d*.\\\\d*|0.\\\\d*[1-9]\\\\d*))|0?.0+|0$\", //非正浮点数（负浮点数 + 0）\n\n email: \"^\\\\w+((-\\\\w+)|(\\\\.\\\\w+))*\\\\@[A-Za-z0-9]+((\\\\.|-)[A-Za-z0-9]+)*\\\\.[A-Za-z0-9]+$\", //邮件\n color: \"^[a-fA-F0-9]{6}$\", //颜色\n url: \"^http[s]?:\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+([\\\\w-./?%&=]*)?$\", //url\n chinese: \"^[\\\\u4E00-\\\\u9FA5\\\\uF900-\\\\uFA2D]+$\", //仅中文\n ascii: \"^[\\\\x00-\\\\xFF]+$\", //仅ACSII字符\n zipcode: \"^\\\\d{6}$\", //邮编\n mobile: \"^(13|15)[0-9]{9}$\", //手机\n mobilephone: \"^[1][0-9]{10}$\", //手机\n landline: \"^(0[0-9]{2,3}\\-)?([2-9][0-9]{6,7})+(\\-[0-9]{1,4})?$\", //// 座机\n ip4: \"^(25[0-5]|2[0-4]\\\\d|[0-1]\\\\d{2}|[1-9]?\\\\d)\\\\.(25[0-5]|2[0-4]\\\\d|[0-1]\\\\d{2}|[1-9]?\\\\d)\\\\.(25[0-5]|2[0-4]\\\\d|[0-1]\\\\d{2}|[1-9]?\\\\d)\\\\.(25[0-5]|2[0-4]\\\\d|[0-1]\\\\d{2}|[1-9]?\\\\d)$\", //ip地址\n notempty: \"^\\\\S+$\", //非空\n picture: \"(.*)\\\\.(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$\", //图片\n rar: \"(.*)\\\\.(rar|zip|7zip|tgz)$\", //压缩文件\n date: \"^\\\\d{4}(\\\\-|\\\\/|\\.)\\\\d{1,2}\\\\1\\\\d{1,2}$\", //日期\n qq: \"^[1-9]*[1-9][0-9]*$\", //QQ号码\n tel: \"^(([0\\\\+]\\\\d{2,3}-)?(0\\\\d{2,3})-)?(\\\\d{7,8})(-(\\\\d{3,}))?$\", //电话号码的函数(包括验证国内区号,国际区号,分机号)\n username: \"^\\\\w+$\", //用来用户注册。匹配由数字、26个英文字母或者下划线组成的字符串\n letter: \"^[A-Za-z]+$\", //字母\n letter_u: \"^[A-Z]+$\", //大写字母\n letter_l: \"^[a-z]+$\", //小写字母\n idcard: \"^[1-9]([0-9]{14}|[0-9]{17})$\", //身份证\n newEmail: \"^\\\\w+([-+.']\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$\", //最新验证Email正则表达式\n newIDCard: \"^\\\\d{17}[\\\\d|X]$|^\\\\d{15}$\", //最新验证身份证号的正则表达式\n newnoteEmpty: \"^[\\\\s\\\\S]*\\\\S+[\\\\s\\\\S]*$\", //最新验证字符串是否为空的正则表达式\n newdecmalOrInt: \"^0\\\\.\\\\d+$|^[1-9]\\\\d*\\\\.\\\\d+$|^[1-9]\\\\d*$\", //最新验证数字（正整数或正小数）\n newNumber: \"^\\\\d+$\", //验证纯数字\n newtelephone: \"^\\\\+?(\\\\(\\\\d+\\\\) ?)?(\\\\d+[- ])*\\\\d+$\",//最新验证电话号码正则表达式\n newFaxNumber: \"^(\\\\(?\\\\d+\\\\)?[- ])+(\\\\d+[- ])*\\\\d+$\"//最新验证传真号码正则表达式\n num0_100: \"^((?!0{1,2})\\d{1,2}|10{2}|0)(\\.\\d{1})*$\" //0-100的整数或者0.0-100.9的一位小数\n```\n","tags":["javascript"],"categories":["javascript"]},{"title":"nodejs hapi(三) view template","url":"/nodejs/nodehapi3.html","content":"\n## 说明\n[上一篇](/nodejs/nodehapi2.html)我们介绍了hapi server的会话，本篇view模版。\n同express一样，hapi也支持多种模版引擎，eg：jade、ejs、html等。配置方式略有不同，下面具体\n介绍\n\n## 实现\n* express\n ```\n  app.set('views', __dirname + '/views'); ／/指定views文件路径\n  app.set('view engine', 'ejs'); ／／ 指定模版引擎为ejs\n ```\n\n* hapi\n 需要接住vision插件来实现\n\n ```\n const init = async() => {\n    ....\n    await server.register(require('vision'));\n    server.views({\n        engines: { ejs: Ejs },\n        relativeTo: __dirname,\n        path: 'templates/view',\n    });\n    await server.start();\n};\n\n ```\n\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^","tags":["nodejs"],"categories":["nodejs"]},{"title":"nodejs hapi(二) server session","url":"/nodejs/nodehapi2.html","content":"\n## 说明\n[上一篇](/nodejs/nodehapi1.html)我们搭建了基本的hapi server，从本篇开始我们将“添砖增瓦”，今天我们讨论是server session会话的问题。\n作为web server，session保持是必须要有的基础功能，用来验证用户请求的合法性。在express中\n我们可以用<code>express-session</code> 插件，app.use(session({...options}))来实现。hapi也是类似，可以用<code>[hapi-server-session](https://www.npmjs.com/package/hapi-server-session)</code>,但具体引用并不像express来的直接。因为hapi倡导的是configure rather than\ncoding ，官方都是提供都是以[plugin](https://hapijs.com/tutorials/plugins?lang=en_US)的方式进行注册引用。具体实现如下\n\n## 实现\nnpm install hapi-server-session --save\n代码如下:\n```\n'use strict';\n\n\nconst init = async() => {\n    \n    ....\n    await server.register({\n        plugin: require('hapi-server-session'),\n        options: {\n            cookie: {\n                path: '/', \n            },\n            expiresIn:10*1000,\n            key:'hapi',\n            name:'hapi'\n        },\n    });\n    await server.start();\n    console.log(`Server running at: ${server.info.uri}`);\n};\n\nprocess.on('unhandledRejection', (err) => {\n    console.log(err);\n    process.exit(1);\n});\n\ninit();\n\n```\n\n这样我们实现了简单的会话存储，但这只是基于neicun模式。如果要用类似pm2进行\ncluser进行部署的话session 进程之间没法共享。hapi也支持cache方式配置\neg：mongo，redis等。这里介绍一下redis的配置方法：我们需要依赖一个组件<code>catbox-redis</code>,然后需要在sever实例化的时候进行配置：\n```\nconst server = Hapi.server({\n    port: 3000,\n    host: 'localhost',\n    cache: [{\n        name: 'redisCache',\n        engine: require('catbox-redis'),\n        host: '172.*.*.115',\n        partition: 'cache',\n        port: 6379,\n        password: 'xxx',\n    }],\n});\n\n```\n\n至于其它的cache option参数可以参见[catbox-redis官方说明](https://www.npmjs.com/package/catbox-redis)\n\n这样就实现了利用redis进行缓存，当然包括会话数据，当然也可以用来存储其它缓存数据，下面我们以用户会话举例。\n很简单的一个场景：某接口或者页面需要用户登录后才可访问；\n1、登录\n用户登录完，session记录用户基本信息；\n```\n server.route({\n    method: 'GET',\n    path: '/login',\n    handler: function (request, h) {\n      if(request.session.user){\n            return 'logining';\n      } \n      request.session.user = {\n        name: 'jack'\n      }\n    return h.response('Success');\n};\n});\n\n```\n\n2、api请求资源\n```\nserver.route({\n    method: 'GET',\n    path: '/getresource',\n    handler: function(request, h) {\n        if(!request.session.user){\n            return 'no login';\n        }\n        return 'getresource';\n    }\n});\n```\n\n3、测试\n先登录，后getresource,结果返回‘getresource’，当10s后则反馈‘no login’，因为我们的会话时间设置的是10s\n\n4、这样我们就简单的实现了资源访问之前的会话验证。\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^","tags":["nodejs"],"categories":["nodejs"]},{"title":"electron 实践","url":"/electron/electron1.html","content":"## 说明\nelectron为全栈工程师开发桌面程序提供了可能，页面可以用任何姿势进行构建：jquery、react、vue等等，然后打包成应用程序。\n但是有时候我们会集成一些已有的页面或者第三方页面进来。[webview](https://electronjs.org/docs/api/webview-tag)可以\n解决这个问题\n```\n<webview src=\"\" httpreferrer=\"\" style=\"height: 100vh;width: 100vw;\" id=\"chat-frame\" plugins disablewebsecurity=\"on\">\n\n    </webview>\n```\n但是会发现一个问题，如果引用的页面需要打开一个页面（_blank,_self）时，并没有任何反应，是因为第三方页面和electron本身不是一个体系，没法\n直接进行通信。我们可以再<code>webview</code>上追加一个属性[nodeintegration](https://electronjs.org/docs/api/webview-tag#nodeintegration),\n该属性可以让webview 中的访客页（guest page）将具有Node集成, 并且可以使用像 require 和 process 这样的node APIs 去访问低层系统资源。\n这样如果我们用的```<a href=\"other page\">```标签 target=\"_self\" 效果就是在本桌面程序里打开这个页面。\n那我们把target改成_blank 或者用window.open 就又打不开了\n\n解决思路也简单\n* 方案一:第三方告诉主页面我要打开一个新页面\n* 方案二：主页面自动监听是否需要开新页面\n 方案一设置到第三方页面的改动，不太现实；那只能方案二\n <code>webview</code>会监听 new-window 事件，然后通过sheel打开,但也要配置<code>nodeintegration</code>,否则也会失效\n ```\nconst webview = document.querySelector('webview');\n    webview.addEventListener('new-window', (event) => {\n        const url = event.url;\n        url.startsWith('http') && shell.openExternal(url);\n    })\n```\n","tags":["electron"],"categories":["electron"]},{"title":"七牛图片快速下载到本地服务器","url":"/hexo/hexoqiuniu.html","content":"## 说明\n\n有一天登录到自己的博客，打开发现所有的图片都加载不出来了。图片原来都寄存在七牛云上，刚开始\n由于七牛是免费的且速度较快，就放在上面了。但是最终还是被坑了，后来通过填写工单的方式，才得知\n原来的都是测试域名，现在都回收了，不再使用。也就是外联都失效了，从七牛官网上也下载不了，原来的\n图片七零八碎的也都不知道在哪。抓狂。后边也感谢七牛工程师，将原来的测试域名暂时给我激活，<code>3天</code>期限。\n要么从官网下载下来放到别的地方，要么填写一个自己已经备案的cdn加速域名。之前也没备案，就赶紧备案\n但是路漫漫，决定还是一边申请备案，一边把资源下下来。但是蛋疼的又发现，官网并不知道批量打包下载。哭！！\n后边工程师发了一个官方的工具，还得下载安装，配置环境变量，看着挺费劲。决定还是自己利用nodejs爬虫下来。\n\n## 实现\n* 获取所有图片地址\n\n   爬虫的第一步，肯定的拿到我原来在七牛上传的所有图片的url地址,这个会点前端的难不倒。打开七牛网站，找到自己的\n   空间，打开F12开发者工具,请求页面。分析后发现，图片是以分页的方式加载的，最终发现有个file的api，在response\n   里很清楚的看到我的图片资源。就是它了，然后将右侧的response的json复制下来作为page1.json备用。\n   ![图0](/image/hexo/qiniu1.png)\n   后边的分页数据也是类似的方法，点击列表最后的加载更多，继续上述步骤，我这里总共有4页所有，最后拿到的资源就有\n   page1.json、page2.json、page3.json、page4.json \n\n* 获取资源\n  这里我使用的是nodejs，原因是会且相对简单。建立一个小小的express项目，新建一个test.js,\n  核心就是利用[axios](https://www.npmjs.com/package/axios)和nodejs的fs文件模块，对文件进行下载\n  和保存。然后将上一步保存的json文件放到同一级目录下，方便读取。\n  ![图1](/image/hexo/qiniu2.png)\n  完整的爬虫项目可以Github上下载[拿走不谢](https://github.com/ustbtaotao/qiuniuimg.git)\n  \n* 七牛地址替换为本地地址\n  将原来七牛的测试域名全部替换为本站相对地址\n  \n* end\n  最终成功的抛弃的七牛，摆脱了束缚。    \n","tags":["hexo"],"categories":["hexo"]},{"title":"react项目 webpack 3.x打包效率提升记","url":"/reactjs/reactwebpack2.html","content":"\n## 说明\n\nwebpack是大家都知晓的主流打包工具,或者形象的讲是“模块打包机”，在之前的博客中也\n总结了[1.x-->2.x](/reactjs/reactwebpack.html)的核心步骤。今天要介绍的如何提升\n前端项目的打包效率，缩短打包时间，进而缩短项目部署的时间。\n大家都知道，随着项目原来越大，需要解析和处理的文件也越来越多，构建是文件读写和计算密集型的操作，\n这时候webpack的处理效率会越来越慢。运行在nodejs的webpack是单线程模式，也就说它不能\n同时处理好几件事，所以这也就说慢的原因。那么有没有办法让webpack并行处理呢。答案肯定是有的。\n* <code>happypack </code>\n首先介绍一下[happypack](https://www.npmjs.com/package/happypack)\n它的思想就是将\n任务拆分成多个子进程进行并发处理，处理完成后将结果返回给主进程也就是webpack进程。那么怎么\n接入呢？\n先看看没接入前：\n```\nmodule: {\n          rules: [{\n              test: /\\.(js|jsx)$/,\n              exclude: /node_modules/,\n              loader: 'babel-loader'\n          },\n          , {\n             test: /\\.(css|less)$/,\n             use: ExtractTextPlugin.extract({\n                 fallback: 'style-loader',\n                 use: [{\n                     loader: 'css-loader'\n                 }, {\n                     loader: 'less-loader'\n                 }]\n          \n             })\n           }\n          ...\n        }\n\n```\n\n使用了babel-loader对es6的语法进行转化。接入happypack：\n\n```\nconst HappyPack = require('happypack');\nconst happyThreadPool = HappyPack.ThreadPool({ size: 4 }); // 默认3个进程\nmodule: {\n          rules: [{\n              test: /\\.(js|jsx)$/,\n              exclude: /node_modules/,\n              loader: 'happypack/loader?id=happyBabel',\n          },\n          {\n              test: /\\.(css|less)$/,\n              loader: 'happypack/loader?id=styles',\n          },\n        ...\n        },\n        // add a new plugin\nplugins: [\n        new HappyPack({\n            id: 'happyBabel', // 必须和rules里的id保持一致\n            loaders: [{\n                loader: 'babel-loader?cacheDirectory=true',\n            }],\n            threadPool: happyThreadPool,\n            verbose: true,\n        }),\n        new HappyPack({\n            id: 'styles',\n            threadPool: happyThreadPool,\n            loaders: [ 'style-loader', 'css-loader', 'less-loader' ]\n          })        \n        ...\n        ]\n      \n```\n<code>注：</code>对于样式的happpack可能会报错，如果报错，还原样式部分配置即可。\n\n* <code>webpack-parallel-uglify-plugin</code>\n\n代码并行转换完了，但是最最费时间的是js的压缩，在常用的配置中我们会使用webpack插件\nuglifyjs-webpack-plugin\n```\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');\nplugins: [\n        new UglifyJSPlugin({\n            sourceMap: false,\n            uglifyOptions: {\n                ecma: 5,\n                ie8: true,\n                mangle: false\n            }\n        }),\n        ....\n        ]\n```\n这里也是单线程的，对于越来越多越大的js，压缩时间可想而知。同理，我们也可以参考\nhappypack的思想，让并发起来，这里介绍另个神器[webpack-parallel-uglify-plugin](https://www.npmjs.com/package/webpack-parallel-uglify-plugin)\n原理类似。具体接入方法如下：\n讲原来部分注销掉\n```\nconst ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');\n plugins: [\n        /*new UglifyJSPlugin({\n            sourceMap: false,\n            uglifyOptions: {\n                ecma: 5,\n                ie8: true,\n                // 不能压缩变量名，会导致项目无法发起异步请求\n                mangle: false\n            }\n        }),*/\n        // 使用 ParallelUglifyPlugin 并行压缩输出JS代码\n        new ParallelUglifyPlugin({\n            uglifyJS: {\n                output: {\n                    /*\n                     是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，\n                     可以设置为false\n                    */\n                    beautify: false,\n                    /*\n                     是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false\n                    */\n                    comments: false\n                },\n                compress: {\n                    /*\n                     是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用\n                     不大的警告\n                    */\n                    warnings: false,\n\n                    /*\n                     是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句\n                    */\n                    drop_console: true,\n\n                    /*\n                     是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不\n                     转换，为了达到更好的压缩效果，可以设置为false\n                    */\n                    collapse_vars: true,\n\n                    /*\n                     是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = 'xxx'; y = 'xxx'  转换成\n                     var a = 'xxxx'; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false\n                    */\n                    reduce_vars: true\n                }\n            }\n        }),\n        ...\n        ]\n```\n至此，在两大神器的加盟下，实际效果到底如何呢？\n实际项目,pack 5次求平均，测试结果如下\n\n|before|only with ParallelUglifyPlugin|with ParallelUglifyPlugin & happypack|\n|:----:|:----:|:----:|\n|4min30s|1min30s|<1min|\n\n","tags":["reactjs","webpack"],"categories":["reactjs"]},{"title":"git常用命令","url":"/git/git.html","content":"## 说明\n\n在我们程序猿的开发工作中，代码管理并不可少，之前介绍了本地[svn环境的搭建](/server/svnstart.html)。\n当然除了svn外，主流的还有git，关于git的安装大家可自行去官网或者论坛里寻找，这里要介绍的是\ngit的一些常用的操作命令：\n\n* 初始化仓库\n先在git上new一个project，复制git地址留着备用\n\n1、创建一个空的代码库，本地没有任何代码\n\n```\ngit clone git@git.jd.com:uname/test.git\ncd test\ntouch README.md\ngit add README.md\ngit commit -m \"add README\"\ngit push -u origin master\n```\n\n2、本地已有代码\n```\ncd existing_folder\ngit init\ngit remote add origin git@git.jd.com:uname/test.git\ngit add .\ngit commit -m \"Initial commit\"\ngit push -u origin master\n```\n\n* 提交文件\n```\ngit commit -a --m ='msg' && git push\n等同于\ngit add . \ngit commit --m ='msg'\ngit push\n```\n\n* 更新远程到本地\n```\ngit pull\n```\n\n* 提交本地到远程\n```\ngit push\n```\n\n* 切换本地分支\n```\ngit checkout exit_branch\n```\n\n* 新建分支并提交到远程\n```\ngit checkout -b new_branch\ngit push --set-upstream origin new_branch   \n```\n* 拉取远程分支\n```\ngit checkout -b remote_branch origin/remote_branch\n```\n\n* 查看本地所有分支\n\n```\ngit branch\n```\n\n* 查看所有远程分支\n```\ngit branch -r\n```\n\n* 拉取所有远程分支\n```\ngit fetch --all\n```\n","tags":["其他","git"],"categories":["git"]},{"title":"js正则表达式之exec和match","url":"/javascript/jspattern2.html","content":"## 说明\n\n最近项目中遇到了一个实例，需要将字符串中的特定字符，替代成img标签，即表情以html的方式展示在前端。\n数据返回的字符串形如<code>aaaa#E-s01ffff#E-s02ddd#E-s21</code>其中#E-s01为要替换的表情字符，\n需要替换为<code><\\img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s21.png\" /></code>\n该如何做呢？\n\n## 实现\n我们首先想到的肯定是正则表达式，第一步我们要把所有的#E-s01表情字符找出来，抽象成正则表达式就是 #E-s\\d{2},这样是能匹配出来，\n但是有个问题，在第二步，我们需要将sxx部分动态的拼接在img标签的src属性上，这时候就有点爱莫能助了。那么该怎么办呢，大家都知道\njs正则有分组的概念，所有我们将#E-s01分组成 #E-s01(\\d{2})即可，为了匹配大小写和全局，最终的表达式为\n```\nconst reg = new RegExp(/#E-s(\\d{2})/ig);\n```\n接下来就是正则替换了，用string.replace即可；\n具体实现如下：\n```\nlet html = 'aaaa#E-s01ffff#E-s02ddd#E-s21';\nconst reg = new RegExp(/#E-s(\\d{2})/ig);\nconsole.time('match');\nlet temp = html.match(reg);\ntemp.forEach((v)=>{\n    html = html.replace(v,'<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s'+v.replace('#E-s','')+'.png\" />')\n});\nconsole.log(html)\nconsole.timeEnd('match');\n```\n\n输出结果为：\n```\naaaa<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s01.png\" />\nffff<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s02.png\" />\nddd<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s21.png\" />\nmatch: 2.113ms\n```\n总共花费了2ms+的时间，实现了我们想要的结果\n\n那么有没有别的实现思路呢？答案肯定是有的，方案一呢我们用到了match函数，将所有的表情字符拿到了，即为一个数组，然后我们循环遍历\n用replace加以替换得到结果。除了match还有一种正则方法exec，它俩有啥区别呢，区别就是：\n\n<code>1、当正则表达式无子表达式，并且定义为非全局匹配时，exec和match执行的结果是一样，均返回第一个匹配的字符串内容；</code>\n\n<code>2、当正则表达式无子表达式，并且定义为全局匹配时，exec和match执行，做存在多处匹配内容，则match返回的是多个元素数组；</code>\n\n<code>3、当正则表达式有子表示时，并且定义为非全局匹配，exec和match执行的结果是一样；</code>\n\n<code>4、当正则表达式有子表示时，并且定义为全局匹配，exec和match执行的结果不一样，此时match将忽略子表达式，只查找全匹配正则表达式并返回所有内容；</code>\n\n<code>也就说，exec与全局是否定义无关系，而match则于全局相关联，当定义为非全局，两者执行结果相同</code>\n\n也就是exec此时会返回分组信息，比如#E-s01 可以返回 #E-s 和 01两部分，具体实现如下：\n```\nlet r = \"\";\nconst temp = 'aaaa#E-s01ffff#E-s02ddd#E-s21';\nconst reg = new RegExp(/#E-s(\\d{2})/ig);\nif(new RegExp(reg).test(temp)){\n    while(r = reg.exec(temp)) {\n        temp = temp.replace(r[0],'<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s'+r[1]+'.png\" />');\n    }\n}\nconsole.log(temp)\nconsole.timeEnd('exec');\n```\n输出结果为：\n```\naaaa<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s01.png\" />\nffff<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s02.png\" />\nddd<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s21.png\" />\nexec: 0.042ms\n```\n\n可以看出结果完全一样，但效率方面，方案二远远胜于方案一\n方案3：利用正则分组$\n```\nlet r = \"\";\nlet temp = 'aaaa#E-s01ffff#E-s02ddd#E-s21';\nconsole.time('replace');\nlet reg = new RegExp(/#E-s(\\d{2})/ig);\nlet temp2 = temp.replace(reg,'<img style=\"width:25px;height:25px\" src=\"http://xxx.example.com/im_smart/images/express/base/s'+'$1'+'.png\" />')\nconsole.log(temp2)\nconsole.timeEnd('replace');\n```\n也能实现我们要的结果\n由此也给我们一个启示就是：条条大路通罗马，定有最有解！\n","tags":["javascript"],"categories":["javascript"]},{"title":"nodejs hapi(一) server","url":"/nodejs/nodehapi1.html","content":"\n## 说明\n最近偶遇nodejs一个框架[hapi](https://hapijs.com/)，经过各种搜贴发现相关的信息很少，据说是国内不太流行，毕竟express还是大腿。具体和express和koa的比较，可以参考[diff](https://www.airpair.com/node.js/posts/nodejs-framework-comparison-express-koa-hapi)。这里我们不做好坏对比，我们的原则就是能满足实现的frame很多，具体如何选择具体分析。官方的文案demo比较碎，很不适合初学者上手。这里我们就来个深度的<code>get start</code>\n\n## server\n\n本节将实现hapi server。之后所有的分享均基于hapi v17.\nstep1: 创建项目文件，eg:mkdir hapi\nstep2: cd hapi \nstep3: npm init\nstep4: npm install hapi --save\nstep5: touch index.js\n代码如下:\n```\n'use strict';\n\nconst Hapi = require('hapi');\nconst Path = require('path');\nconst server = Hapi.server({\n    port: 3000,\n    host: 'localhost'\n});\n\nconst init = async() => {\n    \n    server.route({\n        method: 'GET',\n        path: '/test',\n        handler: {\n            return 'hello world';\n        }\n    });\n\n    await server.start();\n    console.log(`Server running at: ${server.info.uri}`);\n};\n\nprocess.on('unhandledRejection', (err) => {\n    console.log(err);\n    process.exit(1);\n});\n\ninit();\n\n```\n\nstep6: node index.js\nstep7: curl http://localhost:3000/test\nstep8: output 'hello world'\n\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^","tags":["nodejs"],"categories":["nodejs"]},{"title":"nodejs timeout","url":"/nodejs/nodejstimeout.html","content":"\n## 说明\n正常的网络请求无非都是\n client ---req--->\n        <---res--server\n，由于业务需要或者xx要求，需要对请求做超时限制。一个请求的timeout可分为三种：\n1、client requset timeout\n指的的是客户端请求超时设置，比如5s，意思是client从发起请求开始计时，如果超过5s，server还没有响应header\n返回，即视为请求超时；\n2、server response timeout\n指的是服务器端响应超时设置，比如5s，意思是server从发送数据开始计时，如果超过5s，client还没有全部接收数据，即视为响应超时；\n3、server timeout\n指的是server要维持和client的连接处于空闲的时间，比如5s，指的是client和server建立连接5s后，还没响应，连接就会失效。\n现在要实践的是2和3，client timeout不做扩展了\n\n## 实验\n\n* server response timeout\nnodejs express框架，router可以灵活的设置一个或者多个中间价，比如常见的auth，passport，ratelimit以及现在要说的timeout等等。比如路由\n\n```\n router.post('/hello', function (req, res, next) {\n  res.send('world');\n })\n```\n\n\n一个的post请求，我们想要的效果是5s内server res timetou，那么自然想到的是express中间价，这里我用的是\n<code>[connect-timeout](https://www.npmjs.com/package/connect-timeout)</code> 就可以轻松的实现。\n```\nimport timeout from 'connect-timeout';\n router.post('/hello', timeout(5s), function (req, res, next) {\n  setTimeout(() =>{\n     res.send('world');\n    },6*1000);  //模拟业务处理需要6s\n })\n```\n\n然后我们可以用postman或者restclient工具进行模拟请求，发现5s的时候客户端会返回timeout\n\n* server timeout\n上面的业务需要6s，比如是非常耗时的处理需要3min（当然如果是这样就不建议http同步处理了，最好采用异步处理的方式），但为了测试timeout，我们还是鲁莽一次。这次不设置server res timeout\n```\n router.post('/hello', function (req, res, next) {\n  setTimeout(() =>{\n     res.send('world');\n    },3*60*1000);  //模拟业务处理需要3min\n })\n```\n\n然后我们可以用postman或者restclient工具进行模拟请求，发现2min的时候客户端自动取消请求了。这不是我们想要的，这是为什么呢，查阅nodejs官方文档发现，server client会有连接超时设置 默认2min\n ![timeout1](/image/nodejs/timeout1.jpeg)\n但是我们的业务需要3min怎么办，继续看文档发现 servertimeout 可以设置\n ![timeout2](/image/nodejs/timeout2.jpeg)\n试试0 表示无限制\n```\nserver.timeout = 0;\nserver.listen(port);\n\n```\n\n再请求，发现在3min的时候数据返回了world，符合业务要求。\n\n但是这样会有问题，无限等待会对服务器造成压力，尤其是请求量大的时候。或者其他路有响应很快，这时候可以结合中间件进行双重控制。比如：\n```\napp.js\nserver.timeout = 0;\nserver.listen(port);\n\nrouter.js\n router.post('/hello',timeout(4*60s), function (req, res, next) {\n  setTimeout(() =>{\n     res.send('world');\n    },3*60*1000);  //模拟业务处理需要3min\n })\nrouter.post('/world',timeout(4s), function (req, res, next) {\n     res.send('hello');\n })\n```\n\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"nodejs api实现数字签名验证","url":"/nodejs/nodeapipassportdigital.html","content":"\n## 说明\nnodejs作为服务端api开发语言已经不是什么稀奇的事情了，今天分享的不是怎么利用express\n进行api封装，而是怎么利用middleware中间件对api接口进行签名验证。为什么要做签名验证，\n原因很简单就是为了安全。\n\n## 实现\n大家都知道express route可以很灵活的加入一些中间件包括我们自定义的，今天要实现的数字签名\n验证需要依赖[passport-digital-signature](https://www.npmjs.com/package/passport-digital-signature)进行二次开发。\n签名逻辑说明：对每个api请求必须要求传入时间戳timestamp、keyId和数字签名值sign。其中\nsign签名规则为：\n\n### 第一步：\n\n设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。\n特别注意以下重要规则：\n\n参数名按ASCII码从小到大排序（字典序）；\n如果参数的值为空不参与传参和签名；\n参数名区分大小写；\nget 和 post 参数均参与签名（注意：签名时不要对 get 和 post 的参数进行urlencode）；\nsign 参数不参与签名；\n根据HTTP协议要求，传递参数的值中如果存在特殊字符（如：&、@等），那么该值需要做URL Encoding，这样请求接收方才能接收到正确的参数值。这种情况下，待签名数据应该是原始值而不是encoding之后的值。例如：调用某接口需要对请求参数email进行数字签名，那么待签名数据应该是email=test@msn.com，而不是email=test%40msn.com。\n\n### 第二步：\n\n在stringA最后拼接上“&key=AppSecret”得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值。\n\n### 第三步：\n\n拼接sign签名，得到最终请求字符串。\n\n具体实现步骤：\n* 1、npm install passport-digital-signature\n* 2、修改passport-digital-signature签名逻辑\n   进入passport-digital-signature/lib目录,打开strategy.js，实现签名和签名验证规则,核心方法：\n   2.1、param排序\n\n```\n/**\n* 获取参数字符串 ascall码排序\n*/\nfunction getVerifyParams(params) {\n var sPara = [];\n if(!params) return null;\n for(var key in params) {\n   if((!params[key]) || key == \"sign\") {\n     continue;\n   };\n   sPara.push([key, params[key]]);\n }\n sPara = sPara.sort();\n var prestr = '';\n for(var i2 = 0; i2 < sPara.length; i2++) {\n   var obj = sPara[i2];\n   if(i2 == sPara.length - 1) {\n     prestr = prestr + obj[0] + '=' + obj[1] + '';\n   } else {\n     prestr = prestr + obj[0] + '=' + obj[1] + '&';\n   }\n }\n prestr += '&key='+params.keyId;\n return prestr;\n};\n```\n\n2.2、生成签名\n \n \n ```\n/**\n* 获取签名\n*/\nfunction getSign(data){\n  if (data && data.length > 0) {\n      var buf = new Buffer(data);\n      var str = buf.toString('binary');\n      let md5Str = crypto.createHash('md5').update(str).digest('hex');\n      return md5Str.toUpperCase();\n  }\n}\n ```\n\n2.3 overwrite authenticate\n\n```\n/**\n * Authenticate request based on the contents of a form submission.\n *\n * @param {Object} request\n * @api protected\n */\n Strategy.prototype.authenticate = function(req, options) {\n   //时间戳timestamp、keyId和数字签名值sign 三个参数必传 \n  if (!req.query || !req.query.sign || !req.query.timestamp || !req.query.keyId) {\n    return this.fail2(1005);\n  }\n  var timestamp = req.query.timestamp;\n  var now = new Date().getTime();\n  //timestamp 必须是10位或者13位\n  if(timestamp.length != 10 && timestamp.length != 13){\n    return this.fail2(1001);\n  }else if(timestamp.length == 10){\n    timestamp = timestamp * 1000;\n  }\n  let grap = now - timestamp ;\n  //timestamp 3分钟内有效\n  if(grap > 3 * 60 * 1000 || grap <＝ 0){\n    return this.fail2(1001);\n  }\n  var appkey = req.query.keyId;\n  var params = req.query;\n  var self = this;\n\n  function verified(err, client) {\n    if (err) { return self.fail2(-1); }\n    // keyId不存在\n    if (!client) { return self.fail2(1006); }\n    // 获取排序参数\n    params = getVerifyParams(params);\n    // 获取正确签名\n    var signVerfied = getSign(params);\n    var sign = req.query.sign;\n    var flag = false;\n    flag = verifySign(signVerfied,sign);\n    if(!flag){\n      return self.fail2(1002);\n    }\n    self.pass();\n  }\n  if (self._passReqToCallback) {\n    this._verify(req, appkey, verified);\n  } else {\n    this._verify(appkey, verified);\n  }\n};\n```\n\n* 3、api router注册\n\n```\nconst DigitalSignatureStrategy =require('passport-digital-signature').Strategy;\n// 验证keyId是否有效\nconst digitalSignature = require('./middleware/checkClient');    \npassport.use(new DigitalSignatureStrategy(digitalSignature))；\napp.use('/openapi', passport.authenticate('digital-signature'), yourRoute);\n```\n\n## 测试\n![digit1](/image/nodejs/digit1.jpeg)\n![digit2](/image/nodejs/digit2.jpeg)\n![digit3](/image/nodejs/digit3.jpeg)\n","tags":["javascript","nodejs"],"categories":["nodejs"]},{"title":"kettle实现异构数据同步(四)","url":"/kettle/kettle4.html","content":"\n## 说明\n\n今天谈谈kettle（v7.2）数据同步之增量更新，在实际的业务中经常会遇到增量更新的问题，一般有两种做法：\n1、先全量删除、后全量插入\n优点：简单，快速；\n缺点：修改的增量数据体现不出来，数据体积庞大\n2、当前数据和历史数据进行一一对比\n优点：增量数据体积小，更符合业务场景要求\n缺点：计算成本高、耗费资源\n\n\n## 总体实现\n本例使用的mysql数据库，数据库连接这里不再赘述，参见[上一篇](/kettle/kettle3.html)\n说明用到的组件：\n1、输入：表\n2、合并记录：用来比较当前和历史数据，生成比较标记，kettle预设的四种状态：\n  “identical” 标识没变化\n  “changed” 有更新\n  ”deleted“ 已删除\n  “new”新增\n3、switch/case:选择分支\n4、空操作\n5、获取系统信息\n6、插入、更新\n7、删除\n总体效果图\n![kettle41](/image/kettle/kettle41.jpeg)\n## 详细说明\n1、输入\ntoday指当天的数据或者最新的数据；yestoday指历史数据；需要说明的是today 和yestoday的关键业务字断必须一致、且均需要按照对比字断进行order by，否则可能会出现意想不到的\n情况；\n2、合并记录\n![kettle42](/image/kettle/kettle42.jpeg)\n比如：\ntoday        yestoday         result \na | b        a | b            a | b  | c\n1 | 11       1 | 11           1 | 11 |identical\n2 | 22       2 | 222          2 | 222|changed\n3 | 33       4 | 44           3 | 33 |deleted\n                              4 | 44 |new\n\n3、switch/case\n![kettle43](/image/kettle/kettle43.jpeg) 4、空操作\n如果第三步flag为   identical 则什么也不干\n5、获取系统信息   \n获取当前日期，更新业务时间字段\n![kettle44](/image/kettle/kettle44.jpeg)  6、插入、更新\n根据关键字段比较，new为插入，changed为更新\n7、删除\n  插入、更新、删除 ，需要注意的是比较的关键字断值不能为null，否则查询比较会有问题\n## 运行\n50w+数据，对比后增量更新，30s-40s\n\n","tags":["kettle"],"categories":["kettle"]},{"title":"react实现服务器渲染","url":"/reactjs/reactserver.html","content":"\n## 说明\n\n之前我们所有的react spa项目都是前后端分离的客户端渲染，即通过render的方式进行UI呈现，通过ajax或者fetch进行api异步请求数据。  闲暇期间接触到了react服务器渲染方式，决定研究研究。为什么要说服务器端渲染呢？查了些帖子和资料，无非以下几个原因：\n1、代码复用；\n2、利于SEO，因为整个html都是由node后台生成好直接输出到前端的。\n3、提升首屏加载速度\n\n为了更好更快的学习，这里给大家分享一个项目，步骤说明已经很清楚了，我不再赘述，这里分享出项目的[源码](https://pan.baidu.com/s/1d9n6SJiDhXsxMwKfLnvKUA)。运行前先建立mongo数据库，建立open_cook库，新建user和recipe表，结构参见src/server/models;mongoose配置修改src/server/config/index.js database节点\n下载后直接npm install 然后npm run start 即可。具体实现逻辑看下边－－－－－>>>>\n\n## 分享\n用 React + Redux + Node（Isomorphic JavaScript）开发食谱分享网站\n\n## 前言\n如果你是从一开始跟著我们踏出 React 旅程的读者真的恭喜你，也谢谢你一路跟著我们的学习脚步，对一个初学者来说这一段路并不容易。本章是扣除附录外我们最后一个正式章节的范例，也是规模最大的一个，在这个章节中我们要整合过去所学和添加一些知识开发一个可以登入会员并分享食谱的社群网站，Les's GO！\n\n## 需求规划\n让使用者可以登入会员并分享食谱的社群网站\n\n## 功能规划\n\n1. React Router / Redux / Immutable / Server Render / Async API\n2. 使用者登入/登出（JSON Web Token）\n3. CRUD 表单资料处理\n4. 资料库串接(ORM/MongoDB)\n\n## 使用技术\n1. React\n2. Redux(redux-actions/redux-promise/redux-immutable)\n3. React Router\n4. ImmutableJS\n5. Node MongoDB ORM(Mongoose)\n6. JSON Web Token\n7. React Bootstrap\n8. Axios(Promise)\n9. Webpack\n10. UUID\n\n## 专案成果截图\n\n![用 React + Redux + Node（Isomorphic）开发一个食谱分享网站](/image/react/open-cook-demo-1.png \"用 React + Redux + Node（Isomorphic）开发一个食谱分享网站\")\n\n![用 React + Redux + Node（Isomorphic）开发一个食谱分享网站](/image/react/open-cook-demo-2.png \"用 React + Redux + Node（Isomorphic）开发一个食谱分享网站\")\n\n![用 React + Redux + Node（Isomorphic）开发一个食谱分享网站](/image/react/open-cook-demo-3.png \"用 React + Redux + Node（Isomorphic）开发一个食谱分享网站\")\n\n![用 React + Redux + Node（Isomorphic）开发一个食谱分享网站](/image/react/open-cook-demo-4.png \"用 React + Redux + Node（Isomorphic）开发一个食谱分享网站\")\n\n## 环境安装与设定\n1. 安装 Node 和 NPM\n\n2. 安装所需套件\n\n```\n$ npm install --save react react-dom redux react-redux react-router immutable redux-immutable redux-actions redux-promise bcrypt body-parser cookie-parser debug express immutable jsonwebtoken mongoose morgan passport passport-local react-router-bootstrap axios serve-favicon validator uuid\n```\n\n```\n$ npm install --save-dev babel-core babel-eslint babel-loader babel-preset-es2015 babel-preset-react babel-preset-stage-1 eslint eslint-config-airbnb eslint-loader eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react html-webpack-plugin webpack webpack-dev-server redux-logger\n```\n\n接下来我们先设定一下开发文档。\n\n1. 设定 Babel 的设定档： `.babelrc`\n\n  ```javascript\n  {\n    \"presets\": [\n      \"es2015\",\n      \"react\",\n    ],\n    \"plugins\": []\n  }\n\n  ```\n\n2. 设定 ESLint 的设定档和规则： `.eslintrc`\n\n  ```javascript\n  {\n    \"extends\": \"airbnb\",\n    \"rules\": {\n      \"react/jsx-filename-extension\": [1, { \"extensions\": [\".js\", \".jsx\"] }],\n    },\n    \"env\" :{\n      \"browser\": true,\n    }\n  }\n  ```\n\n3. 设定 Webpack 设定档： `webpack.config.js`：\n\n  ```javascript\n  import webpack from 'webpack';\n\n  module.exports = {\n    entry: [\n      './src/client/index.js',\n    ],\n    output: {\n      path: `${__dirname}/dist`,\n      filename: 'bundle.js',\n      publicPath: '/static/'\n    },\n    module: {\n      preLoaders: [\n        {\n          test: /\\.jsx$|\\.js$/,\n          loader: 'eslint-loader',\n          include: `${__dirname}/app`,\n          exclude: /bundle\\.js$/,\n        },\n      ],\n      // 使用 Hot Module Replacement 外挂\n      plugins: [\n        new webpack.optimize.OccurrenceOrderPlugin(),\n        new webpack.HotModuleReplacementPlugin()\n      ],    \n      loaders: [{\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        query: {\n          presets: ['es2015', 'react'],\n        },\n      }],\n    },\n  };\n  ```\n\n4. 设定 `src/server/config/index.js`：\n\n```javascript\nexport default ({\n  \"secret\": \"ilovecooking\",\n  \"database\": \"mongodb://localhost/open_cook\"\n});\n``` \n\n太好了！这样我们就完成了开发环境的设定可以开始动手实作我们的食谱分享社群应用程式了！  \n\n同时我们也初步设计我们资料夹结构，主要我们将资料夹分为 `client`、`common`、`server`：\n\n![用 React + Redux + Node（Isomorphic）开发一个食谱分享网站](./images/open-cook-demo-folder.png \"用 React + Redux + Node（Isomorphic）开发一个食谱分享网站\")\n\n## 动手实作\n\n首先我们先进行 `src/client/index.js` 的设计：\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { browserHistory, Router } from 'react-router';\nimport { fromJS } from 'immutable';\n// 我们的 routing 放置在 common 资料夹中的 routes\nimport routes from '../common/routes';\nimport configureStore from '../common/store/configureStore';\nimport { checkAuth } from '../common/actions';\n\n// 将 server side 传过来的 initialState 给 rehydration（覆水）\nconst initialState = window.__PRELOADED_STATE__;\n\n// 将 initialState 传给 configureStore 函数创建出 store 并传给 Provider\nconst store = configureStore(fromJS(initialState));\nReactDOM.render(\n  <Provider store={store}>\n    <Router history={browserHistory} routes={routes} />\n  </Provider>,\n  document.getElementById('app')\n);\n```\n\n由于 Node 端要到新版对于 ES6 支援较好，所以先用 `babel-register` 在 `src/server/index.js` 去即时转译 `server.js`，但不建议在 `production` 环境使用。\n\n```javascript\n// use babel-register to precompile ES6 \nrequire('babel-register');\nrequire('./server');\n```\n\n```javascript\n// 引入 Express、mongoose（MongoDB ORM）以及相关 server 上使用的套件\n/* Server Packages */\nimport Express from 'express';\nimport bodyParser from 'body-parser';\nimport cookieParser from 'cookie-parser';\nimport morgan from 'morgan';\nimport mongoose from 'mongoose';\nimport config from './config';\n// 引入后端 model 透过 model 和资料库互动 \nimport User from './models/user';\nimport Recipe from './models/recipe';\n\n// 引入 webpackDevMiddleware 当做前端 server middleware\n/* Client Packages */\nimport webpack from 'webpack';\nimport React from 'react';\nimport webpackDevMiddleware from 'webpack-dev-middleware';\nimport webpackHotMiddleware from 'webpack-hot-middleware';\nimport { RouterContext, match } from 'react-router';\nimport { renderToString } from 'react-dom/server';\nimport { Provider } from 'react-redux';\nimport Immutable, { fromJS } from 'immutable';\n/* Common Packages */\nimport webpackConfig from '../../webpack.config';\nimport routes from '../common/routes';\nimport configureStore from '../common/store/configureStore';\nimport fetchComponentData from '../common/utils/fetchComponentData';\nimport apiRoutes from './controllers/api.js';\n/* config */\n// 初始化 Express server\nconst app = new Express();\nconst port = process.env.PORT || 3000;\n// 连接到资料库，相关设定档案放在 config.database\nmongoose.connect(config.database); // connect to database\napp.set('env', 'production');\n// 设定静态档案位置\napp.use('/static', Express.static(__dirname + '/public'));\napp.use(cookieParser());\n// use body parser so we can get info from POST and/or URL parameters\napp.use(bodyParser.urlencoded({ extended: false })); // only can deal with key/value\napp.use(bodyParser.json());\n// use morgan to log requests to the console\napp.use(morgan('dev'));\n\n// 负责每次接受到 request 的处理函数，判断该如何处理和取得 initialState 整理后结合伺服器渲染页面传往前端\nconst handleRender = (req, res) => {\n  // Query our mock API asynchronously\n  match({ routes, location: req.url }, (error, redirectLocation, renderProps) => {\n    if (error) {\n      res.status(500).send(error.message);\n    } else if (redirectLocation) {\n      res.redirect(302, redirectLocation.pathname + redirectLocation.search);\n    } else if (renderProps == null) {\n      res.status(404).send('Not found');\n    }\n    fetchComponentData(req.cookies.token).then((response) => {\n      let isAuthorized = false;\n      if (response[1].data.success === true) {\n         isAuthorized = true;\n      } else {\n        isAuthorized = false;        \n      }\n      const initialState = fromJS({\n        recipe: {\n          recipes: response[0].data,\n          recipe: {\n            id: '',\n            name: '', \n            description: '', \n            imagePath: '',            \n          }  \n        },\n        user: {\n          isAuthorized: isAuthorized,\n          isEdit: false,\n        }\n      });\n      // server side 渲染页面\n      // Create a new Redux store instance\n      const store = configureStore(initialState);\n      const initView = renderToString(\n        <Provider store={store}>\n          <RouterContext {...renderProps} />\n        </Provider>\n      );\n      let state = store.getState();\n      let page = renderFullPage(initView, state);\n      return res.status(200).send(page);\n    })\n    .catch(err => res.end(err.message));\n  })\n}\n\n// 基础页面 HTML 设计\nconst renderFullPage = (html, preloadedState) => (`\n    <!doctype html>\n    <html>\n      <head>\n        <title>OpenCook 分享料理的美好时光</title>\n        <!-- Latest compiled and minified CSS -->\n        <link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css\">\n        <!-- Optional theme -->\n        <link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap-theme.min.css\">\n        <link rel=\"stylesheet\" href=\"//maxcdn.bootstrapcdn.com/bootswatch/3.3.7/journal/bootstrap.min.css\">\n      <body>\n        <div id=\"app\">${html}</div>\n        <script>\n          window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace(/</g, '\\\\x3c')}\n        </script>\n        <script src=\"/static/bundle.js\"></script>\n      </body>\n    </html>`\n);\n\n// 设定 hot reload middleware\nconst compiler = webpack(webpackConfig);\napp.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: webpackConfig.output.publicPath }));\napp.use(webpackHotMiddleware(compiler));\n\n// 设计 API prefix，并使用 controller 中的 apiRoutes 进行处理\napp.use('/api', apiRoutes);  \n// 使用伺服器端 handleRender \napp.use(handleRender);\napp.listen(port, (error) => {\n  if (error) {\n    console.error(error)\n  } else {\n    console.info(`==> 🌎  Listening on port ${port}. Open up http://localhost:${port}/ in your browser.`)\n  }\n});\n```\n\n由于 Node 端要到新版对于 ES6 支援较好，所以先用 `babel-register` 在 `src/server/index.js` 去即时转译 `server.js`，但目前不建议在 `production` 环境使用。\n\n```javascript\n// use babel-register to precompile ES6 syntax\nrequire('babel-register');\nrequire('./server');\n```\n\n现在我们来设计一下我们资料库的 Schema，在这边我们使用 MongoDB 的 ORM Mongoose，可以方便我们使用物件方式进行资料库的操作：\n\n```javascript\n// 引入 mongoose 和 Schema\nimport mongoose, { Schema } from 'mongoose';\n\n// 使用 mongoose.model 建立新的资料表，并将 Schema 传入\n// 这边我们设计了食谱分享的一些基本要素，包括名称、描述、照片位置等\nexport default mongoose.model('Recipe', new Schema({ \n    id: String,\n    name: String, \n    description: String, \n    imagePath: String,\n    steps: Array,\n    updatedAt: Date,\n}));\n```\n\n```javascript\n// 引入 mongoose 和 Schema\nimport mongoose, { Schema } from 'mongoose';\n\n// 使用 mongoose.model 建立新的资料表，并将 Schema 传入\n// 这边我们设计了使用者的一些基本要素，包括名称、描述、照片位置等\nexport default mongoose.model('User', new Schema({ \n    id: Number,\n    username: String, \n    email: String,\n    password: String, \n    admin: Boolean \n}));\n```\n\n为了方便维护，我们把 API 的部份统一在 `src/server/controllers/api.js` 进行管理，这部份会涉及比较多 Node 和 mongoose 的操作，若读者尚不熟悉可以参考 [mongoose 官网](http://mongoosejs.com/)\n\n```javascript\nimport Express from 'express';\n// 引入 jsonwebtoken 套件 \nimport jwt from 'jsonwebtoken';\n// 引入 User、Recipe Model 方便进行资料库操作\nimport User from '../models/user';\nimport Recipe from '../models/recipe';\nimport config from '../config';\n\n// API Route\nconst app = new Express();\nconst apiRoutes = Express.Router();\n// 设定 JSON Web Token 的 secret variable\napp.set('superSecret', config.secret); // secret variable\n// 使用者登入 API ，依据使用 email 和 密码去验证，若成功则回传一个认证 token（时效24小时）我们把它存在 cookie 中，方便前后端存取。这边我们先不考虑太多资讯安全的议题\napiRoutes.post('/login', function(req, res) {\n  // find the user\n  User.findOne({\n    email: req.body.email\n  }, (err, user) => {\n    if (err) throw err;\n    if (!user) {\n      res.json({ success: false, message: 'Authentication failed. User not found.' });\n    } else if (user) {\n      // check if password matches\n      if (user.password != req.body.password) {\n        res.json({ success: false, message: 'Authentication failed. Wrong password.' });\n      } else {\n        // if user is found and password is right\n        // create a token\n        const token = jwt.sign({ email: user.email }, app.get('superSecret'), {\n          expiresIn: 60 * 60 * 24 // expires in 24 hours\n        });\n        // return the information including token as JSON\n        // 若登入成功回传一个 json 讯息\n        res.json({\n          success: true,\n          message: 'Enjoy your token!',\n          token: token,\n          userId: user._id\n        });\n      }   \n    }\n  });\n});\n// 初始化 api，一开始资料库尚未建立任何使用者，我们需要在浏览器输入 `http://localhost:3000/api/setup`，进行资料库初始化。这个动作将新增一个使用者、一份食谱，若是成功新增将回传一个 success 讯息\napiRoutes.get('/setup', (req, res) => {\n  // create a sample user\n  const sampleUser = new User({ \n    username: 'mark', \n    email: 'mark@demo.com', \n    password: '123456',\n    admin: true \n  });\n  const sampleRecipe = new Recipe({\n    id: '110ec58a-a0f2-4ac4-8393-c866d813b8d1',\n    name: '番茄炒蛋', \n    description: '番茄炒蛋，一道非常经典的家常菜料理。虽然看似普通，但每个家庭都有属于自己家裡的不同味道', \n    imagePath: 'https://c1.staticflickr.com/6/5011/5510599760_6668df5a8a_z.jpg',\n    steps: ['放入番茄', '打个蛋', '放入少许盐巴', '用心快炒'],\n    updatedAt: new Date()\n  });\n  // save the sample user\n  sampleUser.save((err) => {\n    if (err) throw err;\n    sampleRecipe.save((err) => {\n      if (err) throw err;\n      console.log('User saved successfully');\n      res.json({ success: true });      \n    })\n  });\n});\n// 回传所有 recipes\napiRoutes.get('/recipes', (req, res) => {\n  Recipe.find({}, (err, recipes) => {\n    res.status(200).json(recipes);\n  })\n});\n\n// route middleware to verify a token\n// 接下来的 api 将进行控管，也就是说必须在网址请求中夹带认证 token 才能完成请求\napiRoutes.use((req, res, next) => {\n  // check header or url parameters or post parameters for token\n  // 确认标头、网址或 post 参数是否含有 token，本范例因为简便使用网址 query 参数 \n  var token = req.body.token || req.query.token || req.headers['x-access-token'];\n  // decode token\n  if (token) {\n    // verifies secret and checks exp\n    jwt.verify(token, app.get('superSecret'), (err, decoded) => {      \n      if (err) {\n        return res.json({ success: false, message: 'Failed to authenticate token.' });    \n      } else {\n        // if everything is good, save to request for use in other routes\n        req.decoded = decoded;    \n        next();\n      }\n    });\n  } else {\n    // if there is no token\n    // return an error\n    return res.status(403).send({ \n        success: false, \n        message: 'No token provided.' \n    });\n  }\n});\n// 确认认证是否成功\napiRoutes.get('/authenticate', (req, res) => {\n  res.json({\n    success: true,\n    message: 'Enjoy your token!',\n  });\n});\n// create recipe 新增食谱\napiRoutes.post('/recipes', (req, res) => {\n  const newRecipe = new Recipe({\n    name: req.body.name, \n    description: req.body.description, \n    imagePath: req.body.imagePath,\n    steps: ['放入番茄', '打个蛋', '放入少许盐巴', '用心快炒'],\n    updatedAt: new Date()\n  });\n  newRecipe.save((err) => {\n    if (err) throw err;\n    console.log('User saved successfully');\n    res.json({ success: true });      \n  });\n}); \n// update recipe 根据 _id（mongodb 的 id）更新食谱\napiRoutes.put('/recipes/:id', (req, res) => {\n  Recipe.update({ _id: req.params.id }, {\n    name: req.body.name, \n    description: req.body.description, \n    imagePath: req.body.imagePath,\n    steps: ['放入番茄', '打个蛋', '放入少许盐巴', '用心快炒'],\n    updatedAt: new Date()\n  } ,(err) => {\n    if (err) throw err;\n    console.log('User updated successfully');\n    res.json({ success: true });      \n  });\n});\n// remove recipe 根据 _id 删除食谱，若成功回传成功讯息\napiRoutes.delete('/recipes/:id', (req, res) => {\n  Recipe.remove({ _id: req.params.id }, (err, recipe) => {\n    if (err) throw err;\n    console.log('remove saved successfully');\n    res.json({ success: true }); \n  });\n}); \nexport default apiRoutes;\n```\n\n设定整个 App 的 routing，我们主要页面有 `HomePageContainer`、`LoginPageContainer`、`SharePageContainer`，值得注意的是我们这边使用 [Higher Order Components](http://www.darul.io/post/2016-01-05_react-higher-order-components) （Higher Order Components 为一个函数， 接收一个 Component 后在 Class Component 的 render 中 return 回传入的 components）方式去确认使用者是否有登入，若有没登入则不能进入分享食谱页面，反之若已登入也不会再进到登入页面：\n\n```javascript\nimport React from 'react';\nimport { Route, IndexRoute } from 'react-router';\nimport Main from '../components/Main';\nimport CheckAuth from '../components/CheckAuth';\nimport HomePageContainer from '../containers/HomePageContainer';\nimport LoginPageContainer from '../containers/LoginPageContainer';\nimport SharePageContainer from '../containers/SharePageContainer';\n\nexport default (\n  <Route path='/' component={Main}>\n    <IndexRoute component={HomePageContainer} />\n    <Route path=\"/login\" component={CheckAuth(LoginPageContainer, 'guest')}/>\n    <Route path=\"/share\" component={CheckAuth(SharePageContainer, 'auth')}/>\n  </Route>\n);\n```\n\n设定行为常数（`src/constants/actionTypes.js`）：\n\n```javascript\nexport const AUTH_START    = \"AUTH_START\";\nexport const AUTH_COMPLETE = \"AUTH_COMPLETE\";\nexport const AUTH_ERROR    = \"AUTH_ERROR\";\nexport const START_LOGOUT    = \"START_LOGOUT\";\nexport const CHECK_AUTH    = \"CHECK_AUTH\";\nexport const SET_USER    = \"SET_USER\";\nexport const SHOW_SPINNER    = \"SHOW_SPINNER\";\nexport const HIDE_SPINNER    = \"HIDE_SPINNER\";\nexport const SET_UI    = \"SET_UI\";\nexport const GET_RECIPES = 'GET_RECIPES';\nexport const SET_RECIPE = 'SET_RECIPE';\nexport const ADD_RECIPE = 'ADD_RECIPE';\nexport const UPDATE_RECIPE = 'UPDATE_RECIPE';\nexport const DELETE_RECIPE = 'DELETE_RECIPE';\n```\n\n设定 `src/actions/recipeActions.js`，我们这边使用 redux-promise，可以很容易使用非同步的行为 WebAPI：  \n\n```javascript\nimport { createAction } from 'redux-actions';\nimport WebAPI from '../utils/WebAPI';\n\nimport {\n  GET_RECIPES,\n  ADD_RECIPE,\n  UPDATE_RECIPE,\n  DELETE_RECIPE,\n  SET_RECIPE,\n} from '../constants/actionTypes';\n\nexport const getRecipes = createAction('GET_RECIPES', WebAPI.getRecipes);\nexport const addRecipe = createAction('ADD_RECIPE', WebAPI.addRecipe);\nexport const updateRecipe = createAction('UPDATE_RECIPE', WebAPI.updateRecipe);\nexport const deleteRecipe = createAction('DELETE_RECIPE', WebAPI.deleteRecipe);\nexport const setRecipe = createAction('SET_RECIPE');\n```\n\n设定 `src/actions/uiActions.js`：\n\n```javascript\nimport { createAction } from 'redux-actions';\nimport WebAPI from '../utils/WebAPI';\n\nimport {\n  SHOW_SPINNER,\n  HIDE_SPINNER,\n  SET_UI,\n} from '../constants/actionTypes';\n\nexport const showSpinner = createAction('SHOW_SPINNER');\nexport const hideSpinner = createAction('HIDE_SPINNER');\nexport const setUi = createAction('SET_UI');\n```\n\n设定 `src/actions/userActions.js`，处理使用者登入登出等行为：\n\n```javascript\nimport { createAction } from 'redux-actions';\nimport WebAPI from '../utils/WebAPI';\n\nimport {\n  AUTH_START,\n  AUTH_COMPLETE,\n  AUTH_ERROR,\n  START_LOGOUT,\n  CHECK_AUTH,\n  SET_USER\n} from '../constants/actionTypes';\n\nexport const authStart = createAction('AUTH_START', WebAPI.login);\nexport const authComplete = createAction('AUTH_COMPLETE');\nexport const authError = createAction('AUTH_ERROR');\nexport const startLogout = createAction('START_LOGOUT', WebAPI.logout);\nexport const checkAuth = createAction('CHECK_AUTH');\nexport const setUser = createAction('SET_USER');\n```\n\n于 `scr/actions/index.js` 输出 actions：\n\n```javascript\nexport * from './userActions';\nexport * from './recipeActions';\nexport * from './uiActions';\n```\n\n于 `scr/common/utils/fetchComponentData.js` 设定 server side 初始 fetchComponentData：\n\n```javascript\n// 这边使用 axios 方便进行 promises base request\nimport axios from 'axios';\n// 记得附加上我们存在 cookies 的 token  \nexport default function fetchComponentData(token = 'token') {\n  const promises = [axios.get('http://localhost:3000/api/recipes'), axios.get('http://localhost:3000/api/authenticate?token=' + token)];\n  return Promise.all(promises);\n}\n```\n\n于 `scr/common/utils/WebAPI.js` 所有前端 API 的处理：\n\n```javascript\nimport axios from 'axios';\nimport { browserHistory } from 'react-router';\n// 引入 uuid 当做食谱 id\nimport uuid from 'uuid';\n\nimport { \n  authComplete,\n  authError,\n  hideSpinner,\n  completeLogout,\n} from '../actions';\n\n// getCookie 函数传入 key 回传 value\nfunction getCookie(keyName) {\n  var name = keyName + '=';\n  const cookies = document.cookie.split(';');\n  for(let i = 0; i < cookies.length; i++) {\n      let cookie = cookies[i];\n      while (cookie.charAt(0)==' ') {\n          cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(name) == 0) {\n        return cookie.substring(name.length, cookie.length);\n      }\n  }\n  return \"\";\n}\n\nexport default {\n  // 呼叫后端登入 api\n  login: (dispatch, email, password) => {\n    axios.post('/api/login', {\n      email: email,\n      password: password\n    })\n    .then((response) => {\n      if(response.data.success === false) {\n        dispatch(authError()); \n        dispatch(hideSpinner());  \n        alert('发生错误，请再试一次！');\n        window.location.reload();        \n      } else {\n        if (!document.cookie.token) {\n          let d = new Date();\n          d.setTime(d.getTime() + (24 * 60 * 60 * 1000));\n          const expires = 'expires=' + d.toUTCString();\n          document.cookie = 'token=' + response.data.token + '; ' + expires;\n          dispatch(authComplete());\n          dispatch(hideSpinner());  \n          browserHistory.push('/'); \n        }\n      }\n    })\n    .catch(function (error) {\n      dispatch(authError());\n    });\n  },\n  // 呼叫后端登出 api  \n  logout: (dispatch) => {\n    document.cookie = 'token=; ' + 'expires=Thu, 01 Jan 1970 00:00:01 GMT;';\n    dispatch(hideSpinner());  \n    browserHistory.push('/'); \n  },\n  // 确认使用者是否登入    \n  checkAuth: (dispatch, token) => {\n    axios.post('/api/authenticate', {\n      token: token,\n    })\n    .then((response) => {\n      if(response.data.success === false) {\n        dispatch(authError()); \n      } else {\n        dispatch(authComplete());\n      }\n    })\n    .catch(function (error) {\n      dispatch(authError());\n    });\n  },\n  // 取得目前所有食谱    \n  getRecipes: () => {\n    axios.get('/api/recipes')\n    .then((response) => {\n    })\n    .catch((error) => {\n    });\n  },\n  // 呼叫新增食谱 api，记得附加上我们存在 cookies 的 token  \n  addRecipe: (dispatch, name, description, imagePath) => {\n    const id = uuid.v4();\n    axios.post('/api/recipes?token=' + getCookie('token'), {\n      id: id,\n      name: name,\n      description: description,\n      imagePath: imagePath,\n    })\n    .then((response) => {\n      if(response.data.success === false) {\n        dispatch(hideSpinner());  \n        alert('发生错误，请再试一次！');\n        browserHistory.push('/share');         \n      } else {\n        dispatch(hideSpinner());  \n        window.location.reload();        \n        browserHistory.push('/'); \n      }\n    })\n    .catch(function (error) {\n    });\n  },\n  // 呼叫更新食谱 api，记得附加上我们存在 cookies 的 token  \n  updateRecipe: (dispatch, recipeId, name, description, imagePath) => {\n    axios.put('/api/recipes/' + recipeId + '?token=' + getCookie('token'), {\n      id: recipeId,\n      name: name,\n      description: description,\n      imagePath: imagePath,\n    })\n    .then((response) => {\n      if(response.data.success === false) {\n        dispatch(hideSpinner());  \n        dispatch(setRecipe({ key: 'recipeId', value: '' }));\n        dispatch(setUi({ key: 'isEdit', value: false }));\n        alert('发生错误，请再试一次！');\n        browserHistory.push('/share');         \n      } else {\n        dispatch(hideSpinner());  \n        window.location.reload();        \n        browserHistory.push('/'); \n      }\n    })\n    .catch(function (error) {\n    });\n  },\n  // 呼叫删除食谱 api，记得附加上我们存在 cookies 的 token  \n  deleteRecipe: (dispatch, recipeId) => {\n    axios.delete('/api/recipes/' + recipeId + '?token=' + getCookie('token'))\n    .then((response) => {\n      if(response.data.success === false) {\n        dispatch(hideSpinner());  \n        alert('发生错误，请再试一次！');\n        browserHistory.push('/');         \n      } else {\n        dispatch(hideSpinner());  \n        window.location.reload();        \n        browserHistory.push('/'); \n      }\n    })\n    .catch(function (error) {\n    });    \n  } \n};\n```\n\n接下来设定我们的 `reducers`，以下是 `src/common/reducers/data/recipeReducers.js`，`GET_RECIPES` 负责将后端 API 取得的所有食谱存放在 recipes 中：\n\n```javascript\nimport { handleActions } from 'redux-actions';\nimport { RecipeState } from '../../constants/models';\n\nimport {\n  GET_RECIPES,\n  SET_RECIPE,\n} from '../../constants/actionTypes';\n\nconst recipeReducers = handleActions({\n  GET_RECIPES: (state, { payload }) => (\n    state.set(\n      'recipes',\n      payload.recipes\n    )\n  ),\n  SET_RECIPE: (state, { payload }) => (\n    state.setIn(payload.keyPath, payload.value)\n  ),  \n}, RecipeState);\n\nexport default recipeReducers;\n```\n\n以下是 `src/common/reducers/data/userReducers.js`，负责确认登入相关处理事项。注意的是由于登入是非同步执行，所以会有几个阶段的行为要做处理：\n\n```javascript\nimport { handleActions } from 'redux-actions';\nimport { UserState } from '../../constants/models';\n\nimport {\n  AUTH_START,\n  AUTH_COMPLETE,\n  AUTH_ERROR,\n  LOGOUT_START,\n  SET_USER,\n} from '../../constants/actionTypes';\n\nconst userReducers = handleActions({\n  AUTH_START: (state) => (\n    state.merge({\n      isAuthorized: false,      \n    })\n  ),  \n  AUTH_COMPLETE: (state) => (\n    state.merge({\n      email: '',\n      password: '',\n      isAuthorized: true,\n    })\n  ),  \n  AUTH_ERROR: (state) => (\n    state.merge({\n      username: '',\n      email: '',\n      password: '',\n      isAuthorized: false,\n    })\n  ),  \n  START_LOGOUT: (state) => (\n    state.merge({\n      isAuthorized: false,      \n    })\n  ), \n  CHECK_AUTH: (state) => (\n    state.set('isAuthorized', true)\n  ),\n  SET_USER: (state, { payload }) => (\n    state.set(payload.key, payload.value)\n  ),\n}, UserState);\n\nexport default userReducers;\n\n```\n\n以下是 `src/common/reducers/ui/uiReducers.js`，负责确认 UI State 相关处理：\n\n\n```javascript\nimport { handleActions } from 'redux-actions';\nimport { UiState } from '../../constants/models';\n\nimport {\n  SHOW_SPINNER,\n  HIDE_SPINNER,\n  SET_UI,\n} from '../../constants/actionTypes';\n\nconst uiReducers = handleActions({\n  SHOW_SPINNER: (state) => (\n    state.set(\n      'spinnerVisible',\n      true\n    )\n  ),\n  HIDE_SPINNER: (state) => (\n    state.set(\n      'spinnerVisible',\n      false\n    )\n  ),\n  SET_UI: (state, { payload }) => (\n    state.set(payload.key, payload.value)\n  ),    \n}, UiState);\n\nexport default uiReducers;\n```\n\n最后把所有 recipes 在 `src/common/reducers/index.js` 使用 `combineReducers` 整合在一起，注意的是我们整个 App 的资料流要维持 immutable： \n\n```javascript\nimport { combineReducers } from 'redux-immutable';\nimport ui from './ui/uiReducers';\nimport recipe from './data/recipeReducers';\nimport user from './data/userReducers';\n// import routes from './routes';\n\nconst rootReducer = combineReducers({\n  ui,\n  recipe,\n  user,\n});\n\nexport default rootReducer;\n```\n\n以下是 `src/common/store/configureStore.js` 处理 store 的建立，这次我们使用了 `promiseMiddleware` 的 middleware：\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport promiseMiddleware from 'redux-promise';\nimport createLogger from 'redux-logger';\nimport Immutable from 'immutable';\nimport rootReducer from '../reducers';\n\nconst initialState = Immutable.Map();\n\nexport default function configureStore(preloadedState = initialState) {\n  const store = createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware(createLogger({ stateTransformer: state => state.toJS() }, promiseMiddleware))\n  );\n\n  return store;\n}\n```\n\n经过一连串努力，我们来到了 View 的佈建。在这个 App 中我们主要会由一个 AppBar 负责所有页面的导览，也就是每个页面都会有 AppBar 常驻在上面，然而上面的内容则会依 UI State 中的 isAuthorized 而有所不同。最后要留意的是我们使用了 React Bootstrapt 来建立 React Component。\n\n```javascript\nimport React from 'react';\nimport { LinkContainer } from 'react-router-bootstrap';\nimport { Link } from 'react-router';\nimport { Navbar, Nav, NavItem, NavDropdown, MenuItem } from 'react-bootstrap';\n\nconst AppBar = ({\n  isAuthorized,\n  onToShare,\n  onLogout,\n}) => (\n  <Navbar>\n    <Navbar.Header>\n      <Navbar.Brand>\n        <Link to=\"/\">OpenCook</Link>\n      </Navbar.Brand>\n      <Navbar.Toggle />\n    </Navbar.Header>\n    <Navbar.Collapse>\n      {\n        isAuthorized === false ?\n        (\n          <Nav pullRight>\n            <LinkContainer to={{ pathname: '/login' }}><NavItem eventKey={2} href=\"#\">登入</NavItem></LinkContainer>\n          </Nav>\n        ) :\n        (\n          <Nav pullRight>\n            <NavItem eventKey={1} onClick={onToShare}>分享食谱</NavItem>\n            <NavItem eventKey={2} onClick={onLogout} href=\"#\">登出</NavItem>\n          </Nav>\n        )        \n      }\n    </Navbar.Collapse>\n  </Navbar>\n);\n\nexport default AppBar;\n```\n\n以下是 `src/common/containers/AppBarContainer/AppBarContainer.js`：\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport AppBar from '../../components/AppBar';\nimport { browserHistory } from 'react-router';\n\nimport {\n  startLogout,\n  setRecipe,\n  setUi,\n} from '../../actions';\n\nexport default connect(\n  (state) => ({\n    isAuthorized: state.getIn(['user', 'isAuthorized']),\n  }),\n  (dispatch) => ({\n    onToShare: () => {\n      dispatch(setRecipe({ key: 'recipeId', value: '' }));\n      dispatch(setUi({ key: 'isEdit', value: false }));\n      window.location.reload();        \n      browserHistory.push('/share'); \n    },\n    onLogout: () => (\n      dispatch(startLogout(dispatch))\n    ),\n  })\n)(AppBar);\n```\n\n以下是 `src/components/Main/Main.js`，透过 route 机制让 AppBarContainer 可以成为整个 App 母模版：\n\n```javascript\nimport React from 'react';\nimport AppBarContainer from '../../containers/AppBarContainer';\n\nconst Main = (props) => (\n  <div>\n    <AppBarContainer />\n    <div>\n      {props.children}\n    </div>\n  </div>\n);\n\nexport default Main;\n```\n\n 在 `checkAuth` 这个 Component 中，我们使用到了 Higher Order Components 的观念。Higher Order Components 为一个函数， 接收一个 Component 后在 Class Component 的 render 中 return 回传入的 components 方式去确认使用者是否有登入，若有没登入则不能进入分享食谱页面，反之若已登入也不会再进到登入页面：\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { withRouter } from 'react-router';\n\n// High Order Component\nexport default function requireAuthentication(Component, type) {\n  class AuthenticatedComponent extends React.Component {\n    componentWillMount() {\n      this.checkAuth();\n    }\n    componentWillReceiveProps(nextProps) {\n      this.checkAuth();\n    }\n    checkAuth() {\n      if(type === 'auth') {\n        if (!this.props.isAuthorized) {\n          this.props.router.push('/');\n        }        \n      } else {\n        if (this.props.isAuthorized) {\n          this.props.router.push('/');\n        }                \n      }\n    }\n    render() {\n      return ( \n        <div> \n        {\n          (type === 'auth') ?\n          this.props.isAuthorized === true ? <Component {...this.props } /> : null\n          : this.props.isAuthorized === false ? <Component {...this.props } /> : null\n        } \n        </div>\n      )\n    }\n  };\n  const mapStateToProps = (state) => ({\n    isAuthorized: state.getIn(['user', 'isAuthorized']),\n  });\n  return connect(mapStateToProps)(withRouter(AuthenticatedComponent));\n}\n```\n\n我们将每个食谱呈现设计成 RecipeBox，以下是在 `src/common/components/HomePage/HomePage.js` 使用 map 方法去迭代我们的食谱：\n\n```javascript\nimport React from 'react';\nimport RecipeBoxContainer from '../../containers/RecipeBoxContainer';\n\nconst HomePage = ({\n  recipes\n}) => (\n  <div>        \n  {\n    recipes.map((recipe, index) => (\n      <RecipeBoxContainer recipe={recipe} key={index}  />\n    )).toJS()\n  }\n  </div>\n);\n\nexport default HomePage;\n```\n\n以下是 `src/common/containers/HomePageContainer/HomePageContainer.js`：\n\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport HomePage from '../../components/HomePage';\n\nexport default connect(\n  (state) => ({\n    recipes: state.getIn(['recipe', 'recipes']),    \n  }),\n  (dispatch) => ({\n  })\n)(HomePage);\n```\n\n在 `src/common/components/LoginBox/LoginBox.js` 设计我们 LoginBox：\n\n```javascript\nimport React from 'react';\nimport { Form, FormGroup, Button, FormControl, ControlLabel } from 'react-bootstrap';\n\nconst LoginBox = ({\n  email,\n  password,\n  onChangeEmailInput,\n  onChangePasswordInput,\n  onLoginSubmit\n}) => (\n  <div>\n    <Form horizontal>\n      <FormGroup\n        controlId=\"formBasicText\"\n      >\n        <ControlLabel>请输入您的 Email</ControlLabel>\n        <FormControl\n          type=\"text\"\n          onChange={onChangeEmailInput}\n          placeholder=\"Enter Email\"\n        />\n        <FormControl.Feedback />\n      </FormGroup>\n      <FormGroup\n        controlId=\"formBasicText\"\n      >\n        <ControlLabel>请输入您的密码</ControlLabel>\n        <FormControl\n          type=\"password\"\n          onChange={onChangePasswordInput}\n          placeholder=\"Enter Password\"\n        />\n        <FormControl.Feedback />\n      </FormGroup>\n      <Button \n        onClick={onLoginSubmit} \n        bsStyle=\"success\" \n        bsSize=\"large\" \n        block\n      >\n        提交送出\n      </Button>\n    </Form>\n  </div>\n);\n\nexport default LoginBox;\n```\n\n以下是 `src/common/containers/LoginBoxContainer/LoginBoxContainer.js`：\n\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport LoginBox from '../../components/LoginBox';\n\nimport { \n  authStart,\n  showSpinner,\n  setUser,\n} from '../../actions';\n\nexport default connect(\n  (state) => ({\n    email: state.getIn(['user', 'email']),\n    password: state.getIn(['user', 'password']),\n  }),\n  (dispatch) => ({\n    onChangeEmailInput: (event) => (\n      dispatch(setUser({ key: 'email', value: event.target.value }))\n    ),\n    onChangePasswordInput: (event) => (\n      dispatch(setUser({ key: 'password', value: event.target.value }))\n    ),\n    onLoginSubmit: (email, password) => () => {\n      dispatch(authStart(dispatch, email, password));\n      dispatch(showSpinner());\n    },\n  }),\n  (stateProps, dispatchProps, ownProps) => {\n    const { email, password } = stateProps;\n    const { onLoginSubmit } = dispatchProps;\n    return Object.assign({}, stateProps, dispatchProps, ownProps, {\n      onLoginSubmit: onLoginSubmit(email, password),\n    });\n  }\n)(LoginBox);\n\n```\n\n在 `src/common/components/LoginPage/LoginPage.js`，当 spinnerVisible 为 true 会显示 spinner：\n\n\n```javascript\nimport React from 'react';\nimport { Grid, Row, Col, Image } from 'react-bootstrap';\nimport LoginBoxContainer from '../../containers/LoginBoxContainer';\n\nconst LoginPage = ({\n  spinnerVisible,\n}) => (\n  <div>\n    <Row className=\"show-grid\">\n      <Col xs={6} xsOffset={3}>\n        <LoginBoxContainer />\n        { spinnerVisible === true ?\n          <Image src=\"/static/images/loading.gif\" /> :\n          null\n        }\n      </Col>\n    </Row>\n  </div>\n);\n\nexport default LoginPage;\n```\n\n以下是 `src/common/containers/LoginPageContainer/LoginPageContainer.js`：\n\n\n```\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport LoginPage from '../../components/LoginPage';\n\nexport default connect(\n  (state) => ({\n    spinnerVisible: state.getIn(['ui', 'spinnerVisible']),\n  }),\n  (dispatch) => ({\n  })\n)(LoginPage);\n\n\n```\n\n真正设计我们内部的食谱， `src/common/components/RecipeBox`，使用者登入的话可以修改和删除食谱：\n\n```javascript\nimport React from 'react';\nimport { Grid, Row, Col, Image, Thumbnail, Button } from 'react-bootstrap';\n\nconst RecipeBox = (props) => {\n  return(\n      <Col xs={6} md={4}>\n        <Thumbnail src={props.recipe.get('imagePath')} alt=\"242x200\">\n          <h3>{props.recipe.get('name')}</h3>\n          <p>{props.recipe.get('description')}</p>\n          {\n            props.isAuthorized === true ? (\n            <p>\n              <Button bsStyle=\"primary\" onClick={props.onDeleteRecipe(props.recipe.get('_id'))}>删除</Button>&nbsp;\n              <Button bsStyle=\"default\" onClick={props.onUpadateRecipe(props.recipe.get('_id'))}>修改</Button>\n            </p>)\n            : null            \n          }\n        </Thumbnail>\n      </Col>\n    );\n}\n\nexport default RecipeBox;\n```\n\n以下是 `src/common/containers/RecipeBoxContainer/RecipeBoxContainer.js`：\n\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport RecipeBox from '../../components/RecipeBox';\nimport { browserHistory } from 'react-router';\n\nimport {\n  deleteRecipe,\n  setRecipe,\n  setUi\n} from '../../actions';\n\nexport default connect(\n  (state) => ({\n    isAuthorized: state.getIn(['user', 'isAuthorized']),\n    recipes: state.getIn(['recipe', 'recipes']),\n  }),\n  (dispatch) => ({\n    onDeleteRecipe: (recipeId) => () => (\n      dispatch(deleteRecipe(dispatch, recipeId))\n    ),\n    onUpadateRecipe: (recipes) => (recipeId) => () => {\n      const recipeIndex = recipes.findIndex((_recipe) => (_recipe.get('_id') === recipeId));\n      const recipe = recipeIndex !== -1 ? recipes.get(recipeIndex) : undefined;\n      dispatch(setRecipe({ keyPath: ['recipe'], value: recipe }));\n      dispatch(setRecipe({ keyPath: ['recipe', 'id'], value: recipeId }));\n      dispatch(setUi({ key: 'isEdit', value: true }));\n      browserHistory.push('/share?recipeId=' + recipeId); \n    },\n  }),\n  (stateProps, dispatchProps, ownProps) => {\n    const { recipes } = stateProps; \n    const { onUpadateRecipe } = dispatchProps; \n    return Object.assign({}, stateProps, dispatchProps, ownProps, {\n      onUpadateRecipe: onUpadateRecipe(recipes),\n    });\n  }\n)(RecipeBox);\n\n\n```\n\n\n设计我们分享食谱页面，这边我们把编辑食谱和新增分享一起共用了同一个 components，差别在于我们会判断 UI State 中的 `isEdit`， 决定相应处理方式。在中 `src/common/components/ShareBox/ShareBox.js`，可以让使用者登入的后修改和删除食谱：\n\n\n```javascript\nimport React from 'react';\nimport { Form, FormGroup, Button, FormControl, ControlLabel } from 'react-bootstrap';\n\nconst ShareBox = (props) => {\n  return (<div>\n    <Form horizontal>\n      <FormGroup\n        controlId=\"formBasicText\"\n      >\n        <ControlLabel>请输入食谱名称</ControlLabel>\n        <FormControl\n          type=\"text\"\n          placeholder=\"Enter text\"\n          defaultValue={props.name}\n          onChange={props.onChangeNameInput}\n        />\n        <FormControl.Feedback />\n      </FormGroup>\n      <FormGroup\n        controlId=\"formBasicText\"\n      >\n        <ControlLabel>请输入食谱说明</ControlLabel>\n        <FormControl \n          componentClass=\"textarea\" \n          placeholder=\"textarea\" \n          defaultValue={props.description}          \n          onChange={props.onChangeDescriptionInput}\n        />\n        <FormControl.Feedback />\n      </FormGroup>\n      <FormGroup\n        controlId=\"formBasicText\"\n      >\n        <ControlLabel>请输入食谱图片网址</ControlLabel>\n        <FormControl\n          type=\"text\"\n          placeholder=\"Enter text\"\n          defaultValue={props.imagePath}\n          onChange={props.onChangeImageUrl}\n        />\n        <FormControl.Feedback />\n      </FormGroup>\n      <Button \n        onClick={props.onRecipeSubmit} \n        bsStyle=\"success\" \n        bsSize=\"large\" \n        block\n      >\n        提交送出\n      </Button>\n    </Form>\n  </div>);\n};\n\nexport default ShareBox;\n```\n\n以下是 `src/common/containers/ShareBoxContainer/ShareBoxContainer.js`：\n\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport ShareBox from '../../components/ShareBox';\n\nimport { \n  addRecipe,\n  updateRecipe,\n  showSpinner,\n  setRecipe,\n} from '../../actions';\n\nexport default connect(\n  (state) => ({\n    recipes: state.getIn(['recipe', 'recipes']),\n    recipeId: state.getIn(['recipe', 'recipe', 'id']),\n    name: state.getIn(['recipe', 'recipe', 'name']),\n    description: state.getIn(['recipe', 'recipe', 'description']),\n    imagePath: state.getIn(['recipe', 'recipe', 'imagePath']),\n    isEdit: state.getIn(['ui', 'isEdit']),\n  }),\n  (dispatch) => ({\n    onChangeNameInput: (event) => (\n      dispatch(setRecipe({ keyPath: ['recipe', 'name'], value: event.target.value }))\n    ),\n    onChangeDescriptionInput: (event) => (\n      dispatch(setRecipe({ keyPath: ['recipe', 'description'], value: event.target.value }))\n    ),\n    onChangeImageUrl: (event) => (\n      dispatch(setRecipe({ keyPath: ['recipe', 'imagePath'], value: event.target.value }))\n    ),    \n    onRecipeSubmit: (recipes, recipeId, name, description, imagePath, isEdit) => () => {\n      if (isEdit === true) {\n        dispatch(updateRecipe(dispatch, recipeId, name, description, imagePath));\n        dispatch(showSpinner());\n      } else {\n        dispatch(addRecipe(dispatch, name, description, imagePath));\n        dispatch(showSpinner());\n      }\n    },    \n  }),\n  (stateProps, dispatchProps, ownProps) => {\n    const { recipes, recipeId, name, description, imagePath, isEdit } = stateProps;\n    const { onRecipeSubmit } = dispatchProps;\n    return Object.assign({}, stateProps, dispatchProps, ownProps, {\n      onRecipeSubmit: onRecipeSubmit(recipes, recipeId, name, description, imagePath, isEdit),\n    });\n  }  \n)(ShareBox);\n\n\n```\n\n单纯的 SharePage（`src/common/components/SharePage/SharePage.js`）页面：\n\n```javascript\nimport React from 'react';\nimport { Grid, Row, Col } from 'react-bootstrap';\nimport ShareBoxContainer from '../../containers/ShareBoxContainer';\n\nconst SharePage = () => (\n  <div>\n    <Row className=\"show-grid\">\n      <Col xs={6} xsOffset={3}>\n        <ShareBoxContainer />\n      </Col>\n    </Row>\n  </div>\n);\n\nexport default SharePage;\n```\n\n以下是 `src/common/containers/SharePageContainer/SharePageContainer.js`：\n\n\n```javascript\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport SharePage from '../../components/SharePage';\n\nexport default connect(\n  (state) => ({\n  }),\n  (dispatch) => ({\n  })\n)(SharePage);\n```\n\n恭喜你成功抵达终点！若一切顺利，在终端机打上 `$ npm start`，你将可以在浏览器的 `http://localhost:3000` 看到自己的成果！\n\n\n## 总结\n本章整合过去所学和添加一些后端资料库知识开发了一个可以登入会员并分享食谱的社群网站！快把你的成果和你的朋友分享吧！觉得意犹未尽？别忘了附录也很精采！最后，再次谢谢读者们支持我们一路走完了 React 开发学习之旅！然而前端技术变化很快，唯有不断自我学习才能持续成长。笔者才疏学浅，撰写学习心得或有疏漏，若有任何建议或提醒都欢迎和我说，大家一起加油：）\n\n## 延伸阅读\n1. [joshgeller/react-redux-jwt-auth-example](https://github.com/joshgeller/react-redux-jwt-auth-example)\n2. [Securing React Redux Apps With JWT Tokens](https://medium.com/@rajaraodv/securing-react-redux-apps-with-jwt-tokens-fcfe81356ea0#.5hfri5j5m)\n3. [Adding Authentication to Your React Native App Using JSON Web Tokens](https://auth0.com/blog/adding-authentication-to-react-native-using-jwt/)\n4. [Authentication in React Applications, Part 2: JSON Web Token (JWT)](http://vladimirponomarev.com/blog/authentication-in-react-apps-jwt)\n5. [Node.js 身份认证：Passport 入门](https://nodejust.com/nodejs-passport-auth-tutorial/)\n6. [react-bootstrap compatibility #83](https://github.com/reactjs/react-router/issues/83)\n7. [How to authenticate routes using Passport? #725](https://github.com/reactjs/react-router/issues/725)\n8. [Isomorphic React Web App Demo with Material UI](https://github.com/tech-dojo/react-showcase)\n9. [react-router/examples/auth-flow/](https://github.com/reactjs/react-router/tree/master/examples/auth-flow)\n10. [redux-promise](https://github.com/acdlite/redux-promise)\n11. [How to use redux-promise](http://qiita.com/takaki@github/items/42bddf01d36dc18bdc8e)\n12. [Authenticate a Node.js API with JSON Web Tokens](https://scotch.io/tutorials/authenticate-a-node-js-api-with-json-web-tokens)\n13. [3 JavaScript ORMs You Might Not Know](https://www.sitepoint.com/3-javascript-orms-you-might-not-know/)\n14. [lynndylanhurley/redux-auth](https://github.com/lynndylanhurley/redux-auth)\n15. [How to avoid getting error 'localStorage is not defined' on server in ReactJS isomorphic app?](http://stackoverflow.com/questions/33724396/how-to-avoid-getting-error-localstorage-is-not-defined-on-server-in-reactjs-is)\n16. [Where to Store your JWTs – Cookies vs HTML5 Web Storage](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage)\n17. [What is the difference between server side cookie and client side cookie? [closed]](http://stackoverflow.com/questions/6922145/what-is-the-difference-between-server-side-cookie-and-client-side-cookie)\n18. [Cookies vs Tokens. Getting auth right with Angular.JS](https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/)\n19. [Cookies vs Tokens: The Definitive Guide](https://auth0.com/blog/cookies-vs-tokens-definitive-guide/)\n20. [joshgeller/react-redux-jwt-auth-example](https://github.com/joshgeller/react-redux-jwt-auth-example)\n21. [Programmatically navigate using react router](http://stackoverflow.com/questions/31079081/programmatically-navigate-using-react-router)\n22. [withRouter HoC (higher-order component) v2.4.0 Upgrade Guide](https://github.com/reactjs/react-router/blob/master/upgrade-guides/v2.4.0.md)\n\n## License\nMIT, Special thanks [Loading.io](http://loading.io/)\n\n","tags":["reactjs"],"categories":["reactjs"]},{"title":"node保存base64编码的图片","url":"/nodejs/nodepost64file.html","content":"\n\n## 说明\nweb开发中经常遇到的一种场景就是保存图片到服务器，这里的服务器可能是专门的图片服务器也可能是\napi服务器。我们常用的做法就是利用标签为<code>input[type='file']</code>的DOM就客户端的\nfile对象拿到服务器进行处理，代码如下：\n```\nrouter.post('/uploadfile', multipart(), function (req, res, next) {\n  var files = req.files.files;\n  var filename = files.originalFilename || path.basename(files.path);\n  //复制文件到指定路径\n  var targetPath =  process.cwd() + '\\/uploads\\/' + filename;\n  //复制文件流\n  try{\n      var readable = fs.createReadStream(files.path).pipe(fs.createWriteStream(targetPath));\n      readable.on('close', function(){\n       neetupload(targetPath,function(code,data){\n        if(code === 500){\n            res.json(util.error(data));\n        }else{\n            res.json(util.success({\n                url:data\n           }));\n        }\n       });\n      });\n      readable.on('error', function(err){\n       res.json(util.error('上传失败'));\n     });\n\n  }catch(e){\n    res.json(util.error('上传失败'));\n  }\n});\n```\n\n原理就是通过文件流的方式就客户端文件copy到服务器然后上传到图片服务器上。\n但有时候面对大的图片文件的时候可能就比较慢了、不得不加上烦人的loading等待或者文件大小限制等。此时我们可以考虑在前端利用lrz对图片进行压缩处理，生成base64编码，甚至还可以对base64做zlib压缩，进一步减小传输大小，当服务端接到base64编码的参数数，我们可以将base64解析成本地文件，再做上传,参考代码:\n\n```\nrouter.post('/uploadfilebase64', function (req, res, next) {\n  var dataInfo = req.body;\n  dataInfo = dataInfo.data;\n  var filename = dataInfo.filename;\n  //复制文件到指定路径'\n   var targetPath = process.pwd() + '\\/uploads\\/' + filename;\n  //复制文件流\n  try{\n     //过滤data:URL\n    var base64Data = dataInfo.base64.replace(/^data:image\\/\\w+;base64,/, \"\");\n    var dataBuffer = new Buffer(base64Data, 'base64');\n    fs.writeFile(targetPath, dataBuffer, function (err) {\n        if (err) {\n            res.json(util.error('上传失败'));\n        } else {\n            neetupload(targetPath,function(code,data){\n             if(code === 500){\n                 res.json(util.error(data));\n             }else{\n                 res.json(util.success({\n                     url:data\n                }));\n             }\n            });\n        }\n    });\n  }catch(e){\n    res.json(util.error('上传失败'));\n  }\n});\n```\n## 最后\n\n考虑到易用性和兼用性，因为有些手机客户端可能对lrz不支持，所以我们可以在前端区分对待，支持lrz压缩就用base64的方式，不支持的可以采用原始的方式，最终实现图片上传的完美解决方案","tags":["nodejs"],"categories":["nodejs"]},{"title":"react项目中实现返回不刷新补充","url":"/reactjs/reactrefresh2.html","content":"\n## 说明\n\n[上一篇](/reactjs/reactrefresh.html)我们介绍了reach页面返回不刷新的问题，但是细心的\n童鞋发现，当我们有三级页面时1->2->3 ;比如2级页面我们用这个方法缓存住了数据，3->2是没有问题的\n，但是再从1->2的时候数据应该是从0开始加载，这就不对了。针对这个问题我们该怎么处理呢？也好解决根据this.props.location.action进行判断，1->2action是PUSH 3->2action是POP。到这里相信你知道该怎么做了吧\n\n### 取数据\n```\ncomponentDidMount() {\n   if(this.props.location.action === 'PUSTH'){\n     this.props.getList.call(this);  //每次1->2，路由前进时都重新加载\n    }else{\n      this.props.list.data && this.props.list.data.length <= 0 && this.props.getList.call(this);\n    }\n  }\n\n```\n\n这就防止了第二次重新加载已有数据,换句话说就是只有第一次或者路由正常进栈访问的时候\n才会执行getlist方法。\n\n  ","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"node-oracle安装 补充说明","url":"/nodejs/nodeoracle2.html","content":"\n## 说明\n\n[上一篇](/nodejs/nodeoracle.html)我们介绍了oracledb 的安装方法，本篇补充说明先因为oracledb版本升级带来的变更：\n1、oracle数据版本10g以下不再支持，ORA-03134: Connections to this server version are no longer supported；\n2、如果用pm2 启动包含oracledb驱动的项目，需要使用单进程fork模式，用cluster模式驱动会报错\n3、对于同一版本的centeros 如果部署成功过一台，直接部分下oracledb node 包，下次同样的环境，直接安装oracleclient和配置环境变量即可。\n\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"react项目 webpack 1.0升级2.0 1.13.0－>2.6.1","url":"/reactjs/reactwebpack.html","content":"\n## 说明\n\nwebpack是大家都知晓的主流打包工具,或者形象的讲是“模块打包机”，看下图想象应该一目了然。\n![webpack1](/image/webpack/webpack1.jpeg)\n很多人都配置配1.x版本的webpack，处于项目框架长久开发或者某些新的功能包对于webpack高版本的要求，比如新版本的react－pdf 2.x，要求webpack>=2.x。这时候你就不得不去升级webpack。抛开这些不说，先看看webpack2.x和webpack1.x的效率对比\n上图是1.x打包后的文件大小，下图是2.x打包后的大小（同样的react项目），压缩比还是很惊人的\n![webpack2](/image/webpack/webpack2.jpeg)\n![webpack3](/image/webpack/webpack3.jpeg)\n左图是1.x打包用时，右图是2.x打包用时，效率也明显提升了不少，这对于前端开发，编译的速度提升很大\n程度能提升你的开发效率，而不是苦x的等待\n![webpack4](/image/webpack/webpack4.jpeg)\n\n## 实现\n\n是不是很想亲自实践一下，配置跟我一步步走起：\n变化步步改：\n1、resolve.root\n <code>resolve.root</code>被 <code>resolve.modules</code>替代\n1.x\n```\nresolve: {\n    root: paths.client(),\n    extensions: ['', '.js', '.jsx', '.json']\n  },\n```\n2.x\n```\nresolve: {\n    modules: [paths.client(), \"node_modules\"],\n    extensions: ['.js', '.jsx', '.json']\n},\n \n```\n\n2、loaders\n<code>loaders</code>被 <code>rules</code>替代\n\n* 2.1 js|jsx\n1.x\n```\nwebpackConfig.module.loaders = [{\n  test: /\\.(js|jsx)$/,\n  exclude: /node_modules/,\n  loader: 'babel-loader',\n  query: {\n    cacheDirectory: true,\n    plugins: ['transform-runtime'],\n    presets: ['es2015', 'react', 'stage-0'],\n    env: {\n      production: {\n        plugins: [\n          'transform-react-remove-prop-types',\n          'transform-react-constant-elements'\n        ]\n      }\n    }\n  }\n},\n{\n  test: /\\.json$/,\n  loader: 'json-loader'  // 2.x 不再需要自己配置\n}];\n```\n2.x\n```\nwebpackConfig.module.rules = [{\n  test: /\\.(js|jsx)$/,\n  exclude: /node_modules/,\n  loader: 'babel-loader',\n  query: {\n    cacheDirectory: true,\n    plugins: ['transform-runtime'],\n    presets: ['es2015', 'react', 'stage-0'],\n    env: {\n      production: {\n        plugins: [\n          'transform-react-remove-prop-types',\n          'transform-react-constant-elements'\n        ]\n      }\n    }\n  }\n}];\n```\n\n\n* 2.2 css\n1.x\n```\nwebpackConfig.module.loaders.push({\n  test: /\\.css$/,\n  exclude: excludeCSSModules,\n  loaders: [\n    'style-loader',\n    'css-loader',\n    'postcss-loader'\n  ]\n});\n```\n2.x\n```\n webpackConfig.module.rules.push({\n    test: /\\.css$/,\n    exclude: excludeCSSModules,\n    use: [\n      'style-loader',\n      BASE_CSS_LOADER,\n      'postcss-loader'\n    ]\n  });\n```\n\n\n* 2.2 scss\n1.x\n```\nwebpackConfig.module.loaders.push({\n  test: /\\.css$/,\n  exclude: excludeCSSModules,\n  loaders: [\n    'style-loader',\n    'css-loader',\n    'postcss-loader'\n  ]\n});\n```\n2.x\n```\n  webpackConfig.module.rules.push({\n    test: /\\.scss$/,\n    exclude: excludeCSSModules,\n    use: [\n      'style-loader',\n      'css-loader',\n      'postcss-loader',\n      'sass-loader?sourceMap'\n    ]\n```\n\n* 2.2 url/file loader\n1.x\n```\nwebpackConfig.module.loaders.push(\n    { test: /\\.woff(\\?.*)?$/,  loader: 'url?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=application/font-woff' },\n    { test: /\\.woff2(\\?.*)?$/, loader: 'url?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=application/font-woff2' },\n    { test: /\\.otf(\\?.*)?$/,   loader: 'file?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=font/opentype' },\n    { test: /\\.ttf(\\?.*)?$/,   loader: 'url?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=application/octet-stream' },\n    { test: /\\.eot(\\?.*)?$/,   loader: 'file?prefix=fonts/&name=[path][name].[ext]' },\n    { test: /\\.pdf(\\?.*)?$/,   loader: 'file?prefix=fonts/&name=[path][name].[ext]' },\n    { test: /\\.svg(\\?.*)?$/,   loader: 'url?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=image/svg+xml' },\n    { test: /\\.(png|jpg|gif)$/,    loader: 'url?name=images/[hash:8].[ext]&limit=8192' }\n)\n```\n2.x\n```\n webpackConfig.module.rules.push({\n  test: /\\.woff2$/,\n  use: [{\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: '[path][name].[ext]',\n      mimetype: 'application/font-woff2'\n    }\n  }]\n}, {\n  test: /\\.otf$/,\n  use: [{\n    loader: 'file-loader',\n    options: {\n      limit: 10000,\n      name: '[path][name].[ext]',\n      mimetype: 'font/opentype'\n    }\n  }]\n}, {\n  test: /\\.ttf$/,\n  use: [{\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: '[path][name].[ext]',\n      mimetype: 'application/octet-stream'\n    }\n  }]\n}, {\n  test: /\\.eot$/,\n  use: [{\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: '[path][name].[ext]',\n    }\n  }]\n}, {\n  test: /\\.svg$/,\n  use: [{\n    loader: 'url-loader',\n    options: {\n      limit: 10000,\n      name: '[path][name].[ext]',\n      mimetype: 'image/svg+xml'\n    }\n  }]\n}, {\n  test: /\\.(png|jpg|gif)$/,\n  use: [{\n    loader: 'url-loader',\n    options: {\n      limit: 8192,\n      name: 'images/[hash:8].[ext]',\n    }\n  }]\n})\n```\n\n3、plugins\n\n```\n  webpackConfig.plugins.push(\n      new webpack.HotModuleReplacementPlugin(),\n      new webpack.NoErrorsPlugin(),\n      ....\n  );\n```\nimport ExtractTextPlugin from 'extract-text-webpack-plugin';\n需要重新安装 npm install --save-dev extract-text-webpack-plugin@2.1.2\n1.x\n```\n new webpack.NoErrorsPlugin()；\n```\n\n2.x\n```\n new webpack.NoEmitOnErrorsPlugin()  //也可不换，会有worning\n```\n\n1.x\n```\n new ExtractTextPlugin('[name].[contenthash].css', {\n        allChunks: true\n      })\n```\n\n2.x\n```\n  webpackConfig.plugins.push(\n    new ExtractTextPlugin({\n      filename: '[name].[contenthash].css',\n      allChunks: true\n    })\n  );\n```\n\n4、postcss\n1.x\n```\n  webpackConfig.postcss = [\n  cssnano({\n    autoprefixer: {\n      add: true,\n      remove: false,\n      browsers: ['last 2 versions']\n    },\n    discardComments: {\n      removeAll: true\n    },\n    discardUnused: false,\n    mergeIdents: false,\n    reduceIdents: false,\n    safe: true,\n    sourcemap: true\n  })\n];\n```\n\n2.x\n在项目根目录下新建 <code>postcss.config.js</code>\n\n```\nmodule.exports = {\n  plugins: [\n    require('autoprefixer')({\n      add: true,\n      remove: false,\n      browsers: ['last 2 versions']\n    })\n  ]\n}\n\n```\n\n\n5、module.preLoaders\n1.x\n```\nwebpack.module.preLoaders = [{\n    test: /\\.(js|jsx)$/,\n    include: new RegExp(config.dir_client),\n    loader: 'isparta',\n    exclude: /node_modules/\n  }];\n```\n2.x\n```\nwebpack.module.rules.concat[{\n    test: /\\.(js|jsx)$/,\n    enforce: \"pre\",\n    include: new RegExp(config.dir_client),\n    loader: 'isparta',\n    exclude: /node_modules/\n  }];\n```\n\n至此我们的整个配置文件改造完成，执行npm run dev\n项目完美的跑起来了，且UI UE跟之前一样，说明我们改造成功了。\n## 最后\n 但是有个问题，css，scss 会加在html style标签里，影响页面布局及加载速度。在1.x\n\n ```\n test: /.css$/,\nloader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\" })\n ```\n  \n2.x  我们需要这样做\n\n```\ntest: /\\.css$/,\n    use: ExtractTextPlugin.extract({\n      fallback: \"style-loader\",\n      use: [\"css-loader\", \"postcss-loader\"]\n  }) \n```\n","tags":["reactjs","webpack"],"categories":["reactjs"]},{"title":"kettle实现异构数据同步(三)","url":"/kettle/kettle3.html","content":"\n## 说明\n\n今天谈谈kettle数据同步之数据连接，\n\n\n## 实现\n对于主流的mysql,oracal,sqlserver kettle都是支持连接的，当然连接的前提是必须要有\n相应的数据驱动，mysql-connector-java-5.1.21-bin.jar;ojdbc6.jar;路径可以是：\n输入－表输入－新建，在弹出的配置页面填写即可\n\n![kettle30](/image/kettle/kettle30.jpeg)\n\n1、oracle配置实例，连接方式选择jdbc\n![kettle31](/image/kettle/kettle31.jpeg)\n这里需要注意，红色的部分都是必须要填写的。数据库配置的需要要小心坑，需要区分oracle提供的是SID还是服务名，如果是SID直接填写SID名称；如果是服务名则需要填写<code>/服务名</code>，\n对于参数配置，我们去 [oracle官方](https://docs.oracle.com/cd/B19306_01/java.102/b14355/urls.htm#i1006362)看看，比如像预加载，是否使用压缩对于数据提取速率的提升是很显著的。\n![kettle34](/image/kettle/kettle34.jpeg)\n2、mysql配置实例，连接方式选择jdbc\n![kettle32](/image/kettle/kettle32.jpeg)\n红色的部分都是必须要填写的。\n对于参数配置，我们去mysql官方看看，比如是否批量执行，是否使用压缩对于数据提取速率的提升是很显著的。\n![kettle33](/image/kettle/kettle33.jpeg)\n连接池，我们一般默认就好，但是如果遇到报错或者数据量比较大的情况导致表锁了，或者占用的连接池没释放的时候。我们需要设置maxWait为一个具体值，比如10，The maximum number of milliseconds that the pool will wait (when there are no available connections) for a connection to be returned before throwing an exception, or -1 to wait indefinitely.意思就是在异常后10ms释放连接，如果默认就是一直等待，白白浪费资源。\n3、sqlserver \n基本同上，参数也可以去官网查阅。\n\n## 最后\n未完待续\n","tags":["kettle"],"categories":["kettle"]},{"title":"kettle实现异构数据同步(二)","url":"/kettle/kettle2.html","content":"\n## 说明\n\n上一篇简单的介绍了kettle，今天我们来个牛刀小试，kettle的核心就两种文件，一个是ktr的转化文件，一个是kjb的作业文件。熟悉kettle的人应该都了解，所有的密码都是用某种算法加密的。今天我们先来一个转化测试实现密码的加密\n\n\n## 实现\n加密离不开机密算法，通过查找资料得知，kettle使用的是<code>Packages.org.pentaho.di.core.encryption.Encr.encryptPassword</code>。\n一个完整的转化，应该包括输入和输出。这里输入我们用常量，输出使用文本，中间加密算法用java脚本\n进行实现\n\n我们先从输入中脱一个常量组件\n![kettle3](/image/kettle/kettle3.jpeg)\n\n然后在数据栏输入测试数据\n\n![kettle4](/image/kettle/kettle4.jpeg)\n\n接着从脚本拖一个javascript组件\n\n![kettle5](/image/kettle/kettle5.jpeg)\n\n```\n//Script here\n\nvar encrypted_password = 'not encrypted';\nencrypted_password = \"Encrypted \" + Packages.org.pentaho.di.core.encryption.Encr.encryptPassword(pass);\n\n```\n\n在脚本组件的最下方，字段输出栏输入,用来后边的流程接收\n![kettle6](/image/kettle/kettle6.jpeg)\n\n最后从输出中拖一个文本输出组件\n![kettle7](/image/kettle/kettle7.jpeg)\n\n需要在字段栏自动获取下上一步传下来的<code>encrypted_password</code>值\n\n完成的流程如下\n\n![kettle8](/image/kettle/kettle8.jpeg)\n\n\n## 运行\n\n点击工作区上面的三角形按钮即可，见上图左上角。\n\n## 结果\n\n点击上图preview data按钮，可查看运行的结果\n\n\n\n## 最后\n未完待续\n","tags":["kettle"],"categories":["kettle"]},{"title":"kettle实现异构数据同步(一)","url":"/kettle/kettle1.html","content":"\n## 说明\n\n作为全栈开发工程或者DBA，往往会遇到数据同步的问题，有从excel同步到db的，有从mysql同步到\noracle的，有从oracle同步到sqlserver的等等，其实我们都统称为异构数据同步，异构有可能是字段\n的异样，也有可能是数据库厂商的不同。按照传统思路，对于同一厂商的数据同步，可能还稍微简单点，一般都是导出文件，然后再导入文件。对于不同厂商的可能就更加麻烦一些。对于中间有逻辑处理的甚至可能还得写程序进行处理，费时费力。下图是传统我们数据同步的思路和方法。\n![kettle1](/image/kettle/kettle1.jpeg)\n\n今天我要给大家介绍异构数据同步神器kettle\n\n\n## 简介\nKettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，数据抽取高效稳定。分社区版本和企业版本，对于我们日常开发社区版本够用了。感兴趣的可以去[官网](https://community.hds.com/docs/DOC-1009855)进行下载，正常下载下来，解压就行。如果要在本地运行，请先安卓java环境。然后点击Data Integration.app进行启动（MAC环境，其他环境请自行查找）\n\n\n\n## 组成\nKettle主要由Spoon、Pan、CHEF、Kitchen四块组成：\n\nspoon : 提供了一个图形化界面，方便我们进行业务逻辑实现\n![kettle2](/image/kettle/kettle2.jpeg)\npan: 用来执行转换(.ktr)\nCHEF 允许你创建任务（Job）\nKitchen: 用来执行作业(.kjb)\n\n## 优点\n\n可以在Window、Linux、Unix上运行，数据抽取高效稳定，编写一份脚步，可在多地跨平台运行\n\n\n","tags":["kettle"],"categories":["kettle"]},{"title":"nodejs生成签名","url":"/nodejs/nodesign.html","content":"\n## 说明\n\n为了api数据访问的安全性，我们常用的几种做法：\n1、参数加密；\n2、时间戳校验；\n3、token校验；\n4、签名校验；\n相比较而言，签名校验是最安全的方式，比如qq，微信，支付宝的相关数据接口都是采用签名的方式。\n我们在实际项目中和网易进行对接的过程中也遇到了签名的问题，下面简单分享下nodejs环境下，签名和\n校验的方法\n\n## 实现\n\n这里我们使用nodejs自带的Crypto加解密算法库；它主要提供了加密、解密、签名、验证等功能。这里我们重点介绍签名和验证方法。加密离不开hash算法，<code>Crypto</code>支持的hash算法有如下好多种\n```\n[ 'DSA',\n  'DSA-SHA',\n  'DSA-SHA1',\n  'DSA-SHA1-old',\n  'RSA-MD4',\n  'RSA-MD5',\n  'RSA-MDC2',\n  'RSA-RIPEMD160',\n  'RSA-SHA',\n  'RSA-SHA1',\n  'RSA-SHA1-2',\n  'RSA-SHA224',\n  'RSA-SHA256',\n  'RSA-SHA384',\n  'RSA-SHA512',\n  'dsaEncryption',\n  'dsaWithSHA',\n  'dsaWithSHA1',\n  'dss1',\n  'ecdsa-with-SHA1',\n  'md4',\n  'md4WithRSAEncryption',\n  'md5',\n  'md5WithRSAEncryption',\n  'mdc2',\n  'mdc2WithRSA',\n  'ripemd',\n  'ripemd160',\n  'ripemd160WithRSA',\n  'rmd160',\n  'sha',\n  'sha1',\n  'sha1WithRSAEncryption',\n  'sha224',\n  'sha224WithRSAEncryption',\n  'sha256',\n  'sha256WithRSAEncryption',\n  'sha384',\n  'sha384WithRSAEncryption',\n  'sha512',\n  'sha512WithRSAEncryption',\n  'shaWithRSAEncryption',\n  'ssl2-md5',\n  'ssl3-md5',\n  'ssl3-sha1',\n  'whirlpool' ]\n```\n\n这里我们以和网易对接为例，使用RSA-SHA1算法\n首先引用crypto算法库；\n```\nconst crypto = require('crypto'); \n```\nmac环境下，我们先利用openssl工具生成 private.pem和public.pem  私钥和公钥，用来生成和验证签名\n1、安装openssl mac一般自带\n2、打开命令行工具(生成1024位的私钥)\n```\nopenssl genrsa -out rsa_private_key.pem 1024\n```\n\n3、把RSA私钥转换成PKCS8格式（当然可以不用转，看格式需要）\n```\nopenssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt\n```\n\n4、生成公钥\n```\nopenssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout \n```\n\n5、生成最终文件\n![pem](/image/nodejs/nodepem.jpeg)\n\n### 签名\n```\n/**\n * 获取rsa签名\n */\nfunction getRSASign(words) {\n  fs.readFile('file/rsa_private_key.pem', 'utf-8', function (err, prikey) {\n    if (err) {\n      return 'error';\n    } else {\n      var algorithm = 'RSA-SHA1';\n      var privatePem = prikey;\n      var key = privatePem.toString();\n      var sig = signer(algorithm, key, words); //数字签名\n      return sig;\n    }\n  });\n}\nfunction signer(algorithm, key, data) {\n  var sign = crypto.createSign(algorithm);\n  sign.update(data);\n  var sig = sign.sign(key, 'hex');\n  return sig;\n}\n```\n\n### 验证\n```\nfunction verify(sig,data){\n  var algorithm = 'RSA-SHA1';\n  var publicPem = fs.readFileSync('file/rsa_public_key.pem');\n  var pubkey = publicPem.toString();\n  var verify = crypto.createVerify(algorithm);\n  verify.update(data);\n  return verify.verify(pubkey, sig, 'hex')\n}\n```\n\n### 测试\n```\n var data = \"abcdef\";   //传输的数据\n var sign = getRSASign(data);\n console.log(verify,data); // true\n console.log(verify,data + 'HI'); //  flase\n```\n\n\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"小小接班人","url":"/baby/小小接班人.html","content":"跟大多数人的生命里程一样，从自己出生到上学到毕业再到工作，从娶妻再到生子，一步一个脚印，\n跟随着人类进步的步伐，繁衍生息，为社会主义增添接班人。而我们也属于这大部分里的一个小小组织。\n组织里有在中关村上班的准妈妈小玮，有在公主坟上班的准爸爸me，当然还有我们的小幸运准宝宝奇奇。\n为了迎接小家伙的到来，特地让准妈书写宝宝日记，作为宝宝以后的一份小礼物。\n在此，祝愿广大同行，游客，路人甲乙丙，家庭美满，阖家幸福\n\n## 2017.8.11 第六周零四天 \n幸福的重量91斤\n      原谅妈咪今天才写你的出生历程日记，是因为你的爸比今天才提供了这个想法，妈咪我觉得这主意真是极好的，一拍即合，马上行动！我们的第一次见面是在一只细细长长的验孕棒上呦，我和你爸比怀着激动忐忑的心情等待着结果，发现那上面有个略浅点的两道杠时，我俩高兴坏了，你那傻爸比还给出建议咱放一晚上看看这两道杠还在不在，你爸比傻的可爱吧。第二天一早两道杠还在，我和你爸比开始奔走相告这个喜讯，分享我们因为你升级为爸比妈咪的喜悦！不知不觉，你在肚肚里已经六周多了，前几周你不太乖呦，妈咪赏罚分明，口头批评一次呦，给妈咪搞得怂的无比，吃多了干呕，吃少了过几个小时又开始找食，还在地铁上犯了低血糖，诸如此类的“事迹”数不胜数啊，随着时间的推移，你现在可比前几周乖多了，今天妈咪走路不没感觉特别累，食欲还很不错呦，这会还能不恶心的写你的出生日历呦，口头表扬你一次，再接再厉哈。\n\n## 2017.8.12 第六周零五天 \n幸福的重量91斤\n  我就粘贴个功夫，你爸比把桃都吃了，而且是家里唯一一个桃，现在给我卖萌，差评！！！今儿个咱们和去参加你爸比的团建了，唯一美中不足的是天公不作美——雨一直下，吃喝玩乐一整天，你都特别乖，晚上回家路上估计是妈咪今天玩红白机打拳皇用力过猛，你提出抗议了，一路有点干呕，晚饭断断续续吃了好几次，一碗小碗拉面都没吃完，真不是妈咪我不想多吃，实在是你的口味太刁钻，吃什么都没味道，醋就倒了三次，宝宝啊咱乖乖的哈\n\n## 2017.8.13 第六周零六天 \n幸福的重量91斤\n   今天周日是你爸比和家里视频的日子呦，你爸肩膀上放着一个小🐷，给爷爷奶奶还有太奶奶轮番介绍小猪🐷，是不是个“奥缺”。再过两天就要带你去医院预建档啦，看看你是不是一切正常，发育的好不好，营养够不够，宝宝不要紧张，正常发挥就好了哈。今天你爸比做的午饭可丰盛了，有荷兰豆清炒大虾，这虾煮的时候还活蹦乱跳的呢，可新鲜， 可好吃了，还有一个土豆酸菜炖牛腩，午饭营养丰富，满分！对了，还有一件事要和你说，你爸比今还给买了银耳，要给妈咪我冰糖银耳羹，这都是拖了你的福呀。\n\n## 2017.8.14 第七周\n幸福的重量91斤\n今天托你的福妈咪喝上了你爸比做的爱心银耳枸杞羹，超级无比好吃啊，过程是曲折的，结果是美味的，你爸比第一次做银耳不知道放多少，放了三朵看这几朵孤零零的，就又放了好几个同伴进去陪它，殊不知啊这银耳是干货，遇水会变大，出锅的时候呀这满满一大锅，晚上你爸比妈咪没干别的，就一起消灭这银耳羹了，撑得肚圆滚滚的进入梦乡了，好梦啊我的宝贝\n\n## 2017.8.15 第七周第一天\n幸福的重量91斤\n宝宝今天是你在妈咪肚肚里第七周了，今天你已经有22毫米了呦，每天你的进步都是迅速的，每分每秒你都在发生着巨大的神奇的变化，妈咪能做的就是在合理科学的情况下多吃，多给你输送营养，给你的发育助力，现在妈咪在你这22毫米的影响下，是走不过老太太，吃不过小娃娃，变得无比的怂，我也不想呀，可你这威力忒大了点，咱娘俩现在是磨合期，我做的不好的地方你多多包容，你也别没事就让我干呕，腰疼腿疼的，咱俩都乖乖的，和谐着把这十个月度过，就这么愉快的决定了哈\n## 2017.8.16 第七周第二天 \n幸福的重量91斤\n     今天是去医院预建档的日子，一大早爸比妈咪就起来向医院出发，妈咪从早上一睁眼到中午快十二点一直靠喝水维持着，还只能喝不能出，残忍吧，这一上午漫长的等待，在看到b超单宫内早孕，\n\n一切就值得了，咱们第一关合格了，可以顺利占位预建档啦！中午回家一顿猛吃，估计是上午给你饿着了，吃了一张半的鸡蛋灌饼啊，食欲空前的好啊，妈咪可劲儿吃，你可劲儿吸收，健康长大哈！明天还要继续挨饿，去医院抽血做心电图，宝宝你要像今天一样乖乖的哈，爸比妈咪爱你呦\n\n## 2017.8.17第七周零三天 幸福的重量91斤\n     今天一大早去空总抽血做一系列检查，一大清早就被抽了六个半管血，这当妈真是不容易啊，预建档跑了三个半天的医院才算完事，今天在你爸比合理的安排下，我们才能顺利在十一点半搞定一切检查，你还是很乖的，进了小区才开始让妈咪觉得不舒服，然后下午就一直不是很舒服，宝宝啊你要乖乖的啊，咱这第一阶段算是完成了就等着下个月也就是你三个月的时候正式建档了，你要乖乖表现，妈咪还想带着你去台湾玩呢，这可是你爸比妈咪的蜜月之旅啊，一切就靠你了，拜托了哈\n## 2017.8.20第七周零六天\n 幸福的重量91斤\n     周末了妈咪懒虫出来了，两天没有写日记，妈咪在这里和你说声对不起哈，没写那两天你一切正常，咱俩娘俩自己去了趟医院，看了检查结果一切正常，今爸比妈咪带你去北展剧场听相声呦，这是一个新的相声势力，主要技能天雷滚滚，托你的福这里不让带外带食品，妈咪一说肚肚里有个你，就给开了个绿灯，宝宝你好厉害的说，我和你爸比听相声了哈，over\n## 2017.8.21第八周\n幸福的重量91斤\n     亲爱滴宝宝今天是第八周啦！现在的你在妈咪肚子里已经有葡萄那么大喽，1.7cm，现在我们娘俩磨合的很好啦，妈咪得不适感已经没有刚开始那么强烈了，除了偶尔会有恶心，走的像乌龟，其他还是很不错的，爸比妈咪为了你的小名绞尽脑汁，天天开动头脑风暴，还是没想出来一个适合男孩得小名，你要是有灵感就悄悄告诉妈咪哈，妈咪可以感应的到呦\n## 2017.8.22第八周第一天\n幸福的重量91斤\n  今天妈咪给给你爸比吓到了，早上上班路上觉得不舒服，走路有点岔气，停下不走就好了，这么一路缓慢的到了单位，还是觉得浑身不对劲，在桌子上趴了会，中午竟然没什么胃口，不过为了你的健康，还是勉强吃了一小碟粉丝娃娃菜还有少量米饭，今天两人都和妈咪说现在太瘦了，要买个放辐射服作为孕妇标志，话说这玩意其实一点用也没有，但鉴于现在妈咪实在太瘦了，需要这件丑而无用的衣服做标志，让地铁的人群们注意到我是个孕妇，已经在着手准备了哈。宝宝你要健康的啊，今天的事件不要再来了哈，弄的你妈咪我很惆怅啊，怀孕怀的这么脆弱，咱俩都乖乖的，明年四月正式见面哈。\n## 2017.8.23第八周第二天\n幸福的重量91斤\n   鉴于昨天有点怂，今天就在家卧床休息了，今天当了一天小猪，吃饱睡，睡饱吃，你姥姥还特地过来给做的午饭，这皇太后般的待遇都是因为你啊。对了妈咪已经把怀你的标志——防辐射服，搞定了，下周再做地铁我就不用再不错眼珠，聚精会神的避开人群了，当然还是要小心些，不排除地铁上有些没带眼睛出门的。\n## 2017.8.24第八周第三天\n幸福的重量91斤\n     今天是工作忙碌的一天，下午开会忽略了会议的时长，没有带水杯去，导致下午没有好好喝水，受到了你爸比的批评，会议结束后麻利的喝水，吃香蕉，然后边忙边还把葡萄给吃了，忙也要给你补充营养，今天的你还是相当乖的，你要继续保持，让妈咪睡个安稳觉哈。现在的你还只能依靠b超才能听到心跳，爸比妈咪又不想做频繁b超，怕对你有不好的影响，宝宝你要多多吸收营养，快快长大啊，不要没事吓你妈咪，弄得我们着急忙慌去医院，然后在知道只能做b超才能知道你的情况后，忐忑的打道回府，那种突发状况咱尽量减少哈，咱娘俩打勾勾有啊。\n## 2017.8.25第八周第四天\n幸福的重量91斤\n   今天是周五，啦啦啦！你爸比下午出公差去做技术交流，妈咪下班带着你先去觅食，然后乖乖等你爸比来汇合，晚饭吃的外婆家，总共三个菜，一个菜吧葱密集的无法挑出，一个菜吧肥肉有点多，其实这两个菜味道还是不错的，就是现在肚子里有个你这胃口就变得挑剔无比，只能吃剩下那个有点油的酸菜鱼，总之以后再也不来这俩家吃饭了，差评。还好咱娘俩提前吃了点合胃口的，要不就得另外再搓一顿了。\n## 2017.8.26第八周第五天\n幸福的重量91斤\n     今天去电影院看新上映的科幻大片——星球特工，你就一直不安分，搞得你妈咪我时不时的就干呕，晚上你姥姥想看战狼，吃完晚饭临时决定，二刷走起！这次看的时候你特别安静，可谁知道你这是憋着大招呢，半夜被咳醒，干呕的前所未有的强烈，有种想吐的冲动，黑灯瞎火的妈咪还不小心从床上跌下来，本能反应用手撑地，保护住了你，妈咪这跌下来的同时，你爸比为了拦我们娘家，也跌下来了，黑暗中那妈咪就听到了膝盖碰地板的声音，经过这番惊吓，也不想吐了，躺床上瞪眼了好久才迷糊睡着，后来才知道你现在有听力了，忌吵闹，在你出生前我们不去电影院了，给你个安静的环境哈。\n## 2017.8.27第八周第六天\n幸福的重量91斤\n   自打肚肚里有了你，就比以前还能睡，有的时候吃完晚饭眼皮打架，就小睡到快十点，被你爸比温柔的唤起后，洗漱，然后接着睡，今天就是在吃睡中度过的，估计是昨天晚上太吓人，今儿补充能量呢。\n## 2017.8.28第八周第七天\n幸福的重量91斤\n      今天是穿着“标志服”——防辐射服上班的第一天，妈咪现在太瘦了，没人能看出来肚子里有个你，所以这个“标识服”还是很有必要的，在快下公交的时候售票员叔叔看了我两次，估计再确认，我这么瘦真是孕妇，妈咪无视他这没见过世面的样，镇定下车换乘地铁，有了这个标志吧，多少还是管用的，幸运的是还有人给妈咪让座呢，我们谢谢这位叔叔，按你爸比的话说，好人一生平安。\n## 2017.8.29第九周第一天\n幸福的重量91斤\n     今天是忙碌的一天，在单位一直忙个不停，午睡醒就补充了一个大火龙果，保证你的营养，这样才能继续下午的工作，今天你的反应是正常反应，没有特别的难受，晚饭你爸比做的特别的好吃，且特别符合今天妈咪的口味，导致吃的有点多，今儿就说到这了，妈咪躺会哈。\n## 2017.8.30第九周第二天\n幸福的重量91\n  没有什么新变化，就是妈咪不能吃太多，不然会觉得肚子撑撑的，不舒服，严重的还会恶心，接受到你的新指令，更不敢多吃了，少食多餐，但是吧妈咪在这里向你检讨，中午炸酱面太好吃了，破天荒的都吃了，下午就不舒服了，以后妈咪坚决改哈。晚上回家路上，进到小区，看见有个小胖墩碰你爸比的自行车，妈咪过去告诉小朋友不是他的东西请不要乱碰，以后你也要这么做呦，不是自己的东西咱不碰哈。\n## 2017.8.31第九周第三天\n幸福的重量91\n    今天是有了你之后妈咪感觉最舒服的一天，晚上不觉得恶心，也不嗜睡，可惜好景不长，半夜睡觉开始觉得恶心了，后来你爸比说可能是你饿了，可我也不能半夜吃饭啊，关键是也吃不下啊。咱以后白天折腾哈，晚上让妈咪睡个好觉哈，你也要有充足的休息不是，咱娘俩就这么愉快的决定了哈！\n## 2017.9.1第九周第四天\n幸福的重量91\n    今天妈咪上班下班都遇到了好心人给让座，下班路上是很难遇到好心人的，难道是今天加班的奖励吗？晚上吃完饭，和你爸比去逛街，买适合你后面大些，妈咪穿的裤子，结果吧妈咪现在太瘦了，这裤子穿着都太宽松了，一个裤腿都能装两个腿进去去了，空手而归。不过妈咪虽然瘦，可你的营养是够的呦，你放心哈。\n## 2017.9.2第九周第五天\n幸福的重量91\n   今天本来计划去去郊区玩耍，你爸比说天气预报全天有雨，我们改变计划窝在家里等下雨，结果一滴都没有呦，下午出发去你姥姥那里吃大馄饨，你特别喜欢吃呦，妈咪一下吃了14个呢。\n## 2017.9.3第九周第六天\n幸福的重量91\n   今儿天气晴朗，我们一家四口一起去门头沟京西十八潭玩耍，一路你爸比开车都特别平稳，特别是最后的盘山路，妈咪一路都没觉得不舒服，到了之后，我们先饱餐一顿，味道比妈咪想象的好些，吃饱喝足准备出发游览，为了前方的烤玉米，妈咪特别努力的往上爬，结果到了后得知烤玉米卖光了，妈咪顿时失去了前进的动力，好在最后的最后还是吃上了，这一天玩的很愉快，你也没有怎么折腾，妈咪给你点个赞。\n## 2017.9.4第十周\n幸福的重量91\n      今妈咪特别的幸运，早上上班一号线、四号线、九号线都有座，一路都碰见了好心人，这可是怀你以后第一次遇到全程都有让座的呦。晚上回家就没那么幸运了，只有九号线遇到了好心人，大家上班都挺累的，没有谁应该给妈咪让座，有人给让座，咱们就要心怀感谢，知道不宝宝。晚上你就不太乖了，吃饭期间妈咪就一直恶心，歇了半天才缓过来写日记，宝宝咱尽量白天多动动，妈咪上了一天班就指着晚上你爸比做的好吃的补充一下营养呢，咱娘俩拉勾哈。\n## 2017.9.5第十周第一天\n幸福的重量91\n     妈咪的公司现在下令全公司强制加班，幸运的是因为你的缘故，妈咪不用加班呦，宝宝你真是妈咪的幸运星，当然妈咪上班还是很高效的，一点都没有松懈，你放心哈。今天回家路上报摊的烤肠实在是太香了，但为了你的健康妈咪忍住了，妈咪会努力监督自己，给你一个健康的饮食，你就负责健康长大就好。\n## 2017.9.6第十周第二天\n幸福的重量91\n  今天妈咪早上不坐公交去地铁站了，改绿色环保自行车了，现在开学季，路上实在太堵了，两站地能走半小时，简直比蜗牛都慢，你放心妈咪会根据你的情况来决定后面时期的交通工具，是打车还是地铁，你的安全是第一位的。\n## 2017.9.7第十周第三天\n幸福的重量91\n  爸比今天加班，在攻克难题呢，妈咪只好带你出来吃了，外面的饭不如爸比做的好吃，今儿你就将就下哈，等你出生后妈咪会把和你爸比得恋爱故事，每晚当睡前故事说给你听，这可是个神奇的爱情故事呦。我们很期盼你的出生，一想到有个长的既像你爸比又像妈咪，活泼可爱的小小的你，就觉得又神奇又幸福，我们等着你哈宝宝。\n## 2017.9.8第十周第四天\n幸福的重量91\n   今天爸比在在培训，妈咪忙的下午快五点了才去给你加餐，最近公司实在是太忙了，妈咪会注意的，毕竟现在我不是一个人了，现在你白天可乖了，晚上一回到家，就开始折腾，宝宝啊咱把这折腾时间平均点如何呀，这晚上一吃饭，没吃几楼口就开始干呕，要知道妈咪就指着晚上你爸比做的饭补充营养呢，我吃好了你才能饱饱不是。\n## 2017.9.9第十周第五天\n幸福的重量91\n  爸比今天依旧培训，妈咪只好起床后带着你去姥姥家蹭饭吃，周末你的食欲就是好，中午和晚上都吃的不错，晚上你爸比特批，让妈咪吃了几口冰棍，那个幸福感啊，简直都要溢出来了，孕期能吃冰棍的幸福真是无法言语。\n## 2017.9.10第十周第六天\n幸福的重量91\n   今的天气就像你没有预兆的折腾一样，晴空万里突然乌云密布，哗啦啦的开始下雨了，雨过天晴后我们就带着你去看蜘蛛侠，结婚这蜘蛛侠是个不靠谱的冲动青年，一个劲的折腾，弄得动静巨大无比，你开始有意见了爸比妈咪就把手护在肚肚上，给你隔隔音，多少起到了这么一丢丢作用，顺利的把电影看完。自从肚肚里有了你之后，妈咪这吃饭的口味发生了巨大的变化，从来不吃香蕉的我，现在每天一根，喝牛奶就嗓子疼，今天电影看完突然想喝牛奶，这有了你之后真的神奇无比。\n## 2017.9.11第十一周\n幸福的重量91\n  昨天半夜妈咪在你的折腾和腰疼的双重折磨下，再加上荷尔蒙分泌过盛的缘故，妈咪梨花带雨了，实在是太难受了，宝宝啊咱们不带这么折腾你亲妈的，今天上班又忙成神经病，下班路上就在一号线遇见好心人让座，妈咪一直在按摩太阳穴，累到不行，今晚上让妈咪睡个好觉哈，你这么乖，妈咪相信你哈。我们距离三个月越来越近了呦，15天倒计时现在开始喽！\n## 2017.9.12第十一周第一天\n幸福的重量91\n    今天是很不舒服的一天，下班回来没人让座，累的妈咪恨不得站着睡着，晚上回来吃完饭就开始昏睡，难受的无法言语，so今天的日记没什么正能量，因为实在是太……难……受……了！\n## 2017.9.13第十一周第二天\n幸福的重量91\n    今天相比昨天来讲就舒服多了，晚上下班爸比和说他们同事的媳妇怀宝宝，在地铁上都站不住，只能自备小板凳，妈咪听后幸灾乐祸了下，这还有比我怂的，我就放心了，结果晚上你就让我频繁干呕来着，你可真是神奇了，在肚子里什么都知道，妈咪不在幸灾乐祸了哈\n## 2017.9.14第十一周第三天\n幸福的重量91\n    宝宝树上说你今天已经看上去像个小人了，就是不知道你是男孩还是女孩嘞，爸比妈咪希望你健健康康的，男女不重要，你自己决定就好哈。今天工作没那么忙，下午带你去加了个餐，馋m的双层鳕鱼堡了，妈咪很自觉没有喝饮料呦。\n## 2017.9.15第十一周第四天\n幸福的重量91\n      今周五喽，妈咪一周最期盼的日子，可以好好休息不用工作，关于你的小名我和你爸比还是没有考虑好，我们想给你起一个没那么随意的名字，所有好多名字都被pass了，下个月带你去成都耍的时候说不定会有意外的收获呦！\n## 2017.9.16第十一周第五天\n幸福的重量91\n    现在的你饿的次数出奇的多，而且还特别有饭点，妈咪周末起的晚，起床第一件事就是找吃的喂你，要不肚子里就觉得不舒服，导致我这一天五六顿，昨天晚上看爸爸去哪儿上瘾啊了，吃了一片面包片，后来你估计吃饱了要睡，不停抗议，只好乖乖睡觉不再看了。这期里面的小孩都特别可爱，看的时候就会想你以后会是什么样子呢，充满了期待和好奇，我们等着你的到来哈。\n## 2017.9.17第十一周第六天\n幸福的重量91\n    今天天气晴朗，万里无云，秋高气爽，这么好的天气不出去玩耍就太对不起这天儿了，决定去当初你爸比跟妈咪表白的地方故地重游，石景山游乐园举办活动，好多地方都变了位置，找了半天才找到，想想去年六一的时候我和你爸比八字还没一撇呢，今年九月份你都快三个月了，真是觉得无比的神奇，缘分这个东西很玄妙啊！等你大些咱们三个再来一次，到时候给你讲爸比妈咪的爱情故事给你听。\n## 2017.9.18第十二周\n幸福的重量91\n    早上一起床你就开始让妈咪干呕，弄得妈咪无法准点上班，而且你的饭量开始大了，早上吃了面包还不够，增了带袋牛奶舒服多了，说到牛奶，怀孕前妈咪都不能喝，喝了就嗓子疼，可现在肚肚里有了你，喝这个一点事都没有，你说神奇不神奇。\n## 2017.9.19第十二周第一天\n幸福的重量91\n   撒花，撒花，庆祝，今天是宝宝第十二周的日子呦！今天妈咪没有上班，因为单位里有两个重感冒的同事，一个坐在妈咪后边，一个在妈咪的旁边的旁边，妈咪本来抵抗力就弱，现在有了你，更不能生病，所以就请假在家里休息两天。今天下午带着你去遛弯，给爸比买了他最爱喝的大果粒，等着你爸比下班回来。\n## 2017.9.20第十二周第二天\n幸福的重量91\n    今天继续家里呆，躲避同事的感冒，爸比一大早就出门去大兴出差了，妈咪一人带着你在家，等着你姥姥过来给咱俩包大虾馄饨，中午吃饱喝足，你爸比说下午可以提前回来，妈咪特别的开心，午觉醒来你爸比就回来喽！下午带着你去小区附近小花园散步，碰见了好多各种各样的宝宝，妈咪还逗了两个小男孩，你当时没什么意见，晚上回家让我干呕的呦，你爸比起哄非让我向你进行自我批评，说我当着你的面调戏别的小男孩，宝宝不高兴了，妈咪坚决不认，然后就一直断断续续干呕到九点多～\n## 2017.9.21第十二周第三天\n幸福的重量91\n     妈咪今天发现我细声细语和你沟通是有用滴，早上坐地铁上班，一路上有些闷，你有点不舒服，妈咪和你商量再坚持一会就有早点吃喽，你就不折腾了，感觉特别的神奇！以后妈咪都尽量多和你和颜悦色沟通，不再你弄的我难受的时候说你，一言为定哈\n## 2017.9.22第十二周第四天\n幸福的重量91\n     今天和单位同事聊天，说了说怀你症状，有经验的同事说可能是个男宝宝呦，不管你是男孩还是女孩，爸比妈咪都喜欢，健健康康最重要！晚上你爸比开会，我们娘家俩就等啊等，还好妈咪提前加了餐，你跟配合的等你爸比下班。\n## 2017.9.23第十二周第五天\n幸福的重量91\n      今天坐车一日游，本来想带你去天安门溜溜，结果碰上管制，不让去，只好回家，最后以一顿美味的烤鱼结束了今天的行程。你一到周末就特别乖，妈咪都没怎么恶心。\n## 2017.9.24第十二周第六天\n幸福的重量91\n     今天爸比妈咪早早就起来了，因为要去听孕期课程，到了以后发现时间还早，去吃了一顿16一位的豪华早餐，然后准备去上课，找了半天教师，最后你爸比问了位大爷，才知道妈咪记错了日子，课程是在昨天！！！拿出短信一看果然，妈咪傻眼了，你爸比在一直安慰，最后打道回府，宝宝你可别像妈咪学习啊，这么糊涂哈。\n## 2017.9.25第十三周\n幸福的重量91斤\n    今天是正式建档的日子，爸比妈咪一大早起来往空总出发，建档碰上了好心的护士和医生，要是按照那龟速叫号，我们要中午十一点才能让医生给开化验单，那样甭说下午了，建档就要两天了，护士说了句建档的直接去20诊室开单子，妈咪麻利的就过去了，今天的检查不多，就两项b超和白带检测，就这项还弄到11点多，以为今天上午没法建档了，但是碰见了好心医生说她给一个高龄孕妇解释耽误了时间，给妈咪搞定了上午建档的最后一个名额，妈咪就踏实的吃着华夫饼在门外等着，终于在十二点过点，正式建档成功！今天在医院遇见三个试管婴儿的孕妇，那个时候就更加觉得能够在备孕第二个月就有了你，是多么的幸运，妈咪会更加注意的，保证你的营养和安全的。\n## 2017.9.26 第十三周第一天\n幸福的重量91斤\n    今早上称体重，发现终于想突破90斤大关了，爸比高兴的和妈咪击掌庆祝，不过这体重也不能长太快，那样在生产的时候可能会剖腹产呦，今天开始按照医院的要求记录连续三天的饮食，这样营养科的医生就能知道饮食有哪些不合理的地方，这样才能改进。\n## 2017.9.27 第十三周第二天\n幸福的重量91.6斤\n      历经三个月，终于长肉了！其实妈咪之前的体重不是91斤，是在88斤到89斤之间徘徊，第一次写日记的时候，体重是吃完晚饭量的，起高了，吸取之前教训，这次连续两天早上空腹都是这个体重，才敢往上写，为了不让你长的过快，妈咪现在合理加餐，这样对你对妈咪都好。\n## 2017.9.28第十三周第三天\n幸福的重量91.6斤\n    今早上称体重，发现终于想突破90斤大关了，爸比高兴的和妈咪击掌庆祝，不过这体重也不能长太快，那样在生产的时候可能会剖腹产呦，今天开始按照医院的要求记录连续三天的饮食，这样营养科的医生就能知道饮食有哪些不合理的地方，这样才能改进。\n## 2017.9.29第十三周第四天\n幸福的重量92斤\n    宝宝你这重量长得有点快啊，咱悠着点哈，今天早上上称92了，明天妈咪再核实下哈，下个月爸比妈咪带你去度蜜月，所以爸比最近都特别忙，这两天我们就在姥姥家吃晚饭，让你爸比踏实忙。昨天日记遗漏了很重要的一件事，那就是昨天是妈咪怀你后第一次大口吃西瓜啊，上次还是在电影院你爸比抠搜的就给了两小小块，昨天之所以能吃，是妈咪问过医生了，说可以吃，适量就好了，吃到嘴里那叫一个幸福啊！\n## 2017.9.30第十三周第五天\n幸福的重量92斤\n    今天放假前一天，单位没有事情做，无聊的妈咪下楼遛弯去，混时间等下班，带你去找爸比，接爸比下班。\n## 2017.10.1第十三周第六天\n幸福的重量92斤\n     欠了你好久的故事，你爸比终于给你讲胎教故事了，你听得可认真了，今天我们终于把你的小名给定了，因为你特别的神奇，在妈咪肚子里乌漆嘛黑的也能分辨出一天的变化，总在晚饭的时候折腾，还不喜欢吵闹的环境，诸如此类我们绝对叫你奇奇，你喜欢这个名字不啊奇奇？\n## 2017.10.2第十四周\n幸福的重量92斤\n      今天是医院营养科的让记录体重的日子，虽然长了点，但咱还是在标准线以下，我们慢慢长哈这样不容易有妊娠纹，妈咪知道你是个贴心的奇奇。今天我们和你姥姥带你去玉渡山玩，你这一路上还是很乖的，今天天公不作美，阴天加下雨，郊区山里有雾，有一段盘山路像是开进了仙境里，雾气缭绕，就是能见度不高，这段路你爸比开的格外的小心，到了地方后我们去农家院饱餐了一顿，味道不错，分量足，口味清淡，吃的暖暖的饱饱的出发去玉渡山玩耍，那里面可冷可冷了，还好穿的还算多，玩美后向家出发，这回去的路上比来的时候顺利太多了，没怎么堵，你在路上折腾了一阵，妈咪赶紧睡觉，睡着了你就不折腾了，就这样平安到家。\n## 2017.10.3 第十四周第一天\n幸福的重量92斤\n     昨天出去玩耍了一天，今儿在家休息休息一下，养精蓄锐，吃饱了睡睡饱了收拾收拾家，宝宝依旧还是晚上吃饭的时候准点和妈咪互动起来，就是这么神奇，这一天就这么过去啦。\n## 2017.10.4 第十四周第二天\n幸福的重量92斤\n    今天是你在妈咪肚子里度过的第一个中秋节，中秋节是什么呢？就是赏月品月饼一家团圆的日子，晚上找你姥姥汇合外面去吃团圆饭，大过节的你爸比说就不在家吃了，出去吃，这到地方之后还有个小插曲，我们被热情的服务员给误领进了要去的饭馆旁边那家，但是被你妈咪发现了呦，带着这俩笨人去了正确的饭馆，这晚饭菜色估计是不合你的口味，吃了没几口就开始干呕，晚饭吃完没有多坐，就赶紧回家了，出去之后呼吸到新鲜空气你就安静了，我们一路平安回家。\n## 2017.10.5 第十四周第三天\n幸福的重量92斤\n       今天是爸比妈咪度蜜月的日子，本来我们是要畅游台湾滴，这不有了你后，爸比还有姥姥他们一致认为台湾路程有点远，要是你有不舒服去医院不方便，所以只好把已经订好的机票推掉，损失了一千多块呀，曲线去成都玩。你贴心的爸比怕航班太早你会折腾，特意买了十一点的航班，我们吃了丰富的早餐饱饱到了机场，飞机起飞时还担心你不适应，结果一路你超乖，平安降落，落地后我们往咱成都的家出发，因为咱家是二期还没有交房，要不这次我们就可以住家里了，酒店入住后就去咱家小区参观一番，小区环境不错呦，妈咪替你在儿童乐园咱了一下下，然后出发去巴色鱼捞吃晚饭，这晚饭相当美味，一鱼两吃，可以涮着吃还可以烤着吃，这鱼还是一片片的，没有刺的那种，你妈咪的最爱呦，这晚饭吃饭快结束的时候，妈咪才发现你没有折腾，晚上睡觉也没有折腾，第二天早上起床爸比妈咪\n说你要是再不折腾我们就去医院看看，正聊着呢，你像听懂了一样让妈咪干呕了一下，顿时我俩就放心了。\n## 2017.10.6 第十四周第四天\n幸福的重量92斤\n    自由行的行程就是这么随意，你这个准点小闹钟七点半左右给妈咪干呕醒，提醒妈咪吃早饭，洗漱完毕我和你爸比带着你去酒店附近觅食去，兜兜转转后发现酒店楼下得一家抄手还是最合心意，落座后热情的老板介绍这家抄手店是老店，还上过四川电视台呦，有视频作证呦，抄手上来果然名不虚传，骨汤上飘着营养美味的白芝麻，抄手没有肥肉，瘦肉鲜嫩无比，你爸比的红油抄手看着红彤彤一片，可是不是很辣，妈咪因为怀了你，不能总吃辣，就尝了一个，那味道比咱那骨汤的还是好吃些的，你看妈咪为了你多乖啊。我们的行程就是吃为主，吃完这美味早餐后，酒店稍作休整，前往今天要去的景点附近入住，入住之后必须是吃附近美食，妈咪在来之前就对成都当地小吃垂涎三尺，中午选择了当地老字号小吃——龙抄手，这简直是味美价廉啊，一个小吃套餐里面有12种当地特色小吃（有妈咪看攻略就想吃的钟水饺、龙抄手、赖汤圆，还有意外收获的担担面、川北凉粉等等），这么多好吃的才36元，再来上一份大碗担担面，午饭46元吃到撑，带着圆滚滚得肚子爸比妈咪带着你去古玩城溜达了一圈，然后前往下午目的地之一宽窄巷子，虽然去之前做好了看人的准备，可是吧到了后还是超出了心里预期，人头攒动的呦，这地方比南锣鼓巷弄的小资些，两边也都是些卖衣服，卖各种当地小吃，其实就是中午妈咪带你吃到撑的那些，还不齐全，草草逛过打卡照片都没照就去人民公园躲清静去了，还享受了一下成都特色采耳，这耳朵掏的是挺舒服，可就是必须要在茶园消费，这服务员还告诉一人一座，妈咪把你亮出来，说怀孕不能喝茶，才你爸比点了杯茶了事，这简直就是强制消费啊，不过好在采耳还算舒服，就是时间短暂了些，清净呆够了我们去太古里逛街吃饭去，这不亏是成都三里屯，美女很多呦，绵绵细雨天还露着腿，看着都冷，美女不多看吃火锅去，来了成都不吃火锅怎么行，辣火锅给你爸比辣到最后都麻木了，小嘴红嘟嘟的，你放心妈咪还是吃的清汤的，吃饱喝足回去洗洗睡。\n## 2017.10.7 第十四周第五天\n幸福的重量92斤\n     今天早饭妈咪吃的相当多，当然是和自己以前的饭量比哈，吃饱喝足后我们出发去大熊猫基地，今天我们开启自驾游模式，你爸比的驾驶技术那是相当可以，我们到了大熊猫繁殖基地附近后发现人太多交通管制了，只能把车停到离熊猫基地很远的地方步行走过去，一路长途跋涉到地方之后光速找吃饭地方，大熊猫的地盘果然不一样，基本上每道菜都有熊猫的最爱—笋，午饭是鸡肉炖笋和小笋炒肉，味道相当美味，都一点了才吃午饭，导致米饭吃的都比之前多，两个菜爸比妈咪都光盘了，吃饱就去找熊猫玩耍，熊猫住的地方气候湿润，到处都是翠绿翠绿的竹子，树木都滋润的长青苔了，妈咪从小北京长大，没见过长厚厚青苔的大叔，没见识的去摸了摸，感受了下，这一路看见了好多大熊猫，有挂树上睡觉的，有坐那就顾着吃笋的，对了这期间还遇见了一只不怕人，会看镜头的孔雀，这孔雀特别的悠闲，踱着步挑着嫩叶吃，吃的空隙拍个照，告别孔雀和熊猫我们往回走了，出园我们坐了个小蹦蹦，结果你爸比搞了个乌龙，高估了自己的记忆力，提前下车了，结果我们走了好远好远，差点以为车被交警拖走了，后来妈咪呆在原地等你爸比去找车，你爸比小跑了一会儿总算找到了，驱车赶往都江堰。\n## 2017.10.8第十四周第六天\n幸福的重量92斤\n     今天我们一家仨口在都江堰玩耍，观看放水节，你爸比以为花140就是看个大坝放水，那这钱可就白花了，后来观看的时候啊，你爸比那个赞叹啊，一直猛拍，最后还嫌人家演出时间长，根本就忘了当初是谁鄙视人家这放水节的。都江堰玩耍玩肯定是去吃饱饱啊，结果一不留神还逛了个景点，吃饭的地方是一个二层小楼，二楼别有洞天，很有云南风格，今天的你依旧还是饭点报时小闹钟，准点晚饭点开始折腾，不过妈咪现在已经很习惯你折腾了，不折腾还不习惯，生怕你有事情。对了，今天晚上住宿地方可棒了，独栋别墅，还有小院子嘞，等你出生后有机会再带你来。\n## 2017.10.9第十五周\n幸福的重量92斤\n      今天我们在青城山玩耍，妈咪一直好奇这是不是白娘子修炼的地方，歌里唱“青城山下白素贞，洞中修炼千年得此身”，这里处处是景点，绿色是这里得主色调，看着就分外舒服，我们错开了十一高峰，人不多，照相没有一堆人做背景，这山的路不是用石头搭建成的上山路，而是缓缓的，几个台阶，一段平路，这样不知不觉就会走了好远，妈咪可是还差40分钟的路程就登顶了，一是体力不支，而是山上下雨太凉了，休息好后下山饱餐后回成都，怕什么来什么到了市区后，妈咪觉得不太对劲，到了酒店一量体温，发烧啦！37.5，当机立断去医院，人那叫一个多，开了药验了血，回去睡觉吃药。\n## 2017.10.10 第十五周第一天\n幸福的重量92斤\n      今天依旧发烧，下午竟然还飙到了38℃，爸比妈咪马上出发去昨天去的那家医院，这次去的时间比昨天晚上早，路上好多饭馆还开着，不用吃昨天那难吃的冷粥和没熟的土豆丝，买了几个热腾腾的包子，向医院出发，这次没挂号，先找医生问问，主要想说昨天的药不管用！结果不是一个医生不说，还得知急诊就这两个药，建议去成飞医院，好在不远我们这就出发，好不容易出租车到了，结果人家说医院级别太低，还不如刚才那家刚，让去四川省人民医院，接着换地，这病看的倒是顺利，医生说孕妇不能吃退烧药，让物理降温，洗热水澡，那两药可以接着吃，另外妈咪还找医生拿昨天的验血单确认是不是严重贫血，结婚果告诉怀孕期间的正常贫血，就低那么一点点，那个医生真是卖药的，开了三盒补血的！打道回府，冲热水澡物理降温然后睡觉觉，也许是去了大医院转了一圈，也许是晚上的小米粥很和你得胃口，这洗完热水澡，你这个活跃啊，不过爸比妈咪还是很高兴的，生怕你有事。## 2017.10.11第十五周第二天\n幸福的重量92斤\n    今天妈咪比爸比病情有所好转，你爸比也发烧了，我俩一致认为没事住什么别墅，两人住那么大地方，结果发烧了，没住别墅的命啊，奇奇你和妈咪一起加油，快快好起来，我们好回家哈。Fighting!\n## 2017.10.12第十五周第三天\n幸福的重量92斤\n     今天爸比妈咪的病情都很稳定了，我们去买了些当地特产火锅底料，买回来送人，我们明天就可以回家啦，晚饭妈咪选的相当成功，在成都吃到了地道的西北菜，送的小米粥都很软糯，西北的小米就是好吃，晚饭吃的饱饱回去觉觉。\n## 2017.10.13第十五周第四天\n幸福的重量92斤\n       早饭三次光临秦老太婆摊摊面，他俩可是重庆小面50强第一名，是从一家路边摊慢慢做起的，这次妈咪不再自己单选了，前两次点的都是你爸比的好吃，这次妈咪就选了你爸比之前吃的，终于在回去之前吃上了，不用再眼馋你爸比那碗了，吃饱后前往飞机场，路上飞行一切顺利，你也没有特别折腾，顺顺利利回到家。\n## 2017.10.14 第十五周第五天\n幸福的重量92斤\n      今天睡到自然醒，十一点半起床洗漱，你爸比做饭，妈咪洗脏衣服，分工合作，家里干干净净，今天妈咪没有怎么咳嗽，离痊愈越来越近了呦！\n## 2017.10.15-2017.10.17  第十五周第六天至第十六周第一天 幸福的重量92.6\n   从成都玩耍回来的几天，一直处于家里休息状态，调养身体，好好享受不上班的日子，你也很乖，还是早上七点半准点提醒妈咪给你吃早点，吃饱后才让我睡回笼觉。\n## 2017.10.18 第十六周第二天\n幸福的重量92.6\n    从玩耍回来后我和你爸比就一直宅在家里，你爸比决定要出去溜达溜达，要不人都呆发霉了，所以我们决定去自然博物馆玩耍，本来没对免费门票的这里期望值太高，结果物超所值，里面能看到各种各样的动物标本，还看见了大海龟呦，不知不觉就逛了两个小时，在下班高峰前回家喽\n## 2017.10.19  第十六周第三天\n幸福的重量92.6\n    今天是正式建档后的第一次孕检呦，今天要空腹抽血，再加上做唐筛预约的专家号，八点就到了医院，开始一系列检查，今天的孕检项目不多，是有史以来最快的一次，十点多点就全部搞定了，就是明天下午还得来医院做次尿检，今天的检查里面有蛋白质，医生建议复查，后来你爸比上网查有可能和之前发烧有关系，妈咪心虚没有和医生说，要是第二天检查还不正常，就老实和医生交代。\n## 2017.10.20 第十六周第四天\n幸福的重量92.6\n   为了今天检查能够顺利，妈咪从昨天检查回家就开始不断的喝水，昨天尿检不合格，除了怀疑和之前的发烧有关，还有就是昨天检查让检查前晚十点后不让吃喝有关，早上没吃饭没喝水就去医院了，一直不停喝水，这样毒素才能7排出体外，果然这方法很奏效，今天尿检蛋白质就没有了，合格喽！就在妈咪以为可以顺利回家的时候，医生说我要去内分泌科做个复查，我的甲功三项指标有点高，挂了号医生告知那两项指标高是怀孕引起的，但促甲状腺激素偏低，有疑似甲亢的可能，要一个月不能吃海鲜，不吃含碘盐后来医院空腹抽血，看是怀孕引起的还是之前就是甲亢，希望是怀孕引起的，这样爸比妈咪就放心了。\n## 2017.10.21 第十六周第五天\n幸福的重量92.6\n     今天是见你舅舅和你未来舅妈的日子，中午两家子八口人一起聚餐那氛围相当热闹，吃的也是非常丰盛，妈咪只能眼睁睁看着美味的生鱼片、大虾、鱼流哈喇子，因为妈咪疑似甲亢不能吃啊，还好有排骨安慰我的小肚肚，要不我得多伤心啊，你未来舅妈性格超级好，等你出生后妈咪带你找他们玩耍去呦，而且他们打算明年就要宝宝喽，你就是小哥哥或者小姐姐喽。\n## 2017.10.22 第十六周第六天\n幸福的重量92.6\n    你爸比这两天周末下午都去单位加班，就妈咪和你两人在家，好孤单的说，妈咪晚上亲自下厨给你爸比做的油菜炒面，这可是妈咪第一次做呦，结果是相当的成功，看你爸比一进门看见妈咪做的晚饭那高兴样，妈咪就觉得特别的开心。\n## 2017.10.23   第十七周\n幸福的重量92.6\n    今天是妈咪十月份休假后第一天上班，休了大半个月的生活宣告结束，这个依依不舍啊，今天主要工作就是梳理备案这22天休假期间的一切工作，这80多封邮件看的我呦，好在妈咪条理清晰，下班前大部分梳理完毕，明天只需要做点简单收尾工作就好了，当这期间也没忘记给你补充水果呦。\n## 2017.10.24 第十七周第一天\n幸福的重量94\n    今天妈咪的运气超级好，早上一路去单位一号线九号线四号线都有坐呦，晚上下班回来的时候一号线人特别多，幸好有个好心人给让座，谢谢这些好心人，套用你爸比的话“好人一生平安呦”，这周我们娘俩都吃不到你爸比做的晚饭，爸比要加班，咱们就在姥姥家蹭吃蹭喝，妈咪坚持不吃海鲜，不吃含碘盐，早餐连咸菜都戒掉了，就为了检查的时候排除甲亢，我们娘俩都健健康康的哈。\n## 2017.10.25 第十七周第二天\n幸福的重量94\n     继续昨天早上的好运，今天早上上班还是一路有座呦，现在你已经在妈咪肚肚里四个月了呦，肚子也比原来大了不少，而且不怎么需要额外加餐，好好吃三餐，中间吃水果就好了，奇奇果然最心疼妈咪，不让妈咪长太多肉，肉肉都长你身上了，妈咪爱你呦。\n## 2017.10.26  第十七周第三天\n幸福的重量94\n     今天好几个同事都好奇妈咪都怀了你四个月了，怎么还是那么苗条嘞，答案是我家奇奇心疼妈咪，肉都长在自己身上了，妈咪的肚子还是有货的呦，我家奇奇真是太好了，不想妈咪之后减肥瘦身辛苦，妈咪表扬你呦！现在你已经不再准点晚饭让妈咪干呕了，加餐也不想三个月前必须下午吃顿正餐了，我们娘俩已经磨合的相当好了，再有5个月我们就见面了呦，我和你爸比非常期待这一天的到来。\n## 2017.10.27 第十七周第四天\n幸福的重量94\n   今天你爸比依旧加班，为了赶在周末开大会之前完成软件，一周都在努力，咱娘俩依旧姥姥家吃饭，妈咪的饭量和孕前比没有增加，饭量依旧，其实孕妇只要营养够了就好，不用吃成个大胖子，而且我家奇奇特别帖子，营养吸收的很好，重量都长在自己那了，还有最爸比妈咪决定周末开始，养成天天晚上吃两个核桃的习惯，总忘记给你补脑，七天养成一个习惯，我们会加油的。 \n## 2017.10.28 第十七周第五天\n幸福的重量94\n  今天虽然是周末，但我和你爸比还是早早的起来了，因为要去补上早期孕妇学校，妈咪上次糊涂的给记错日子了，还好没有影响给你正式建档，这次反复确认日期，准时参加，课上发现妈咪的作息饮食还是很健康的，意外收获你的唐筛检查没有问题，没有收到医院专属反馈号码的电话，我和你爸比击掌庆祝了一下，后面还有两次排畸检查大关要过，妈咪相信我们一定没问题，当了妈才知道孕育新生命真是不容易，过关斩将。\n## 2017.10.29 第十七周第六天\n幸福的重量94\n    今天你这小闹钟让妈咪多睡了两个多小时，没有七点半给我叫起来，九点半开始提醒我给你开饭，妈咪麻利吃早点，然后再来个回笼觉，现在的你已经有梨的大小了，四肢都在发育，过几周就能感受到你的胎动了，妈咪很期待呦。\n## 2017.10.30  第十八周\n幸福的重量94\n    为了你的营养更充足，以后妈咪工作日早餐多增加一个鸡蛋，可妈咪这饭量有限，鸡蛋吃下了，包子就只能挑陷吃，粥就喝了半碗，这些也够你的营养了，食物不在多而在精嘛，下午开始遛弯了，现在已经过了三个月可以开始逐步遛弯，这样好生产，生你那天说不定还能提前几个小时和你见面呢。\n## 2017.10.31 第十八周第一天\n幸福的重量94\n    昨天晚上腿抽筋了，妈咪决定工作日早餐有一到两天加顿牛奶，喝多了怕嗓子疼，怀你前这牛奶是喝都不能喝的，一喝就嗓子疼，怀了你后神奇得没事了，就是发烧那次又嗓子疼了，不知道是发烧引起的，还是过敏又恢复了，总之还是小心点好，今天又听见老一辈的传统观念怀孕就要多吃，妈咪出于礼貌并没有反驳，但这也太不科学了，吃那么多确定就都能长宝宝身上啊，在精不在多嘛，还什么吃多了才有力气，这不是胡扯嘛，那是虚胖好嘛，妈咪决定五个月后开始做孕妇瑜伽了，正式确认怀你后就在没做过空中瑜伽了，现在身体状态比前三个月好太多，决定捡起来，这样对咱娘俩都好。\n## 2017.11.1第十八周第二天\n幸福的重量94\n      今天下午遛弯的时间比昨天长了十分钟呦，遛弯了半个小时，每天进步一点点，这样生你的时候就能加快咱娘俩见面的时间啊，遛弯还能呼吸新鲜空气，单位实在是太热了，每天晚上你爸比都会听你的心跳，妈咪这月产检要把你的心跳声录下来，等你出生后放给你听。\n## 2017.11.2 第十八周第三天\n幸福的重量94\n      今天早饭妈咪吃的太丰盛了，导致中午不怎么饿，就吃了白菜粉条还有油麦菜，下午又稍微有点小忙，都没能去买你发给妈咪想吃蛋糕的信号，买了个包子代替下，明天妈咪补给你哈，你爸比今天加了会小班，现在快五个月了，你已经不折腾妈咪了，妈咪状态不错，就主动承担了做晚饭，这可是妈咪第一次正式炒菜呦，之前做的是炒面和凉菜，这次相当成功，你爸比给力了十分呦，今天你吸收营养的时候味道和之前的不一样呦，因为是妈咪做的呦。\n## 2017.11.3第十八周第四天\n幸福的重量94\n      今天工作不是很忙，下午三点半就开始去遛弯，遛弯着遛着刮起小风了，有点微微凉，妈咪怕吹感冒了，有了上次发烧的经历，可不能再有第二次了，于是换到大厦内去遛弯，发现了公司其他孕妇，他们那肚子都特别的大，咱不像他们学习，咱们营养够不在肚子大小，我们肚子和自己比还是不小的呢。\n## 2017.11.4第十八周第五天\n幸福的重量94\n     还有不到两周就到20周了，那会你就有胎动了呦，爸比妈咪超级期待呦，不知道那会是一种什么样的感觉呢？肚子上应该会鼓出一块，然后猜猜那是你的小手还是小脚？今天你爸比照例听胎心，你还是依旧在老地方等着你爸比呢","tags":["小小接班人"],"categories":["小小接班人"]},{"title":"巧用shell脚本和svn命令快速构建svn项目目录","url":"/svn/svnshell.html","content":"\n## 说明\n\n我们经常可能会遇到这样的情况，有一个应用框架（模版，已存在svn中），每次在新建应用的时候都是\n1、先将应用框架下载下来，\n2、删除<code>.svn</code>文件，\n3、手动修改一些文件里的信息，比如我们的项目里需要修改index.html里的title值，和config/base.js里的打包应用名字。\n4、改模版项目名字为新项目名字\n4、新建svn新项目地址，\n5、下载svn新项目空目录\n6、上传代码\n\n整个过程下来很蛋疼，每次都这么搞，可能你会问为什么不直接把模版代码copy到新项目的svn里再下载下来不行么？\n答案被我们的运维工程师回绝了，呵呵哒，只能自己来了。这都不是事儿。\n能自动干嘛要手动，于是想到了shell命令,结合svn命令搞个shell脚本；\n下面是整个shell脚本，每行来个具体分析\n\n\n## 实现\n```\n#参数1:app英文名，即dist打包文件名；参数2:html title；参数3:svn地址\n#./mkproject.sh test 测试 http://svnxxx.xxx.xxx\n# 通过$接收三个参数，\nname=$1\nappdesc=$2\nsvnurl=$3\n# 如果文件夹存在就提示，否则继续\nif [ -d \"${name}\" ]; then\n echo \"${name} is existed\"\n exit 0\nfi\n# 如果name参数为空存在就提示，否则继续\nif [ ! \"${name}\" ]; then\n echo \"please input appname[english]\"\n exit 0\nfi\n# 如果appdesc参数为空存在就提示，否则继续\nif [ ! \"${appdesc}\" ]; then\n echo \"please input appdesc[chinese]\"\n exit 0\nfi\n# 如果svn地址为空存在就提示，否则继续\nif [ ! \"${svnurl}\" ]; then\n echo \"please input a svn url\"\n exit 0\nfi\n# 如果webapp_base应用框架存在就提示，否则继续\nif [ -d \"webapp_base\" ]; then\n echo \"webapp_base is existed,please change a new path\"\n exit 0\nfi\n#echo \"the ${name} are great man\"\n# 获取webapp_base模版应用代码\nsvn checkout http://svn.xxxx.yyyyy/webapp_base\n# 重命名webapp_base为新项目名name\nmv webapp_base ${name}\n# 进入新项目目录\ncd ${name}\n# 删除不需要的文件\nrm -rf .idea/ .svn/ node_modules/\n# 返回上一级目录\ncd ..\n# 获取svn新项目目录\nsvn checkout ${svnurl}\n# 进入新项目目录\ncd ${name}\n# 进入config目录\ncd config\n# sed命令修改base.js文件的字符；hello替换为name\nsed \"s/hello/${name}/g\" _base.js >_base.js_bak\nmv _base.js_bak _base.js\ncd ..\ncd src\n# sed命令修改index.html文件的字符；hello替换为appdesc\nsed \"s/hello/${appdesc}/g\" index.html >index.html_bak\nmv index.html_bak index.html\n# 返回项目根目录\ncd ..\n# 循环遍历所有要提交的文件，包括父子文件夹及文件\nsvn st | grep '^\\?' | tr '^\\?' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\\\ /g' | \n# svn add\nxargs svn add --force\n# svn commit 备注信息：提交\nsvn commit -m=提交\n```\n  \n ","tags":["其他","svn"],"categories":["svn"]},{"title":"linux GraphicsMagick安装","url":"/linux/linuxgraphicsmagic.html","content":"\n## 说明\n\n[上一篇](/linux/linuximagemagic.html)我们介绍了gm依赖imagemagic的安装说明，有人反馈说安装失败了，于是我尝试着\n改用另一个一来包<code>[GraphicsMagick](http://www.graphicsmagick.org/)</code>,安装过程相当顺利，以下是\n安装过程\n\n\n## 安装步骤\n\n* 1、安装依赖\n\n```\nyum install -y gcc libpng libjpeg libpng-devel libjpeg-devel ghostscript libtiff libtiff-devel freetype freetype-devel\n```\n\n* 2、安装glibc2.14\n```\n     wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz\n      tar -xvzf  glibc-2.14.tar.gz\n      cd glibc-2.14\n      \n      mkdir build\n      \n      cd build\n      \n      ../configure --prefix=/usr/local/glibc-2.14\n      \n      make -j4\n      \n      su\n      \n      xxxx\n      \n      make install\n      \n      whereis libc.so.6\n      \n      ln -s /usr/local/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6\n      \n      vim /root/.bash_profile\n      添加：export LD_LIBRARY_PATH=/usr/local/glibc-2.14/lib:$LD_LIBRARY_PATH\n      source /root/.bash_profile \n```\n\n* 3、安装 jpeg依赖\n\n```\n   wget http://www.ijg.org/files/jpegsrc.v9.tar.gz\n   tar -xvzf jpegsrc.v9.tar.gz\n   cd jpeg-9\n   ./configure\n   make libdir=/usr/lib64  \n   make libdir=/usr/lib64 install\n```\n\n* 4、安装GraphicsMagick\n\n```\nwget ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/1.3/GraphicsMagick-1.3.25.tar.gz\ntar -xvzf GraphicsMagick-1.3.25.tar.gz\ncd GraphicsMagick-1.3.25\n./configure --enable-shared\nmake\nmake install  \n```\n\n验证 gm version\n\n* 5、测试\n\ngm convert test.jpg test.png\n\n成功输出test.png，图片格式转换成功，gm安装到此结束，之后我们就可以利用nodejs [gm](https://www.npmjs.com/package/gm)包进行开发了","tags":["linux"],"categories":["linux"]},{"title":"linux ImageMagick安装","url":"/linux/linuximagemagic.html","content":"\n## 说明\n\n最近在做node服务器端截取图片的功能，用到了gm，但gm安装需要依赖ImageMagick，[ImageMagick](http://www.imagemagick.org/download/)安装过程相当曲折，\n经过踩坑2次，最终得以安装成功，以下是具体步骤\n\n\n## 安装步骤\n\n* 1、yum install libjpeg-devel libpng-devel libtiff-devel zlib-devel\n\n* 2、安装glibc2.14\n```\n wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz\n   tar -xvzf  glibc-2.14.tar.gz\n   cd glibc-2.14\n   \n   mkdir build\n   \n   cd build\n   \n   ../configure --prefix=/usr/local/glibc-2.14\n   \n   make -j4\n   \n   su\n   \n   xxxx\n   \n   make install\n   \n   whereis libc.so.6\n   \n   ln -s /usr/local/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6\n   \n   vim /root/.bash_profile\n   添加：export LD_LIBRARY_PATH=/usr/local/glibc-2.14/lib:$LD_LIBRARY_PATH\n   source /root/.bash_profile \n```\n\n* 3、安装 jpeg依赖\n\n```\n   wget http://www.ijg.org/files/jpegsrc.v9.tar.gz\n   tar -xvzf jpegsrc.v9.tar.gz\n   cd jpeg-9\n   ./configure\n   make libdir=/usr/lib64  \n   make libdir=/usr/lib64 install\n```   \n\n* 4、安装ImageMagick\n```   \n   wget http://www.imagemagick.org/download/ImageMagick-6.9.9-13.tar.gz  \n   tar -xvzf ImageMagick-6.9.9-13.tar.gz \n   cd ImageMagick-6.9.9-13\n   ./configure\n   make\n   make install  \n```\n\n* 5、测试\n\n./magick.sh /home/blj/test.jpg /home/blj/test.png","tags":["linux"],"categories":["linux"]},{"title":"认清js this链","url":"/javascript/jsfunc.html","content":"## 说明\n\njs中少不了继承、引用，this的指向理解正确与否直接决定了结果的准确性，我们先看一道某公司的变态\n面试题\n\n## 实例\n\n\n```\nfunction Parent() {\n            this.a = 1;\n            this.b = [1, 2, this.a];\n            this.c = { demo: 5 };\n            this.show = function () {\n                console.log(this.a , this.b , this.c.demo );\n            }\n        }\n function Child() {\n     this.a = 2;\n     this.change = function () {\n         this.b.push(this.a);\n         this.a = this.b.length;\n         this.c.demo = this.a++;\n     }\n }\n Child.prototype = new Parent(); \n var parent = new Parent();\n var child1 = new Child();\n var child2 = new Child();\n child1.a = 11;\n child2.a = 12;\n parent.show();\n child1.show();\n child2.show();\n child1.change();\n child2.change();\n parent.show();\n child1.show();\n child2.show();\n```\n运行结果如下\n\n![jsfun1](/image/js/jsfun1.jpeg)\n\n## 分析\n\n我们先不着急看这个，我们来个变种，将后半部分改成\n\n```\n Child.prototype = new Parent(); \n var parent = new Parent();\n var child1 = new Child();\n var child2 = new Child();\n child1.a = 11;\n child2.a = 12;\n parent.show();\n child1.show();\n child2.show();\n child1.change();\n child1.show();\n child2.change();\n child2.show(); \n parent.show();\n\n```\n\n\n运行结果如下\n\n![jsfun2](/image/js/jsfun2.jpeg)\n\n\n这样是不是好理解点呢：\n\n首先，需要明确一个原则：就近原则，取决于this调用时的位置,谁调用方法，this就指向哪个对象；\n具体来说：\n   * 每个new会重新分配内存\n   * 当实例上存在属性时， 用实例上的\n   * 如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的\n   * 如果原型链都不存在，就用Object原型对象上的\n   * 如果Object原型对象都不存在， 就是undefined\n\n具体分析：\n1、第一个 p.show\nconsole.log(this.a , this.b , this.c.demo );  this指parent，this.a就近找指为1，this.b就近是[1, 2, this.a] 而this.a就近是1，所以this.b是［1，2，1］\nthis.c.demo不用多说，所以最终是 <code>1 [ 1, 2, 1 ] 5</code>\n\n2、c1.change\n  c1.show\n```\nthis.b.push(this.a);\nthis.a = this.b.length;\nthis.c.demo = this.a++;\n```\nthis.a就近应该是child1.this.a,被赋值为11,this.b就近child里没有定义往上找到parent，this.b为［1，2，1］，\npush（this.a）及push（11）所以最终 this.b为［1，2，1，11］，this.a＝this.b.length=4;\nthis.c.demo=this.a++=4++=4;而此时 this.a变成了5（因为++）所以最终是 <code>5 [ 1, 2, 1 ,11] 4</code>\n\n3、c2.change\n  c2.show\n\nthis.a就近应该是child2.this.a,被赋值为12,this.b就近child里没有定义往上找到parent，this.b为［1，2，1，11］，\npush（this.a）及push（12）所以最终 this.b为［1，2，1，11，12］，this.a＝this.b.length=5;\nthis.c.demo=this.a++=5++=5;而此时 this.a变成了6（因为++）所以最终是 <code>6 [ 1, 2, 1 ,11，12] 5</code>\n\n4、第二个 p.show\n\nthis指parent，this.a就近找指为1，this.b就近是[1, 2, this.a] 而this.a就近是1，所以this.b是［1，2，1］\nthis.c.demo不用多说，所以最终是 <code>1 [ 1, 2, 1 ] 5</code>\n\n至此大家应该明白点了吧，接着我们分析原题：\n区别在于，两change在一起，结果就发生了变化，我们按照上面思路分析看看：\n\n\n具体分析：\n1、第一个 p.show\nconsole.log(this.a , this.b , this.c.demo );  this指parent，this.a就近找指为1，this.b就近是[1, 2, this.a] 而this.a就近是1，所以this.b是［1，2，1］\nthis.c.demo不用多说，所以最终是 <code>1 [ 1, 2, 1 ] 5</code>\n\n2、c1.change\n\n```\nthis.b.push(this.a);\nthis.a = this.b.length;\nthis.c.demo = this.a++;\n```\nthis.a就近应该是child1.this.a,被赋值为11,this.b就近child里没有定义往上找到parent，this.b为［1，2，1］，\npush（this.a）及push（11）所以最终 this.b为［1，2，1，11］，this.a＝this.b.length=4;\nthis.c.demo=this.a++=4++=4;而此时 this.a变成了5（因为++）\n\n\n3、c2.change\n\n```\nthis.b.push(this.a);\nthis.a = this.b.length;\nthis.c.demo = this.a++;\n```\nthis.a就近应该是child1.this.a,被赋值为12,this.b就近child里没有定义往上找到parent，this.b为［1，2，1，11］，\npush（this.a）及push（12）所以最终 this.b为［1，2，1，11，12］，this.a＝this.b.length=5;\nthis.c.demo=this.a++=5++=5;而此时 this.a变成了6（因为++）\n\n4、c1.show\n\nconsole.log(this.a , this.b , this.c.demo ); this.a就近应该吃child1.this.a为5，this.b就近child\n里没有定义往上找到parent，this.b为［1，2，1，11，12］，this.c.demo就近child里没有定义往上找到parent,this.c为5，\n所以最终是 <code>5 [ 1, 2, 1,11,12] 5</code>\n\n5、c2.show\n\nconsole.log(this.a , this.b , this.c.demo ); this.a就近应该吃child2.this.a为6，this.b就近child里没有定义往上找到parent，this.b为\n［1，2，1，11，12］，this.c.demo就近child里没有定义往上找到parent,this.c为5，所以最终是 <code>6 [ 1, 2, 1,11,12] 5</code>\n\n6、第二个 p.show\n\nthis指parent，this.a就近找指为1，this.b就近是[1, 2, this.a] 而this.a就近是1，所以this.b是［1，2，1］\nthis.c.demo不用多说，所以最终是 <code>1 [ 1, 2, 1 ] 5</code>\n\n\n## 最后\n\n是不是清楚了呢，js继承引用中的变态this，万变不离其宗，就近就近\n","tags":["javascript"],"categories":["javascript"]},{"title":"react自定义selectpicker组件","url":"/reactjs/reactselectpicker.html","content":"\n说明：上次我简单分享的是如何改造[datepicker](/reactjs/reactdatepicker.html)，使得date选择更强大更灵活。\n今天分享的是基于上次picker的原理和思想，来构建强大灵活的selectpicker，最终目的是简单配置，就能实现，1-3列的\n数据选择，可以是无关联的一列，也可以是有关联的2-3列。\n\n\n这里我依然用的是上次datepicker的组件框架，其实还是主要利用的<code>selectitem</code>里面de思想。\n\n\n## 项目结构\n\n\n![select1](/image/react/select1.jpeg)\n\n## 实现思想\n\n*  传值\n为了传递参数方便，设计的data格式如下；\n\n```\ndata={\n  v1,\n  v2,\n  v3\n}\n```\n\n抑或\n\n```\ndata={\n  v1,\n  v2,\n}\n```\n\n\n抑或\n\n```\ndata={\n  v1\n}\n```\n\n每个v，应该传入如下格式；\n```\n{key:'键值',value:'相当于option的value',title:'相当于option的text'}\n```\n这样通过传入的data，就可以决定最终渲染出来的list是几列了。对于2列及2列以上的，\n我们需要构造下“键值”就行，通过<code>_</code>来建立1-2或者1-2-3级关系\n\n```\n{\n\"v1\":{\"key\":\"3\",\"title\":\"item3\",\"value\":\"1item3\"},\n\"v2\":{\"key\":\"3_1\",\"title\":\"item3_1\",\"value\":\"2item3_1\"},\n\"v3\":{\"key\":\"3_1_1\",\"title\":\"item3_1_1\",\"value\":\"3item3_1_1\"}\n}\n```\n\n*  接收参数\n\n首先利用好<code>componentWillReceiveProps</code>函数，需要在这里接受刚传递过来的items，\n组件初始化为5个item，但是当item的数量少于5个的时候，需要给补个空位，让item0处于选中状态。\n\n```\n if (nextProps.item !== this.props.item && nextProps.value != this.props.value) {\n      this.setState({item: nextProps.item, value: nextProps.value});\n      this.data = nextProps.item;\n      this.initDatas(nextProps.item, nextProps.value);  //  补空数据\n}\n\nlet length = datas.v1.length;\n if (Math.floor((length + 1) / 2) <= MIDDLE_INDEX) {\n   for (let i = 0; i < MIDDLE_INDEX; i++) {\n     temp.push({key: datas.v1[0].key + '-' + i, value: '', title: ''});\n   }\n }\n datas.v1.forEach((v, k)=> {\n   temp.push(v);\n });\n if (temp.length < DATE_LENGTH) {\n   for (let i = 0; i <= DATE_LENGTH - temp.length; i++) {\n     temp.push({key: datas.v1[0].key + '-' + (DATE_LENGTH - i), value: '', title: ''});\n   }\n }\n\n```\n\n*  处理pickeritem\n\n正常处理逻辑如datepicker一样，唯一不一定的地方，当上下滚动遇到空数据的时候，禁止其更新；\n\n* 选中事件\n\n1、如果点开picker直接点完成，result应该是v1 v2 v3中间索引的值\n\n```\nlet item = this.state.item;\nresult = {\n      v1: item.v1[MIDDLE_INDEX],\n      v2: item.v2[MIDDLE_INDEX],\n      v3: item.v3[MIDDLE_INDEX]\n    };\n```\n\n2、如果滑动了\n\n未滑动的其它列值为中间索引值，滑动列应该为实时变量值，因为state复制直接取是有延迟的。\n\n```\nlet data = G_result;\nlet item = this.state.item;\ndata = {\n      v1: data.v1 || item.v1[MIDDLE_INDEX],\n      v2: data.v2 || (item.v2 ? item.v2[MIDDLE_INDEX] : null),\n      v3: data.v3 || (item.v3 ? item.v3[MIDDLE_INDEX] : null)\n    };\n```\n\n* 回写处理\n\n对于选中的value值，通过调用引用组件的select方法传出，对应的picker组件接收value值，\n在pickeritem子组件里，我们根据value的key和item的key进行比较，让其处于中间索引，然后补全前面和后面2个item\n\n* 样式UI改造\n\n将远css文件改造成sass文件，根据UI设计进行对应的改造\n\n## 调用方式\n\n```\n<SelectPicker\n  item={this.state.pickerdata}\n  value={this.state.pickerValue}\n  isOpen={this.state.show}\n  title=\"请选择日期\"\n  onSelect={this.handleSelect}\n  onCancel={this.handleCancel}\n  />\n```\n## 效果图\n![select4](/image/react/select4.png)\n![select2](/image/react/select2.png)\n![select3](/image/react/select3.png)\n## 最后\n\n其他细节的代码这里就不啰嗦了，有需要源码一起切磋的可以扫网页下面微我发送，欢迎指点\n\n\n\n","tags":["reactjs","组件"],"categories":["reactjs"]},{"title":"致歉信","url":"/other/sorry.html","content":"\n感谢曾经和正在光临本店的童鞋们，很多有人发现原来博客下面的评论功能不见了，是因为原来用的\n无觅的插件服务访问不了了，现在已经更换为友言。对于曾今给我支持和交流的同学说声对不起，之前\n的众多评论数据都没了，抱歉。\n最后，还是希望大家多多交流，切磋，感谢","tags":["其他"],"categories":["其他"]},{"title":"react自定义时间组件","url":"/reactjs/reactdatepicker.html","content":"\n说明：react web项目中用到时间选择，我们第一反应都是出于\"站在巨人肩膀\"的思想，先去找现成的组件。\n但往往不符合我们设计狮的设计，没关系，我们要的是思想。\n自定义时间组件从头到尾可能用的时间会很多，项目进度没法保证，于是我选择了基于<code>[react-mobile-datetimepicker](https://github.com/lunayj/react-mobile-datetimepicker)<code/>\n源码进行改造。改造包括UI，列数可调整，支持时间段选择等\n\n## 原有项目效果\n\n支持主题更改 ios和andriod可选，年月日十分固定5列不可调整.\n\n![datepicker00](/image/react/datepicker00.png)\n\n## 原有项目源码结构\n\n![datepicker0](/image/react/datepicker0.png)\n\n## 改造\n\n目录结构我们不用修改，保持原样就好；\n\n* 列数可选改造\n\n先分析源码\n\n```\n <DatePickerItem\n       value={value}\n        min={min}\n        max={max}\n        typeName=\"Year\"\n        format={dateFormat[0]}\n        onSelect={this.handleDateSelect} />\n        ....\n <DatePickerItem\n    value={value}\n    min={min}\n    max={max}\n    typeName=\"Month\"\n    format={dateFormat[1]}\n    onSelect={this.handleDateSelect} />\n\n```\n\n<code>DatePickerItem</code>是列模版，这里是写死的5列，这样我们就知道了为什么它不支持扩展了，所以我就在这\n下手处理就好；\n\n```\n{dateFormat[0] && dateFormat[0] === 'YYYY' && <DatePickerItem\n            value={value}\n            min={min}\n            max={max}\n            typeName=\"Year\"\n            format={dateFormat[0]}\n            onSelect={this.handleDateSelect}/>}\n....\n{dateFormat[4] && dateFormat[4] === 'mm' && <DatePickerItem\n            value={value}\n            min={min}\n            max={max}\n            typeName=\"Minute\"\n            format={dateFormat[4]}\n            onSelect={this.handleDateSelect}/>}            \n```\n\n<code>dateFormat</code>是array类型，类似 dateFormat={['YYYY', 'M', 'D', 'hh', 'mm']}\n通过控制<code>dateFormat</code>就可以实现列数的控制了；\n\n* 支持时间显示类型改造\n\n<code>DatePickerItem</code>新增扩展字段fixed，支持数字显示文字后缀，默认为空\n\n```\n{dateFormat[0] && dateFormat[0] === 'YYYY' && <DatePickerItem\n            value={value}\n            min={min}\n            max={max}\n            typeName=\"Year\"\n            fixed={fixed[0]}\n            format={dateFormat[0]}\n            onSelect={this.handleDateSelect}/>}\n```\n\n<code>fixed</code>是array类型，类似 fixed={['年', '月', '日', '', '']}\n通过控制<code>fixed</code>就可以实现数字显示文字后缀；\n\n* 支持小时间隔改造\n\n由于两个item的属性完全一样,我们可以基于小时<code>DatePickerItem</code>复制出来一个,通过format来控制\ndateFormat={['', '', '', 'hh', 'hh']}，当出现俩hh的时候，组件就可以认为是小时比较,\n基于原来的一个<code>value</code>，复制出来一个value2,逻辑基本同value\n\n```\n constructor(props) {\n    super(props);\n    this.state = {\n      value: nextDate(this.props.value),\n      value2: this.props.value2 ? nextDate(this.props.value2) : nextDate(this.props.value)\n    };\n  }\n\n{dateFormat[3] && dateFormat[3] === 'hh' && <DatePickerItem\n            value={value}\n            min={min}\n            max={max}\n            typeName=\"Hour\"\n            fixed={fixed[3]}\n            format={dateFormat[3]}\n            onSelect={this.handleDateSelect}/>}\n{dateFormat[4] && dateFormat[4] === 'hh' && <DatePickerItem\n  value={value2}\n  min={min}\n  max={max}\n  typeName=\"Hour2\"\n  fixed={fixed[3]}\n  format={dateFormat[3]}\n  onSelect={this.handleDateSelect2}/>}\n```\n\n\n当左边时间大于右边时，完成按钮不可点击：\n\n 源码：\n```\nhandleFinishBtnClick() {\n      this.props.onSelect(this.state.value);\n  }\n```\n \n 改造：\n```\nhandleFinishBtnClick() {\n    if (this._changehandler(this.state.value, this.state.value2)){\n      this.props.onSelect(this.state.value, this.state.value2);\n    }\n  }\n  \n_changehandler(left, right) {\n    let {dateFormat} = this.props;\n    if (dateFormat[4] && dateFormat[4] === 'hh') {\n      if (new Date(left).getHours() >= new Date(right).getHours()) {\n        return false;\n      }\n    }\n    return true;\n  }  \n```\n控制按钮样式：\n\n默认绿色，不能点击变灰：\n```\n<a className={this.state.showOk ? \"datepicker-navbar-btn color419bf9\" : 'datepicker-navbar-btn'}\n     onClick={this.handleFinishBtnClick}>{ confirmTxt ? confirmTxt : '完成'}</a>\n```\n\n其他细节的代码这里就不啰嗦了，至此整个改造完成，有需要源码一起切磋的可以扫网页下面微我发送，欢迎指点；\n\n## 调用\n\n```\nhandleSelectH(time, time2) {\n    let tip = new Date(time).getHours() + ':00-' + (new Date(time2).getHours()) + ':00';\n    this.setState({\n      timeH1: time,\n      timeH2: time2,\n      showDateH: false,\n      tip: tip\n    });\n  }\n  \n<DateTimePicker\n   value={this.state.timeH1}\n   value2={this.state.timeH2}\n   isOpen={this.state.showDateH}\n   theme=\"ios\"\n   title=\"请选择时间段\"\n   dateFormat={['', '', '', 'hh', 'hh']}\n   fixed={['', '', '', ':00', '']}\n   onSelect={this.handleSelectH}\n   onCancel={this.handleCancel}/>\n \n```\n\n* 样式改造\n将远css文件改造成sass文件，根据UI设计进行对应的改造\n\n## 效果图\n\n* 年月日\n![datepicker1](/image/react/datepicker1.png)\n![datepicker3](/image/react/datepicker3.png)\n\n* 年月日十分\n![datepicker4](/image/react/datepicker4.png)\n![datepicker5](/image/react/datepicker5.png)\n\n* 时间段：\n![datepicker2](/image/react/datepicker2.png)\n![datepicker6](/image/react/datepicker6.png)\n","tags":["reactjs","组件"],"categories":["reactjs"]},{"title":"react项目中实现在线PDF文件展示","url":"/reactjs/reactpdf.html","content":"\n## 说明\n\n最近在做一个项目，需求是要在移动客户端：安卓和ios上在线展现pdf文件，并支持上下分页。经过多方多次探索\n实现的都不是很理想，要想在react项目（react+redux+router+webpack）中实现pdf加载并显示就这么费劲么？\n最后的最后抱着试试看的心理在npm官方搜到了一款叫[react-pdf](https://www.npmjs.com/package/react-pdf)的插件，\n<code>Use by adding <ReactPDF file=\"...\" />. file can be an URL, base64 content, Uint8Array, and more.</code>\n看介绍应该可以实现吧，试试？\n\n\n## 试试\n \n * 安装\n```\nnpm install react-pdf --save \n```\n \n * 引用\n ```\n import ReactPDF from 'react-pdf'\n ```\n\n * usage\n \n 我们先用本地文件试试，temp='./sample.pdf'.\n ```\n<ReactPDF file={temp} />\n ```\n \n发现本地环境可以打开，但是有几个问题：\n1、只能显示一页，不能翻页；\n2、手机页面显示太小，看不清楚；\n3、当连上Url网络pdf资源时，跨域问题；\n4、应用站点是https的，但是pdf url资源是http的，跨协议问题；\n5、原接口返回的是html含 iframe dom结构的字符串，没法直接提取url地址\n\n* 解决\n\n针对上述几个问题，我们一个一个进行解决\n\n1、看官方api，支持pageindex设置，所以我们可以设计两个按钮去实现翻页或者利用harmmerjs手势上线触屏分页，根据UI设计我们最终用按钮分页。\n\n```\n<ReactPDF file={temp} key=\"pdf\" width={window.innerWidth * this.state.pdfscale}\n onDocumentLoad={this.onDocumentLoad}\n     onPageLoad={this.onPageLoad} pageIndex={this.state.pdfcurrentIndx} scale={this.state.pdfscale}\n     loading={<LoadingView icon='loading' show={true} text='正在加载pdf'/>}/>\n{this.state.pdftotal >= 2 &&\n   <div className=\"pdfnavbar\">\n      <span onClick={this.nextpage.bind(this, -1)} className=\"pre\"><img\n        src={this.state.pdfnav.left}/></span>\n      {this.state.pageNumber + '/' + this.state.pdftotal}\n      <span onClick={this.nextpage.bind(this, 1)} className=\"next\"><img\n        src={this.state.pdfnav.right}/></span>\n    </div>\n}         \n```\n \n  ![pdf1](/image/react/pdf1.jpeg)\n\n\n\n2、我们利用点击事件，对原pdf进行1、1.2、1.5倍率进行轮询放大；\n\n```\nG_ClickNum=0;\ntogglePDFScsle() {\n    G_ClickNum++;\n    this.setState({\n      clickNum: G_ClickNum,\n      pdfscale: G_Pdfscale[G_ClickNum % 3],\n    });\n  }\n```\n3、临时修改本地host文件；\n4、利用nginx，搭建https转发代理，前端url调用改为nginx代理的https站点；\n5、使用正则表达式，对pdf进行提取\n```\npdfurl = data.match(/<iframe\\s*.*?src=\"[a-zA-z]+:\\/\\/[^\\s]*.pdf/);\n      if (pdfurl !== null) {\n        pdfurl = pdfurl[0].match(/[a-zA-z]+:\\/\\/[^\\s]*.pdf/)[0].replace('http://xxxtest.yyyy.com',\n          'https://xxx.m.yyyy.com');\n     }\n```\n## 效果图\n \n x1\n  ![pdf2](/image/react/pdf2.jpeg)\n x1.2\n  ![pdf3](/image/react/pdf3.jpeg)\n x1.5\n  ![pdf4](/image/react/pdf4.jpeg)\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"如何快速生成api文档，并支持http访问","url":"/nodejs/nodeapidoc.html","content":"\n## 说明\n\n我们经常会遇到这样的一个场景，api和文档往往是独立书写的，一般都是先设计好api文档然后交给开发实现，或者先写好api然后在利用conflunce等md工具\n书写文档，耗时耗力，有时候还得费劲调整样式。今天我将分享一款神奇，在你写api的同时自动输出api文档，这个神器就是\n<code>[apidoc](http://apidocjs.com/)</code>，它的原理就是根据官方指定的格式定义接口方法说明，遍历指定文件，输出模版规定的文档。\n支持java，javascript,C#,php,python,ruby等开发语言。\n![apidoc1](/image/nodejs/apidoc1.jpeg)\n那么如何在现有项目基础上进行搭建实现呢？让我们以node项目为例走起，\n项目目录结构如下：\n![apidoc2](/image/nodejs/apidoc2.jpeg)\n\n\n## 实现\n\n* 安装apidoc\n\n```\nnpm install apidoc -g\n\n```\n\n* 编写apicode.json\n\n```\n{\n  \"name\": \"轻应用api文档\",\n  \"version\": \"0.0.0\",\n  \"description\": \"轻应用api文档\",\n  \"title\": \"轻应用api文档\",\n  \"url\" : \"http://localhost:8001/api/\",\n  \"order\": [\n    \"GetUser\",\n    \"PostUser\"\n  ],\n  \"template\": {\n    \"withCompare\": true,\n    \"withGenerator\": true\n  },\n   \"header\": {\n    \"title\": \"回到底部\",\n    \"filename\": \"template/header.md\"\n  },\n  \"footer\": {\n    \"title\": \"回到顶部\",\n    \"filename\": \"template/footer.md\"\n  }\n}\n\n```\n说明：\n       | 参数        | 说明  |\n       | --------   | -----  | \n       | url        | api访问根地址     |\n       | order        | 排序，先get后post     | \n       | template        | 生成模版，withCompare，支持版本比较，withGenerator 是否显示apidoc官方支持，false不显示     |\n       | header        | 头部模版     | \n       | footer        | 尾部模版     | \n   \n* api接口方法定义\n\n![apidoc3](/image/nodejs/apidoc3.jpeg)\n\n说明：可能你会说有点麻烦，但是我要说很有必要，因为合格优秀的代码也应该类似说明，声明参数类型，含义已经返回类型，只不过这次\n我们是以apidoc官方要求的来做这件事，一箭双雕，既明晰的代码熟悉规则又为api的生成做了铺垫，具体参数说明详见[官方文档](http://apidocjs.com/index.html#params)\n\n*设置模版\n<code>-t mytemplate </code>该命令用来指定api生成用的模版，可以默认，但是如果你想定制，可以下载模版[源码](https://github.com/apidoc/apidoc/tree/master/template)\n放在项目目录下，并作自定义比如样式调整等个性化需要\n\n* 执行命令\n\n```\napidoc -i api/routes/ -o api/public/apidoc/ -t mytemplate/\n\n```\n\n说明： -i  指定被自动生成api的路径\n      -o  指定文档输出的路径\n      -t  指定模版，可以不选这个参数，用默认模版\n      \n* 输出\n      \n最终会在api/public文件夹下生成一个apidoc的文件夹，这就是我们的api文档，直接访问 http://localhost:8001/apidoc\n可以看到如下结果\n![apidoc4](/image/nodejs/apidoc4.jpeg)\n\n* 快速命令\n每次执行apidoc -i api/routes/ -o api/public/apidoc/ -t mytemplate/ 很麻烦\n我们可以在package.json script中加上一句，这样我们就可以用npm run mkapi来快速生成了\n\n![apidoc5](/image/nodejs/apidoc5.jpeg)\n## 最后\n\n是不是很方便呢，一老永逸，适合后台开发的同学，可以试试\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"css实现文字垂直居中","url":"/html/htmlmiddle.html","content":"\n\n## 说明\n\nUI可能如此设计:一行有多列数据,纯div span布局,非table布局,每一列为了自适应有的是一行文字,有的是多行文字,也就说高度不一致,\n蛋疼的要求是每一列还得水平垂直居中,水平好办,text-align,垂直怎么办呢?很多同学可能会说line-height,但是有个问题,你并不知道高度。\n你也可能会说我可以计算,但是像移动端手机宽度不一样,按照百分比拿到的每列宽度也不一样,但是字体大小又必须是UI设定的,那么问题来了,\n一行你放几个字合适呢?今天分享一种非line-height的实现方式\n\n## 实现\n\n* 先看我们的list item布局\n\n```\n <div className=\"tech_greenlist_item\" key={'list_' + index}>\n    <div className=\"tech_greenlist_itemc\">\n      <span className=\"tech_greenlist_item_title1 ellipsis\">{index + 1}</span>\n      <span className=\"tech_greenlist_item_title2\">{item.xhgh}</span>\n      <span className=\"tech_greenlist_item_title3\">{item.xm}</span>\n      <span className=\"tech_greenlist_item_title4\">{item.bjname}</span>\n    </div>\n </div>\n```\n\n* 最终效果\n![list1](/image/html/list1.jpeg)\n![list2](/image/html/list2.jpeg)\n\n* 样式表\n\n```\n.tech_greenlist_item{\n font-size: 15px;\n    color: #505050;\n    border-bottom: 1px solid #dcdcdc;\n    height: auto;\n    line-height: 20px;\n    padding: 18px 5px 18px 5px;\n    .tech_greenlist_itemc {\n          position: relative;\n          width: 100%;\n          display: table;\n        }\n        .tech_greenlist_item_title1 {\n          display: table-cell;\n          vertical-align: middle;\n          *position: absolute;\n          *top: 50%;\n          *left: 0;\n          text-align: center;\n          width: 12.93%;\n        }\n        .tech_greenlist_item_title2 {\n          display: table-cell;\n          vertical-align: middle;\n          *position: absolute;\n          *top: 50%;\n          *left: 0;\n          text-align: center;\n          width: 34%;\n        }\n        .tech_greenlist_item_title3 {\n          display: table-cell;\n          vertical-align: middle;\n          *position: absolute;\n          *top: 50%;\n          *left: 0;\n          text-align: center;\n          width: 32.3%;\n        }\n        .tech_greenlist_item_title4 {\n          display: table-cell;\n          vertical-align: middle;\n          *position: absolute;\n          *top: 50%;\n          *left: 0;\n          text-align: center;\n          width: 20%;\n        }\n}\n```\n","tags":["html"],"categories":["html"]},{"title":"nodejs破解验证码","url":"/nodejs/nodetesseract.html","content":"\n## 说明\n\nnode项目,实现了从pc网站抓取登录接口,获得验证码,并自动破解验证码,最终实现用手机自动登录pc网站。简单点就是\n用手机重新定义UI,调用爬来的pc接口。接口验证码都好获取,验证如何自动破解呢?\n\n\n## 实现\n\n设计到验证码破解,网上node能搜出来的结果很少,都是java之类的,主流的组件叫 <code>tesseract</code>\n但是nodejs项目里如何引用呢?我们走起\n\n\n\n* install(linux centos 6.5)\n\n我们的运行环境是linux centos 6.5,首先谷歌了一个tesseract的安装教程,教程有坑,下面分享实际安装步骤\n\n1、**install gcc**\n```\n yum install gcc gcc-c++ make\n\n```\n\n2、**install dependent packages** 依赖包\n\n```\nyum install autoconf automake libtool\nyum install libjpeg-devel libpng-devel libtiff-devel zlib-devel \n ```\n \n3、**install leptonica** \n ```\n  wget  http://www.leptonica.org/source/leptonica-1.68.tar.gz\n  tar -xvzf leptonica-1.68\n  cd leptonica-1.68\n  ./configure\n  make\n  make install   \n \n ```\n\n4、**install tesseract**  需要翻墙\n ```\n  wget http://tesseract-ocr.googlecode.com/files/tesseract-3.01.tar.gz\n  tar -xvzf  tesseract-3.01.tar.gz\n  cd tesseract-3.01\n  ./autogen.sh\n  ./configure\n  make\n  make install\n  ldconfig \n \n ```\n 有需要的可以去我网盘下载([链接:]http://pan.baidu.com/s/1o8gCD1g  密码:ngno) \n \n5、**intall tesseract language package**  语言包,需要翻墙\n ```\nwget http://tesseract-ocr.googlecode.com/files/tesseract-ocr-3.01.eng.tar.gz\ntar -xvzf tesseract-ocr-3.01.eng.tar.gz\ncd tesseract-ocr\nsudo cp -r tessdata/* /usr/local/share/tessdata/\nln -fs /usr/local/bin/tesseract /usr/bin/tesseract\nexport TESSDATA_PREFIX=/usr/local/share/\n \n ```\n有需要的可以去我网盘下载([链接:]http://pan.baidu.com/s/1o8gCD1g  密码:ngno) \n\n6、**测试**\n\n![test](/image/nodejs/test.jpeg) \n\n ```\n  tesseract test.jpg out\n \n ```\n\n如果输出:Tesseract Open Source OCR Engine v3.01 with Leptonica就说明安装没有问题了。\n\n ![out](/image/nodejs/out.jpeg) \n\n ```\nvim out.text\n\n```\n6152 完全正确\n\n* node调用\n\n经过查找我们找到了tesseract的node包,[node-tesseract](https://www.npmjs.com/package/node-tesseract)\n\n1、**install**\n\n ```\nnpm install node-tesseract --save\n```\n\n2、**引用**\n\n```\nconst tesseract = require('node-tesseract');\n\n```\n\n3、**调用**\n\n```\n/// gif is converted by a gif which getted from a pc website\ntesseract.procsss(gif, \n          function (err, text) {\n            console.log('the qrcode is ',text)\n            if (err) {\n                cb('error');\n            } else {\n                cb(text.replace(/\\n/g, ''));   // 去除空白\n            }\n  });\n```\n\n说明下,tesseract破解的时候建议用gif,或者png,不要用gif,因为gif会提示你报错(no pix returned)。\n所以最好破解前将图片格式转换下,比如使用<code>[imagemagick](https://www.npmjs.com/package/imagemagick)</code>\n\n4、**测试**\n\n和单独执行tesseract命令结果一样\n\n\n## 最后\n\n由于这个pc站的验证码纹理少干净,所以破解率很高,如果是有纹理干扰的就会下降,当然也不是没有办法提升,\n可以通过机器训练来提高,具体教程可[参考这位同学的博客](http://blog.csdn.net/yasi_xi/article/details/8763385)\n","tags":["javascript","nodejs"],"categories":["nodejs"]},{"title":"nodejs api限制请求次数","url":"/nodejs/nodelimit.html","content":"\n## 说明\n\n最近实际项目中遇到了一个需求:现在api的单位时间内请求次数,如果熟悉微信接口的童鞋,会发现当你请求过于频繁的时候会有报错信息,类似\n你太快之类的。说明下项目是基于express 实现的api平台。比如要求我们1hour内不能频繁连续请求1000次,该如何实现呢?\n\n\n## 实现\n\n经过苦苦寻找,终于找到了一款express的中间件 [express-rate-limit](https://www.npmjs.com/package/express-rate-limit),\n阅读完api之后,发现很简单,但是原理是什么,好使么?让我们走起\n\n\n* install\n\n```\nnpm install --save express-rate-limit \n\n```\n\n* usage\n\n<code>before</code>\n```\napp.use('/api', passport.authenticate('bearer', {session: false}), function (req, res, next) {\n    /// \n});\n\n```\n\n<code>after</code>\n\n```\nvar RateLimit = require('express-rate-limit');\n\nvar apiLimiter = new RateLimit({\n    windowMs: 60 * 60 * 1000, // 1 hour\n    max: 1000,                // 1000 次\n    delayMs: 0,               // disabled 延迟响应\n    handler: function (req, res) { // 响应格式\n        res.format({\n            json: function () {\n                res.status(429).json(util.error('Too many requests, please try again later.', 429, null));\n            },\n            html: function () {\n                res.status(429).end('Too many requests, please try again later.');\n            }\n        });\n    }\n});\napp.use('/api', apiLimiter);\napp.use('/api', passport.authenticate('bearer', {session: false}), function (req, res, next) {\n   //\n});\n\n```\n\n\n## 测试\n\n* 测试工具 \n\ngoole浏览器的 Restlet client\n\n* 测试结果\n为了测试方便,我们就max设为5\n连续点击5次,正常返回如图:\n![express-rate-limit](/image/nodejs/limit1.jpeg)\n\n点击第6次,返回如图:\n![express-rate-limit](/image/nodejs/limit2.jpeg)\n\n\n* 测试结果符合要求\n\n* the end\n\n## 最后\n\n原理:基于memory,对访问的ip和资源进行key,value键值对存储,每windowMs清空一次\n拓展:如果访问人数多,访问量太大,对内存也是个考验,甚至会拖慢服务,所以建议将源码改造,利用redis存储\n","tags":["javascript","nodejs"],"categories":["nodejs"]},{"title":"react图表highchart实践_折线图","url":"/reactjs/reacthighchart3.html","content":"\n## 说明\n\n对于web 项目,图表也是常见的一种需求和功能,比如柱状图,饼状图,折线图等,图表的好处自然是\n美观大方,视觉冲击力强,可阅读性强。在jquery项目中,利用highchart或者百度的echarts都很快的\n上手并实践,而我们的react项目能不能信手拈来呢,答案是肯定,我们找来了 <code>react-highcharts</code>,\n通过研究其[文档](https://www.npmjs.com/package/react-highcharts)发现和jquery的调用配置一样。\n今天我要实现的是折线图,要求:\n\n0、按指定颜色数据;\n1、折线颜色自定义;\n2、不显示横纵坐标标尺;\n3、明文显示折点数据。\n\n## 实现\n\n* 引入\n```\nimport  ReactHighcharts from 'react-highcharts';\n```\n\n* usage\n\n```\n <ReactHighcharts config={this.state.hightOP}></ReactHighcharts>\n```\n\n\n* config\n\n```\nthis.state = \n{\n      hightOP: {\n        chart: {\n          spacingTop: 25,\n          spacingRight: 30,\n          type: 'line',\n          height:160,\n        },\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: ''\n        },\n        legend: {\n          enabled: false\n        },\n        tooltip: {\n          pointFormat: '{series.name}: <b>{point.y}分数</b>'  // tip显示\n        },\n        xAxis: {\n          lineColor: '#888888',  // 坐标基准线色值\n          lineWidth: 2,           // 坐标基准线色值\n          tickWidth: 0,          \n          title: {\n            align: 'high',\n            offset: 0,\n            text: '学期',\n            style: {\n              color: '#505050',\n              fontSize: '12px'\n            },\n            rotation: 0,\n            y: -10,\n            x: 28\n          },\n          categories: ['1', '2', '3', '4', '5'],\n          labels: {\n            enabled: false      // 禁止标尺\n          }\n        },\n        yAxis: {\n          minPadding: 1,\n          maxPadding: 1,    \n          gridLineWidth: 0,   // 隐藏横向网格线\n          lineColor: '#888888',\n          lineWidth: 2,\n          title: {\n            align: 'high',\n            offset: -10,\n            text: '分数',\n            style: {\n              color: '#505050',\n              fontSize: '12px'\n            },\n            rotation: 0,\n            y: -5\n          },\n          labels: {\n            enabled: false  // 禁止标尺\n          }\n        },\n        plotOptions: {\n          series: {\n            marker: {\n              radius: 6,\n              fillColor: '#18baa2',\n            }\n          },\n          line: {\n            color: '#cbebe6',  // 折线色值\n            lineWidth: 8,   // 折线宽度\n            dataLabels: {\n              enabled: true,\n              color: '#505050',\n              style: {\n                fontSize: '12px'\n              },\n              y: -10\n            },\n            enableMouseTracking: true\n          }\n        },\n        series: [{\n          name: '',\n          data: [84, 88, 89, 79, 88]\n        }],\n        credits: {\n          enabled: false\n        }\n      }\n    };\n```\n\n\n## 最终效果\n\n![react-highcharts](/image/react/hightchart3.jpeg)\n","tags":["reactjs","highchart"],"categories":["reactjs"]},{"title":"react图表highchart实践_饼状图","url":"/reactjs/reacthighchart2.html","content":"\n## 说明\n\n对于web 项目,图表也是常见的一种需求和功能,比如柱状图,饼状图,折线图等,图表的好处自然是\n美观大方,视觉冲击力强,可阅读性强。在jquery项目中,利用highchart或者百度的echarts都很快的\n上手并实践,而我们的react项目能不能信手拈来呢,答案是肯定,我们找来了 <code>react-highcharts</code>,\n通过研究其[文档](https://www.npmjs.com/package/react-highcharts)发现和jquery的调用配置一样。\n今天我要实现的是饼状图,要求:\n\n0、按指定颜色显示三项数据;\n1、其中两项突出显示;\n2、不显示标注;\n3、鼠标浮动显示tip。\n\n## 实现\n\n* 引入\n```\nimport  ReactHighcharts from 'react-highcharts';\n```\n\n* usage\n\n```\n <ReactHighcharts config={this.state.hightOP}></ReactHighcharts>\n```\n\n\n* config\n\n```\nthis.state = \n{\n      hightOP: {\n        chart: {\n          plotBackgroundColor: null,\n          plotBorderWidth: null,\n          plotShadow: false,\n          type: 'pie'   // 饼状图\n        },\n        title: {\n          text: ''\n        },\n        credits:{\n          enabled:false   // 隐藏highcharts版权\n        },\n        tooltip: {\n          pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'  // tip显示格式 xx:30.2%\n        },\n        plotOptions: {\n          pie: {\n            allowPointSelect: true,\n            cursor: 'pointer',\n            dataLabels: {\n              enabled: false,  // 隐藏标注\n              format: '',\n              style: {\n                color: 'black'\n              }\n            }\n          }\n        },\n        series: [{\n          name: 'Brands',\n          colorByPoint: true,\n          data: [{\n            name: 'Microsoft Internet Explorer',\n            y: 56.33,\n            color:'#63d7fe'  // 设置色值\n          }, {\n            name: 'Chrome',\n            sliced: true,   // 突出显示\n            color:'#fec053',// 设置色值\n            y: 24.03,\n          }, {\n            name: 'Firefox',\n            sliced: true,  // 突出显示\n            color:'#18baa2',// 设置色值\n            y: 10.38\n          }]\n        }]\n      }\n    };\n```\n\n\n## 最终效果\n\n![react-highcharts](/image/react/hightchart2.jpeg)\n","tags":["reactjs","highchart"],"categories":["reactjs"]},{"title":"react图表highchart实践_柱状图","url":"/reactjs/reacthighchart1.html","content":"\n## 说明\n\n对于web 项目,图表也是常见的一种需求和功能,比如柱状图,饼状图,折线图等,图表的好处自然是\n美观大方,视觉冲击力强,可阅读性强。在jquery项目中,利用highchart或者百度的echarts都很快的\n上手并实践,而我们的react项目能不能信手拈来呢,答案是肯定,我们找来了 <code>react-highcharts</code>,\n通过研究其[文档](https://www.npmjs.com/package/react-highcharts)发现和jquery的调用配置一样。\n今天我要实现的是柱状图,要求:\n\n0、显示成绩,大于等于60和小于60不同颜色标注;\n1、不能有背景的横向引导线;\n2、不能有横向和纵向坐标显示;\n3、显示一个标尺,如60;\n4、横轴有条基准线。\n\n## 实现\n\n* 引入\n```\nimport  ReactHighcharts from 'react-highcharts';\n```\n\n* usage\n\n```\n <ReactHighcharts config={this.state.hightOP}></ReactHighcharts>\n```\n\n\n* config\n\n```\nthis.state = {\n      hightOP: {\n        chart: {\n          type: 'column'\n        },\n        title: {\n          text: ''\n        },\n        subtitle: {\n          text: ''\n        },\n        legend: {\n          enabled: false   // 隐藏图例\n        },\n        tooltip: {\n          pointFormat: '{point.y}分</b>'\n        },\n        xAxis: {\n          lineColor: '#888888',\n          lineWidth: 1,   // 横向底部基准线\n          tickWidth:0,    // 隐藏横向每个单元格标尺\n          title:{\n            align: 'high',\n            offset: 0,\n            text: '',\n            rotation: 0,\n            y: -15\n          },\n          categories: ['1', '2', '3', '4', '5'],\n          labels: {\n            enabled: false   // 隐藏横向每个单元格备注('1', '2', '3', '4', '5')\n          }\n        },\n        yAxis: {\n          startOnTick: false,\n          endOnTick: false,\n          gridLineWidth:0,    // 隐藏横向网格线\n          title:{\n            text: ''\n          },\n          labels: {\n            enabled: false  // 隐藏纵向每个单元格备注(分数:10,20,30,40...)\n          },\n          plotLines: [{\n            color: '#cdcdcd',  // 横向基准线\n            dashStyle: 'dot',\n            width: 2,\n            value: 60,         // 定义在60 \n            label: {\n              align: 'right',\n              style: {\n                fontStyle: 'italic'\n              },\n              text: '60',\n              x:-5,\n              y: 5\n            },\n            zIndex: 3\n          }]\n        },\n        plotOptions: {\n          column: {\n            dataLabels: {\n              enabled: true,\n              color:'#ffffff',\n              style:{\n                fontSize:'14px'\n              },\n              y:30\n            },\n            enableMouseTracking: true\n          }\n        },\n        series: [{\n          name: '',\n          data: [\n            {y:88,color:'#18baa2'},\n            {y:70,color:'#18baa2'},\n            {y:90,color:'#18baa2'},  // 大于60\n            {y:56,color:'#ff7156'},  // 小于60\n            {y:88,color:'#18baa2'},\n          ]\n        }],\n        credits:{\n          enabled:false             // 隐藏右下角版权\n        }\n      }\n    };\n```\n\n\n## 最终效果\n\n![react-highcharts](/image/react/highchart1.jpeg)\n","tags":["reactjs","highchart"],"categories":["reactjs"]},{"title":"react项目中如何设置fetch超时","url":"/reactjs/reactfetchtimeout.html","content":"\n## 说明\n\n在[上一篇](/reactjs/reactfetch.html)我们讲到了,在react项目如何利用fetch进行网络请求,获取\n我们想要的网络资源,但是有个细节上的问题,有时候网络环境特别查的时候,比如2g环境下,请求就不那么顺畅了,\n如果没有超时设置包括友好提示的话,应用或者服务很有可能会被用户吐槽。但是用过[fetch](https://www.npmjs.com/package/isomorphic-fetch)的\n童鞋都知道,它不像[superagent](https://www.npmjs.com/package/superagent) 可以直接设计timeout,那怎么办呢?\n两种方案:\n* 抛弃fetch,用superagent\n问题是如果是刚开始写,那没问题,但如果是项目已经成熟了,并存在了很久,小伙伴们都已经熟练上手了,这时候尤其是项目紧的时候还是三思;\n* follow me\n\n## 实现\n\n回顾下之前的源码 get为例\n\n```\nfunction fetchList(dispatch) {\n  return fetch('/api/list')\n    .then((response) => response.json())\n    .then((json) => {\n      let hasError = false;\n      let text = '';\n      \n      /// /api/list正常返回格式{errcode:0,errmsg:'',data:[]}\n      if (json.errcode !== 0) {\n        hasError = true;\n        text = json.errmsg;\n      } else {\n        hasError = false;\n        text = '';\n      }\n      \n      // 网络异常 如断网\n      if (json.error) {\n        dispatch(list({\n          msg: strings.NET_ERROR, \n          data: []\n        }));\n      }\n      // 正常业务处理 \n      else {\n        dispatch(list({\n          msg: hasError ? text : '',\n          data: hasError ? [] : json.data\n        }));\n      }\n    })\n    // 异常处理\n    .catch((err) => {\n      dispatch(list({\n        msg: (__DEBUG__ && err.message) ? err.message : strings.NET_ERROR,\n        data: []\n      }));\n    });\n}\n```\n这里我们只有网络异常包括断网处理,今天我们补上timeout,我们利用promise的race函数,即我们逗乐说的赛跑函数\n来实现它,思路就是让fetch和timeout_callback俩赛跑,谁快输出谁,比如我们设置为4s,到4s了正常的fetch还没回来,\n那不好意思timeout赢了,这样我们就投机的实现了fetch的超时请求处理。当然有人会问,timeout后fetch还会执行么?\n答案是会,但是resolve不在处理了,抛弃了。\n\n* 为了更加的方便调用我们新建一个reduxHeper.js类\n\n```\nfunction _fetch(url, timeout) {\n  var abort_fn = null;\n  var fetch_promise = fetch(url);\n  var abort_promise = new Promise(function (resolve, reject) {\n    abort_fn = function () {\n      reject({message: '网络超时'});\n    };\n  });\n  var abortable_promise = Promise.race([fetch_promise, abort_promise]);\n  setTimeout(function () {\n    abort_fn();\n  }, timeout);\n\n  return abortable_promise;\n}\n\nexports = module.exports = {\n  _fetch: _fetch\n}\n\n```\n  \n  \n代码核心就是 <code>Promise.race([fetch_promise, abort_promise])</code> 其中\n <code>fetch_promise</code>就是正常fetch函数,<code>abort_promise</code> 是我们的超时服务,到点了我们会reject一个<code>message</code>\n 网络超时\n \n \n* 引用\n\n```\nimport {_fetch} from '../reduxHelper’;\n\n```\n\n\n* 调用\n\n```\n_fetch(url,4000) // 设置timeout为4s 改造后\nfetch(url)       // 改造前\n\n\n```\n\n是不是很简单。\n\n\n## 最后\n\n亲测好使","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"如何自定义button样式","url":"/html/htmlbtn.html","content":"\n\n## 说明\n\nbutton按钮可以有多种实现,比如用一个div/span等块状元素进行渲染,设置宽高透明度等等,\n也可以用input,input的好处就是就是可以很方便的进行点击控制,disabled or not。如果是\ndiv/span还得js return fasle;不是很方便,这里将分享如何自定义input的样式/\n\n## 实现\n\n我们要实现一个半透明的带圆角的btn,有输入才能点击,否则不可点击。\n根据需求我们第一反应是用btn\n\n* html\n```\n<input type='button' class='btn' value='登录' />\n\n```\n\n* css\n\n```\n.btn{\n    width: 92%;\n    height: 45px;\n    opacity:0.5;\n    -webkit-opacity: 0.5; \n    -moz-opacity: 0.5;  \n    background-color: #0073bb;\n    line-height: 45px;\n    font-size: 18px;\n    color: #ffffff;\n    text-align: center;\n    border-radius: 5px;\n    border: 1px solid #0073bb;\n}\n```\n\n* 初步效果\n\nios\n![ios](/image/html/input1.png)\nandroid/pc\n![android](/image/html/input2.png)\n\n神奇吧,ios竟然表达的意思和实际的渲染有出入,android/pc渲染正常,为什么呢?\n我们改用div 试试\n\n```\n<div class='btn'>登录</div>\n\n```\n\nios\n![ios](/image/html/input2.png)\nandroid/pc\n![android](/image/html/input2.png)\n\n换了之后发现各平台渲染结果是一样的,那问题就应该出现在input上,它本身自带样式,而我们自定义的\n并没有完全覆盖默认,这点在ios尤为明显,去掉默认就好\n\n\n```\n.btn{\n    width: 92%;\n    height: 45px;\n    opacity:0.5;\n    -webkit-opacity: 0.5; \n    -moz-opacity: 0.5;  \n    background-color: #0073bb;\n    line-height: 45px;\n    font-size: 18px;\n    color: #ffffff;\n    text-align: center;\n    border-radius: 5px;\n    border: 1px solid #0073bb;\n    // 去掉默认\n    appearance:none;\n    -webkit-appearance:none;\n    -moz-appearance:none;\n}\n```\n\n改回input再次运行\n\n\nios\n![ios](/image/html/input2.png)\nandroid/pc\n![android](/image/html/input2.png)\n\n\n最后完美搞定。\n","tags":["html"],"categories":["html"]},{"title":"react项目中的用户体验之各种提示","url":"/reactjs/reactresult.html","content":"\n## 说明\n\n在react web项目中,为了更好的提升用户体验,我们需要做一个异常捕获来展示给用户,比如一个友好的loading,\n让用户知道你在干嘛,而不是\"我是不是没点上\",\"我的网络太慢了\"等等用户的自我怀疑,亦或是\"什么破玩意,卡死了\"等等\n对于服务的吐槽。本文将介绍如何更多的避免这种用户冲突。\n\n\n## 实现\n\n* redux 部分\n\n<code>注意:</code>项目我们引用业内成熟的<code>isomorphic-fetch</code>插件,框架为<code>react+redux+router+webpack</code>,\n实例中以get请求为例。\n\n```\nnpm install --save isomorphic-fetch es6-promise\n```\n\n\n引用\n\n```\nrequire('es6-promise').polyfill();\nrequire('isomorphic-fetch');\n```\n\nget\n \n```\nexport function list(value=initial){\n return {\n     type: LIST,\n     payload: value\n   };\n}\nexport function fetchList(dispatch) {\n  return fetch('/api/list')\n    .then((response) => response.json())\n    .then((json) => {\n      let hasError = false;\n      let text = '';\n      \n      /// /api/list正常返回格式{errcode:0,errmsg:'',data:[]}\n      if (json.errcode !== 0) {\n        hasError = true;\n        text = json.errmsg;\n      } else {\n        hasError = false;\n        text = '';\n      }\n      \n      // 网络异常 如断网\n      if (json.error) {\n        dispatch(list({\n          msg: strings.NET_ERROR, \n          data: []\n        }));\n      }\n      // 正常业务处理 \n      else {\n        dispatch(list({\n          msg: hasError ? text : '',\n          data: hasError ? [] : json.data\n        }));\n      }\n    })\n    // 异常处理\n    .catch((err) => {\n      dispatch(list({\n        msg: (__DEBUG__ && err.message) ? err.message : strings.NET_ERROR,\n        data: []\n      }));\n    });\n}\n```\n\ninitial\n\n```\nconst initial = {\n  msg: strings.LOADING,\n  data: []\n};\n```\n \n* 说明\n \n 大家可能已经注意到了,不管是初始化还是异常处理还是正确返回,我们都有一个msg,正常有4种情况:\n \n 1、loading\n 2、''\n 3、net_error\n 4、catch_other\n 我们可以依赖这四种情况分别在render层给予用户不同提示\n \n* render改造\n\n```\n{this.props.msg ===strings.LOADING && <Toast type='loading'/>}\n{this.props.msg ==='' && this.props.data.length>0 && <List data={this.props.data}>}\n{this.props.msg ==='' && this.props.data.length<=0 && <Empty />}\n{this.props.msg !=='' && this.props.msg != strings.LOADING && <Error err={this.props.msg}/>}\n```\n  \n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"react项目中取消事件关联的默认动作","url":"/reactjs/reactprevent.html","content":"\n## 说明\n\n在传统的html+css+js项目中,会遇到这样一个问题:\n一个a标签 <code><a href='http://www.icafebolger.com' id='link'>走你</code>,我们想实现\n这么一个功能,点击a标签,不让跳走而是在点击的时候弹出href地址而已,怎么做呢? \n很简单,href是html默认属性,那我们就利用<code>preventDefault</code> 干掉默认,让它乖乖执行我们的自定义\n方法。\n\n项目中的坑:我们有个一级页面上面有个button,二级页面有个搜索按钮,默认submit的,巧的是两个按钮的position有重叠,\n上篇说了我们是单页应用,不同router控制跳转,按理说一级点击按钮才会跳到二级页面才会展现二级页面,pc和安卓手机\n都没问题,但是ios几个版本,不知道什么原因,感觉二级页面在一级加载完的时候已经加载出来只是隐藏而已,当我们点击\n一级按钮后,出现了神奇的效果:1、跳到了二级页面;2、自动触发了搜索事件。\n后边查了许久,猜可能是[延迟点击](/reactjs/reactfastclick.html) 问题,试了没反应。最后实在没办法了在一级按钮的事件最后\n加了preventDefalut事件神奇般的好了,ios的这个坑到现在还没想明白。\n\n\n## 上代码\n\n```\nonClick(e) {\n    this.props.push('/erji');\n    e.preventDefault();\n}\n\n\nrender() {\n  return (\n    ...\n     <i className=\"xx\"\n         onClick={this.onClick}></i> \n    ...\n  );\n}\n```\n\n\n## 最后 \n\n针对ios的这个坑,虽然解决了,可能是正解也可能歪打正着,还请牛人解释下原因或者正确的解决姿势,\n最后说明下:二级页面里有一个iframe,嵌套的一个第三方地址,这个搜索按钮是这个第三方页面里的","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"react项目中点击事件延迟","url":"/reactjs/reactfastclick.html","content":"\n\n## 说明\n\n在react web项目中,我们经常会遇到点击事件,比如一个链接或者一个按钮,\n为了兼容性,我们常常只写一个<code>click</code>函数,这样pc和mobile都能处罚,当然你可以写<code>touch</code>\n事件,那得区别对待了,<code>mobile:touch ;pc:click </code>,成本有点高还麻烦,今天带来在项目中的实践;\n原因是这样的,我们有个类似tab的多选功能,点击后更改样式,但是在实际操作中,手机点击后样式改变\n的有点肉,后边断定是触屏 click 300ms的延迟导致的。\n\n## 实现\n\n由于我们用的是<code>react+redux+router+webpack+nodejs</code>框架,熟悉的童鞋都知道,\n这是个单页应用,就一个html模版,一般情况下我们是不容许改模版的也就是说,不建议在里面直接引用js。\n后来苦苦寻找找到了node版的插件<code>react-fastclick</code>,部署很简单\n\n\n```\nnpm insall react-fastclick --save\n```\n\nusage\n\n```\ncomponentWillMount() {\n    initReactFastclick();\n}\n```\n\n\n这样我们就很easy的消除了触屏的300ms延迟,而dom你还是简单写click就好,最终pc和mobile 点击效果\n达到一致,触屏点击不在有肉肉的感觉","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"Hexo统计post阅读次数","url":"/hexo/hexopostcount.html","content":"## 说明\n有的博主的博客都是自己利用开源的hexo搭建的,对于博客的阅读量的统计不是支持的很好,尤其是我们天朝。\n有的主题比如landscape自带google统计,但是天朝你懂的,估计好多人都打不开,翻墙除外。所以我放弃了google,\n再者我用的是<code>TKL</code>这个主题本来也不支持统计,怎么办呢?后台跑到百度统计,看看能不能搞定,发现api目前并不支持根据url\n进行统计提供数据,又放弃了百度。又在[hexo插件](https://hexo.io/plugins/)官网 找个一款<code>hexo-related-popular-posts</code>,\n看了文档也是基于谷歌分析的,也放弃了。自己搭建一个成本有太高,当要放弃的时候在一篇博客中看到了[leancloud](https://leancloud.cn)\n一个云端存储产品,支持个人和商用,个人有api调用限制,其实对于博客来说基本够了,也就调用set get俩接口。下面奉上实现过程:\n\n![hexo](/image/hexo/hexo1.png)\n\n## 注册\n登陆[leancloud](https://leancloud.cn),注册个人帐号\n\n## 新建应用\n\n![hexo3](/image/hexo/hexo3.png)\n\n## 设置应用\n\n![hexo4](/image/hexo/hexo4.png)\n\nappid和appkey\n![hexo5](/image/hexo/hexo5.png)\n\n设置安全域名\n支持多个,也可以填写ip地址\n\n![hexo6](/image/hexo/hexo6.png)\n\n\n## 创建API类\n\n![hexo7](/image/hexo/hexo7.png)\n\n这里我取名为Counter\n\n至此,在leancloud 里的设置我们算是结束了。\n\n## 项目引用\n\n由于hexo是node javascript版本,所以我们打开官方javascript [sdk安装说明](https://leancloud.cn/docs/sdk_setup-js.html),按照步骤来\n\n* 配置config.yml\n 打开项目根目录,编辑<code>config.yml</code>,加入以下编码,app_id 和app_key再上面的设置里可以获取到\n\n```\n# add post views\nleancloud_visitors:\n  enable: true\n  app_id: xxxxx\n  app_key: xxxxx\n```\n\n* 设置html\n\n在casper/post.ejs中添加如下代码\n\n```\n <% if(config.leancloud_visitors.enable){ %>阅读数:\n     <span id=\"<%= url_for(post.path) %>\" class=\"leancloud_visitors\" data-flag-title=\"<%- post.title %>\"></span>次\n <% } %>\n```\n\n\n* 引用js\n\n在footer.ejs,里我们添加如下代码\n\n```\n<script src=\"//cdn1.lncld.net/static/js/2.5.0/av-min.js\"></script>\n<script>\n    var APP_ID = '<%- config.leancloud_visitors.app_id %>';\n    var APP_KEY = '<%- config.leancloud_visitors.app_key %>';\n    AV.init({\n        appId: APP_ID,\n        appKey: APP_KEY\n    });\n    // 显示次数\n    function showTime(Counter) {\n        var query = new AV.Query(\"Counter\");\n        if($(\".leancloud_visitors\").length > 0){\n            var url = $(\".leancloud_visitors\").attr('id').trim();\n            // where field\n            query.equalTo(\"words\", url);\n            // count \n            query.count().then(function (number) {\n                // There are number instances of MyClass where words equals url.\n                $(document.getElementById(url)).text(number?  number : '--');\n            }, function (error) {\n                // error is an instance of AVError.\n            });\n        }\n    }\n   // 追加pv\n    function addCount(Counter) {\n        var url = $(\".leancloud_visitors\").length > 0 ? $(\".leancloud_visitors\").attr('id').trim() : 'icafebolger.com';\n        var Counter = AV.Object.extend(\"Counter\");\n        var query = new Counter;\n        query.save({\n            words: url\n        }).then(function (object) {\n\n        })\n    }\n    $(function () {\n        var Counter = AV.Object.extend(\"Counter\");\n        addCount(Counter);\n        showTime(Counter);\n    });\n</script>\n```\n\n\n* 最终效果\n\n![hexo9](/image/hexo/hexo9.png)\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"css实现带箭头的tooltip","url":"/html/htmlcssarrow.html","content":"\n\n## 说明\n\n前端童鞋用惯了像jquery-ui,bootstrap-ui,react-ui等框架,肯定对tooltip不陌生,一个带小箭头的\n提示,用来告知用户error warning和success的信息,抛开现成,我们能不能自己搞定,答案是肯定的\n\n## 实现\n\n### 分析\n布局肯定是一个大的容器里,左边一个小尖头,右边一个文本比如span/div,形如\n\n```\n<div class=\"container\">\n   <div class=\"arrow\">箭头</div>\n   <span class=\"title\">文本</span>\n<div>\n```\n\n\n### css\n\n说明:小箭头可以有多种实现,比如做一个png,或者巧妙利用border 用css来实现,这里我选择第二种。\n将宽高设为0,边框10px,这样画出来应该是10*10的小方型,但我们要的是小三角,简单我们将right可见,其他\n三边设置为透明即可。\n\n![arrow1](/image/html/arrow1.png)\n \n```\n.container{\n    color: #FFF;\n    font-size: 16px;\n    line-height: 36px;\n    display: inline-block;\n    height: 36px;\n    width: 120px;\n    text-align: center;\n    border-radius: 5px;\n    background-color: #0073bd;\n    margin-top: 18px;\n    padding: 0px 5px 0px 5px;\n    overflow: hidden;            // 超长打点\n    text-overflow: ellipsis;     // 超长打点\n    white-space: nowrap;         // 超长打点\n }\n \n.arrow{\n    width: 0px;\n    height: 0px;\n    border-top: 10px solid transparent;\n    border-right: 10px solid #2d09a7;\n    border-bottom: 10px solid transparent;\n    border-left: 10px solid transparent;\n    border-right-color: #0073bd;\n    position: absolute;\n    margin-left: -12px; // 让箭头伸出去\n    margin-top: 8px;    // 箭头垂直居中  (container height 36-bordertop 10 -borderbottom 10)/2\n  }\n```\n\n![arrow2](/image/html/arrow2.png)\n\n咦,箭头位置不对啊,因为虽然arrow border-left我们不可见了,但是占位还在,我们去掉看看\n\n```\n.arrow{\n    width: 0px;\n    height: 0px;\n    border-top: 10px solid transparent;\n    border-right: 10px solid #2d09a7;\n    border-bottom: 10px solid transparent;\n    border-right-color: #0073bd;\n    position: absolute;\n    margin-left: -12px; // 让箭头伸出去\n    margin-top: 8px;    // 箭头垂直居中  (container height 36-bordertop 10 -borderbottom 10)/2\n  }\n```\n\n完美\n\n![arrow3](/image/html/arrow3.png)\n\n## 最后\n\n我们完整的实现了可打点的tooltip\n","tags":["html"],"categories":["html"]},{"title":"让nodejs支持es6","url":"/nodejs/nodees6.html","content":"\n## 说明\n\nnodejs项目典型的框架就是express,成熟上手快,但是网上copy下来的脚手架大都不支持es6语法,如何在node\n项目中引入es6,让我们愉快的看教程:\n\n\n## 实现\n\n### es-checker\n搞es6之前,我们先看看当前我们安装的nodejs版本对es6的支持情况,安装一个叫<code>es-checker</code>插件,很容易的就可以看出\n当前版本对es6的兼容程度\n\n```\nnpm -g install es-checker\n```\n\n然后会得到形似如下的结果\n\n```\n=========================================\nPasses 37 feature Detections\nYour runtime supports 88% of ECMAScript 6\n=========================================\n\n```\n\n\n我们看到对es6的语法支持高达88%,(我的node版本是v6.2.2),当然支持率越高越好,如果浏览器也支持es6,那么我们不需要引用其他编译工具\n便可以直接运行项目了,但是情况并不友好,有些[戳我检查浏览器es6支持度](http://ruanyf.github.io/es-checker/index.cn.html)不支持es6\n\n为了让项目支持更多的浏览器,我们需要神器babel,它可以将es6转换为es5,也就是说你写你的es6,转化的事不用你自己操心了,交给babel就行了\n\n如何安装babel呢,也很简单\n\n### 安装babel\n\n* 安装\n```\nnpm  install babel-cli --save-dev\nnpm  install babel-cli -g \n\n```\n\n* 安装 babel-preset-es2015\n\nES2015转码规则\n\n```\nnpm install  babel-preset-es2015 --save-dev\n\n```\n\n* 新建 .babelrc文件\n\n 复制如下内容到文件中\n \n```\n{    \"presets\": [      \"es2015\"    ],    \"plugins\": []  }\n```\n\n\n* babel安装完毕。\n\n\n## 测试\n\n新建test.js\n\n```\n'use strict';\nlet [a,b,c] = [1,2,3];\nconsole.log(a,b,c);\n```\n\n运行 \n\n```\nbabel-node test\n\n```\n\n输出 1 2 3,说明项目现在应该可以支持基本的es6语法了。\n\n## 最后\n\nbabelrc文件中可以配置其他转换规则,比如 ES7,react转码等\n\n```\n// react转码\nnpm install --save-dev babel-preset-react  \n// es7 0-3个版本\nnpm install --save-dev babel-preset-stage-0\nnpm install --save-dev babel-preset-stage-1\nnpm install --save-dev babel-preset-stage-2\nnpm install --save-dev babel-preset-stage-3\n```\n\n对应的babelrc文件内容变为\n\n```\n\"presets\": [\"es2015\", \"react\", \"stage-0\"]\n\n```\n\n## 进阶\n\n为了高效的进行es6转码,我们借助<code>babel-core/register</code>这个钩子,对js,jsx,es6等文件进行babel转码,\n\n*  babel-core\n```\nnpm  install babel-core -g  \nnpm  install babel-core --save-dev\n```\n\n* 新建babel_reg.js,实例.babelrc\n\n```\n//  enable runtime transpilation to use ES6/7 in node\nvar fs = require('fs');\nvar path = require('path');\nvar babelrc = fs.readFileSync(path.resolve(__dirname, '../.babelrc'));\nvar config;\ntry {\n  config = JSON.parse(babelrc);\n} catch (err) {\n  console.error('==>     ERROR: Error parsing your .babelrc.');\n  console.error(err);\n}\nrequire('babel-core/register')(config);\n```\n\n* 新建server.babel.js\n\n```\n'use strict';\n/**\n * Module dependencies.\n */\nfunction start () {\n  const app = require('../server/main');\n  const http = require('http');\n\n  /**\n   * Get port from environment and store in Express.\n   */\n  app.set('port', port);\n  /**\n   * Create HTTP server.\n   */\n  const server = http.createServer(app);\n  /**\n   * Listen on provided port, on all network interfaces.\n   */\n  server.listen(port);\n}\nmodule.exports = {\n  start\n};\n```\n\n* 启动文件sever.js\n\n```\n#!/usr/bin/env node\nrequire('./babel-reg');\nvar server = require('./server.babel');\nserver.start();\n```\n\n* 运行\n\n```\n// nodemon 热加载插件 ,当然你可以用node\nnodemon server.js \n```\n\n\n## 最后的最后\n\n下期将介绍如何利用webpack和babel-node 将es6项目打包为es5项目","tags":["nodejs"],"categories":["nodejs"]},{"title":"nodejs性能优化","url":"/nodejs/nodenice.html","content":"\n## 说明\n\nnodejs项目典型的框架就是express,成熟上手快,middware丰富等优点让大家爱不释手,如果只是简简单单的实现功能,\n相信大家很多人都能搞定,但是即使是同一个功能或者服务,不用人写出来部署上线后的表现却不尽相同,这就是我们说的性能:\n当然有人会说是服务器问题,也有人说是网络问题,当然都不希望是自己的编码问题。这里我们就说说我们的问题:\n在项目实现的工程中,遇到的各种性能相关的技巧。\n\n\n## parallel\n\n大家都知道nodejs最擅长的就是并行调用多个方法,这可以大大提高我们的执行效率。\n比如funA,funB,funC是某服务中互相独立不依赖的三个方法,如果像.net等语言,顺着写下来,也就是同步,时间消耗肯定高,\nnodejs我们可以借助async.js或者其他中间价实现并发执行\n\n```\nasync.parallel([    \n    funA,    \n    funB,    \n    funC ], \n    function(err, results) {  \n      //This callback runs when all the functions complete  \n    }\n);\n```\n\n## cache\n\n对于长时间不变的配置信息或者token之类的信息,我们没必要每次都去请求,最直接的就是放在内存中但是有大小限制和丢失的风险,\n放在session里,会话已结束全挂了。推荐使用redis等缓存服务器;\n\n```\nif(getredis(key)){\n  callback(value)\n}else{\n  getAPi(function(err,data){\n  callback(data)\n  });\n}\n\n```\n\n## session\n\nsession中不适合存储太多的数据,因为express是默认保存在内存中的,会导致服务器压力大太,\n所以建议寸关键字断,比如我们用户登陆信息的openid,而非全保存\n\n## gzip\n\nexpress 中间件compression,可以方便的实现 gzip 压缩,当浏览器请求某些资源的时候，\n服务器会在响应返回给浏览器之前进行压缩。如果你使用的是 gzip 压缩你的静态资源，\n浏览器拿到它们花很少的时间,用户得到数据的速度更快,带来更好的用户体验。\n\n```\nvar compression = require('compression');\napp.use(compression()); //use compression \napp.use(express.static(path.join(__dirname, 'public')));\n```\n\n## db select\n\n无论是关系型sqlserver,mysql还是Nosql mongoDb等,尽量少用<code>select * from </code>或者 <code>.find()</code>\n\n推荐使用<code>select A B from </code>或者 <code>.find().exclude('field')</code>\n\n\n## js css打包\n\n将项目中的js css文件整体打包,减少文件个数,有效降低服务请求次数,提升应用加载速度。\n但是要注意不同js的命名空间问题,以防冲突\n\n## pm2\n\n使用pm2 cluster模式,充分利用cpu多核,建立简单的负载,提升服务吞吐量,但要注意session不能用内存,必须要用redis等服务器端\n缓存\n\n## Nginx\n\n真正的负载均衡,配合pm2,完美解决服务压力问题\n\n\n## 其他\n\n欢迎留言补充 ^_^","tags":["nodejs"],"categories":["nodejs"]},{"title":"react项目中使用fetch进行网络请求","url":"/reactjs/reactfetch.html","content":"\n## 说明\n\n我们所有的web应用几乎都是UI+api+DB的模式,UI要获取获取进行呈现,离不开api的调用,今天我们就来说说\nreact项目中,利用[fetch](https://www.npmjs.com/package/isomorphic-fetch) 如何调用API,\n\n\n## 安装\n\n项目我们引用业内成熟的<code>isomorphic-fetch</code>插件,\n\n```\nnpm install --save isomorphic-fetch es6-promise\n```\n\n![fetch](/image/react/fetch.png)\n\n引用\n\n```\nrequire('es6-promise').polyfill();\nrequire('isomorphic-fetch');\n```\n\n## get\n \n```\nfunction fetchList(dispatch) {\n  return fetch('/api/list')\n    .then((response) => response.json())\n    .then((json) => {\n      let hasError = false;\n      let text = '';\n      \n      /// /api/list正常返回格式{errcode:0,errmsg:'',data:[]}\n      if (json.errcode !== 0) {\n        hasError = true;\n        text = json.errmsg;\n      } else {\n        hasError = false;\n        text = '';\n      }\n      \n      // 网络异常 如断网\n      if (json.error) {\n        dispatch(list({\n          msg: strings.NET_ERROR, \n          data: []\n        }));\n      }\n      // 正常业务处理 \n      else {\n        dispatch(list({\n          msg: hasError ? text : '',\n          data: hasError ? [] : json.data\n        }));\n      }\n    })\n    // 异常处理\n    .catch((err) => {\n      dispatch(list({\n        msg: (__DEBUG__ && err.message) ? err.message : strings.NET_ERROR,\n        data: []\n      }));\n    });\n}\n```\n\n\n## post\n\n```\nfunction post(postData, dispatch) {\n  return fetch('/api/save', {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      data: postData\n    })\n  }).then((response) => response.json())\n    .then((json) => {\n      let hasError = false;\n      let text = '';\n      /// /api/list正常返回格式{errcode:0,errmsg:'',data:[]}\n      if (json.errcode !== 0) {\n        hasError = true;\n        text = json.errmsg;\n      } else {\n        hasError = false;\n        text = '';\n      }\n       // 网络异常 如断网\n      if (json.error) {\n         dispatch(success({\n           msg: strings.NET_ERROR, \n           data: false\n         }));\n       }\n       // 正常业务处理 \n       else {\n         dispatch(success({\n           msg: hasError ? text : '',\n           data: !hasError \n         }));\n       }\n    })\n    .catch((err) => {\n      dispatch(success({\n        msg: (__DEBUG__ && err.message) ? err.message : strings.NET_ERROR,\n        data: false\n      }));\n    });\n}\n```\n \n## 最后\n\n推荐另一款[superagent](https://www.npmjs.com/package/superagent) \n \n 如有疑问或者更好的方案留言下方……^_^\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"node-oracle安装","url":"/nodejs/nodeoracle.html","content":"\n## 说明\n\n我们在nodejs项目中,经常会接触到和数据库打交道,如mssql,mysql,oracle,mongodb等,\n其中ssql,mysql,mongodb的数据驱动比较好安装,npm官网都有成熟的安装包,但是oracle虽然有,\n但是如果直接装,相信装过的人很少第一次就成功,为了让新手少走弯路,再次总结下我在项目中的安装经验\n供参考。\n\n\n\n## 安装\n\n##  linux下\n\n本人node版本为 0.10.36\nnodes version 0.10.36\n经实验,这个版本的node安装成功率最高,建议将node版本调节为此版本,装完之后再升级到原有node版本\n\n首先，安装 node-oracle 需要用到前面安装的 oracle instantclient ，在这之前有几个前提：\n\n* 安装 python 2.7( 测试过 2.6 可用 )\n* C++ 编译所需要的（ gcc ） 使用命令 yum install gcc  即可\n \n\n```\nyum install gcc gcc-c++\n```\n\n* 下载驱动\n\n官方下载坑爹,各种验证,提供我的存货12.1版本,包含\n\n[Oracle instant client](http://pan.baidu.com/s/1nuRKk6P)\n(链接: http://pan.baidu.com/s/1nuRKk6P 密码: dm9a) \n\n![oracle](/image/nodejs/oracle.png)\n\n主要下载basic和sdk俩个就够啦，解压出来 instantclient_12_1 目录，拷贝到 /opt/ 下面，当然这路径不重要。\n\n* 加入环境变量\n\n```\ncd\nvi .bash_profile\n//加入下面代码段：\nexport OCI_HOME=/opt/instantclient_12_1\nexport OCI_LIB_DIR=$OCI_HOME\nexport OCI_INCLUDE_DIR=$OCI_HOME/sdk/include\nexport OCI_VERSION=12\nexport NLS_LANG=AMERICAN_AMERICA.UTF8\nexport PATH\n```\n\n\n退出编辑\n\n```\nsource .bash_profile\n\n```\n\n注意，我们这里下载的版本是12.1所以这里OCI_VERSION写的是12，如果你下载的是11.* 那这里就写1\n\n* 检测一下\n\n将盘里下载的node-oracle-master,解压后,发现其中有个shell脚本<code>pre_install_check.sh</code>,运行它检测一下配置是否正确。\n\n```\nsource pre_install_check.sh\n```\n\n\n* 最后执行一下这句\n\n```\necho '/opt/instantclient_12_1/' | sudo tee -a /etc/ld.so.conf.d/oracle_instant_client.confsudo ldconfig\n\n```\n\n*  安装oracle驱动\n\n```\nnpm install oracle\n\n```\n\n##  windows下\n\n* 安装 Microsoft Visual Studio 2012 Express\n\n在 Microsoft 官网注册并下载 [Visual Studio 2012 Express for Windows Desktop](http://www.microsoft.com/visualstudio/eng/downloads#d-2012-express), 运行安装.\n\n*  安装 Node.js\n这里不再赘述\n\n*  安装 node-oracle\n\n1、  安装 Oracle instant client\n\n这是 [Oracle](http://www.oracle.com/technetwork/topics/winx64soft-089540.html) 提供的访问数据库的 C++接口, windows 64位在这里下载 Version 12.1.0.1.0 中的 \n\ninstantclient-basic-windows.x64-12.1.0.1.0.zip和instantclient-sdk-windows.x64-12.1.0.1.0.zip; \n并把它们解压到 C:\\instantclient_12_1 文件夹中, 由于两个 zip 中的文件各不相同, 所以合并到同一个文件夹也不会发生覆盖.\n\n![oracle2](/image/nodejs/oracle2.png)\n\n2、设置系统环境变量\n\n右键\"我的电脑\" → 属性 → 高级 → 环境变量 → 系统变量 → 新建\n\n如果安装了 Visutal Studio 2012, 则 环境变量如下:\n\n```\nOCI_INCLUDE_DIR=C:\\instantclient_12_1\\sdk\\include\nOCI_LIB_DIR=C:\\instantclient_12_1\\sdk\\lib\\msvc\\vc11\nOCI_VERSION=12 \nPath=xxxx之前的你的path;c:\\instantclient_12_1\\vc11;c:\\instantclient_12_1\n```\n\n<code>注意</code>:请确保 Path 中 c:\\instantclient_12_1\\vc11 在 c:\\instantclient_12_1 前面。\n\n3、安装node包\n\n```\nnpm install oracle\n\n```\n\n成功安装后会显示 node-oracle 的版本号及实际安装到的目录。\n\n## 测试\n   \n参见https://www.npmjs.com/package/oracle Linux和window驱动通用\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"linux nodejs安装","url":"/nodejs/nodestart.html","content":"\n## 说明\n\nnodejs服务可以运行在linux、windows等系统中,那么问题来了运行环境如何安装呢?这里我们将接收\nlinux下的几种安装方法\n\n\n\n## 第一种\n\nyum 安装,最简单,前提是支持yum\n\n```\nyum -y install gcc make gcc-c++ openssl-devel wget\nyum install nodejs\n```\n\n### 卸载\n\n```\nyum remove nodejs\n```\n\n### 升级\n \n\n```\nyum update nodejs\n```\n\n或者参考<code>[nodejs](/nodejs/nodenpm.html)</code>\n\n## 第二种\n\n源码安装\n\n```\nyum -y install gcc make gcc-c++ openssl-devel wget (环境依赖)\n\ncd  /opt/\nwget http://nodejs.org/dist/v4.4.2/node-v4.4.2-linux-x64.tar.gz\ntar -zvxf node-v4.4.2-linux-x64.tar.gz\n\nln -fs /opt/node-v4.4.2-linux-x64/bin/node /usr/bin/node\nln -fs /opt/node-v4.4.2-linux-x64/bin/npm /usr/bin/npm\n```\n\n## 最后检查\n\n```\nnode -v\n\n```\n\n如果出现 类似 v6.2.2的输出,表示安装成功","tags":["nodejs"],"categories":["nodejs"]},{"title":"pm2常用命令","url":"/nodejs/nodepm2.html","content":"\n## 说明\n\n在我们开发完成nodejs项目之后,遇到的问题就是如何部署,无论是windows还是linux,大家首先想到的就是node脚本\n<code>node server.js</code>\n但是这样有个问题就是,命令窗口一直开着,碍眼不说还不靠谱,万一被摁掉了,整个服务都挂了,那么相对靠谱的方案是什么?\n在我们的实际项目中,比较了forerver.js和pm2.js之后,我们最终选择了pm2,原因是pm2 api较为丰富,官网有免费的监控平台\n还支持热加载等等,至于forerver和pm2的区别这里就不详细介绍了。下面我们总结下项目中常用的pm2命令:\n\n## 命令\n\n* 安装\n\n\n\n```\npm2 install -g pm2\n```\n\n\n* 普通启动\n\n```\npm2 start xxx.js \n\n```\n\n\n* 带名称启动\n\n方便区别服务\n\n```\npm2 start xxx.js --name 'xxxxx'（fork模式,即单核模式）\npm2 start xxxjs --watch -i max --name 'xxxx'（cluster模式,即多核模式,注意如果服务中还有session相关,切记用redis等,否则如果用内存,会有session丢失的问题）\n\n```\n\n* 用json脚本启动\n\n新建process.json脚本\n\n```\n{\n\t\"apps\": [{\n\t\t\"name\": \"servername\", \n\t\t\"script\": \"xxx.js\", \n\t\t\"ignore_watch\": [\"logs\", \"node_modules\"], \n\t\t\"watch\": false, (true, 热启动,只要用文件内容变化自行重启)\n\t\t\"instances\": 4,  (4核启动)\n\t\t\"log_date_format\": \"YYYY-MM-DD HH:mm Z\", \n\t\t\"max_memory_restart\": \"300M\", (内存到300M自动重启)\n\t\t\"cwd\" : \"/usr/local/project\", (项目根目录绝对地址)\n\t\t\"exec_mode\":'cluster',(多核模式)\n\t\t\"env\": {\n\t\t\t\"NODE_ENV\": \"production\" (生成环境)\n\t\t},\n\t}]\n}\n```\n启动\n\n```\npm2 start process.json\n```\n\n* 进程列表\n\n```\npm2 list\n\n```\n\n* 进程监控\n\ncpu和内存的运行状态\n```\npm2 monit\n\n```\n\n* 进程重启\n\n```\npm2 restart id|name\n\n```\n\n* 进程删除\n\n```\npm2 delete id|name\n\n```\n\n* 进程停用\n\n```\npm2 stop id|name\n\n```\n\n\n* 进程描述\n\n```\npm2 desc id|name\n\n```\n\n* 设置log时间戳\n\n方便我按日期查日志\n\n```\npm2 start xxx.js --log-date-format=\"YYYY-MM-DD HH:mm Z\"\n```\n\n如果你之前忘记设置了,也没关系,restart就行\n\n\n```\npm2 restart xxx.js --log-date-format=\"YYYY-MM-DD HH:mm Z\"\n```\n\n\n* 开机启动\n\n```\n pm2 save \npm2 startup ［centos / redhat, amazon, ubuntu, gentoo, systemd or darwin］根据自己的os进行选择 我们在centos 所以是pm2 startup centos\n\n```\n\n* 显示pm2进程\n\n```\nps -ef|grep pm2\n\n```\n\n ![pm2](/image/nodejs/pm2.png)\n \n* 删除pm2进程\n\n```\nsudo kill -9 30249\n \n```\n \n","tags":["nodejs"],"categories":["nodejs"]},{"title":"mac svn环境配置","url":"/server/svnstart.html","content":"\n## 说明\n\nmac系统对于nodejs开发人员来说,体验会比windows好很多,本人之前用的windows,mac的优势就是命令敲起来比\nwindows更舒服,安装node包的时候也少出错,另外一个优势就是mac自带xcode,而xcode又自带svn,那么如何利用这一优势\n来管理我们的文件版本呢?\n\n\n## 实现\n### 创建代码仓库\n创建代码仓库，用来存储客户端所上传的代码\n\n先在 Documents/SVN，以后可以在SVN目录下创建多个仓库目录,\n打开命令终端，创建一个mycode仓库，输入指令：\n\n```\nsvnadmin create Documents/workplace/SVN/blogger\n```\n\n指令执行成功后，会发现硬盘上多了个blogger目录，目录结构如下：\n\n ![svn1](/image/svn/svn1.png)\n \n### 配置svn的用户权限\n \n 主要是修改/svn/blogger/conf目录下的三个文件\n \n * 打开svnserve.conf，将下列配置项前面的#和空格都去掉\n``` \n # anon-access = read\n # auth-access = write\n \n # password-db = passwd\n \n # authz-db = authz\n ```\n \n \n anon-access = read代表匿名访问的时候是只读的，若改为anon-access = none代表禁止匿名访问，需要帐号密码才能访问\n \n * 打开passwd，在[users]下面添加帐号和密码，比如：\n```\n [users]\n ustbtaotao = 123\n ```\n \n 帐号是ustbtaotao，密码是123\n \n * 打开authz，配置用户组和权限\n \n 我们可以将在passwd里添加的用户分配到不同的用户组里，以后的话，就可以对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。\n \n 在[groups]下面添加组名和用户名，多个用户之间用逗号(,)隔开\n```\n [groups]\n topgroup=ustbtaotao\n ```\n 说明ustbtaotao都是属于topgroup这个组的，接下来再进行权限配置。\n \n 使用[/]代表svn服务器中的所有资源库\n \n```\n [/]\n @topgroup = rw\n```\n 上面的配置说明topgroup这个组中的所有用户对所有资源库都有读写(rw)权限，组名前面要用@\n \n 如果是用户名，不用加@，比如username这个用户有读写权限\n``` \n [/]\n username = rw\n ```\n \n 至于其他精细的权限控制，可以参考authz文件中的其他内容\n \n * 启动svn服务器\n \n 前面配置了这么多，最关键还是看能否正常启动服务器，若启动不来，前面做再多工作也是徒劳。\n \n 在终端输入下列指令：\n \n ```\n svnserve -d -r Documents/workplace/SVN\n ```\n \n 或者输入：\n \n ```\n svnserve -d -r Documents/workplace/SVN/blogger\n ```\n 没有任何提示就说明启动成功了\n \n ![svn2](/image/svn/svn2.png)\n \n \n * 关闭svn服务器\n \n 如果你想要关闭svn服务器，最有效的办法是打开实用工具里面的“活动监视器”\n  ![svn3](/image/svn/svn3.png)\n \n综合上述，我们就可以轻松搭建svn服务器环境了\n \n \n ### 本地文件到服务器\n \n* 在终端中输入\n \n```\n svn import -m 'init repo' ~/Documents/workplace/blogger/ svn://localhost/source/blogger --username=ustbtaotao --password=123\n ```\n \n 将blogger所有文件上传到 source/blogger \n ![svn4](/image/svn/svn4.png)\n \n* 从服务器端下载代码到客户端本地\n cd 到 /Documents/workplace/bloggersvn\n \n 在终端中输入\n \n ```\n cd /Documents/workplace/bloggersvn\n svn checkout svn://localhost/source/blogger --username=ustbtaotao --password=f19900422\n ```\n \n ![svn5](/image/svn/svn5.png)\n \n ## 使用svn客户端\n \n 这里我推荐<code>[svnx](http://mac.softpedia.com/get/Development/Editors/SvnX.shtml)</code>\n 打开svnx,添加work库\n \n  ![svn6](/image/svn/svn6.png)\n  ![svn7](/image/svn/svn7.png)\n  ![svn8](/image/svn/svn8.png)\n  \n  \n ## 最后\n  \n  如果你喜欢用命令行,可以svn help,查看svn常用命令\n  ![svn9](/image/svn/svn9.png)\n  \n","tags":["svn","服务"],"categories":["服务"]},{"title":"json数据key映射","url":"/javascript/nodekey.html","content":"\n## 说明\n有时候我们会遇到这样的场景,json数组中,源头数据key不是我们最终想要的,比如我们项目遇到数据同步的问题,\n提供方的字断属性名和我们有出入,如何统一到我们最终想要的结果呢,现在抛砖一种解析方法\n\n\n## 实现\n\n### 目标：\n\n```\n{\n   \"a\":\"test\",\n   \"aa\":\"test\"\n}\n==>\n{\n  \"b\":\"test\",\n  \"bb\":\"test\"\n}\n```\n\n\n### key转小写(可省略)\n\n```\nfor (var key in data) {\n data[key.toLowerCase()] = data[key];\n if (key.toLowerCase() != key) {\n   delete(data[key]);\n }\n}\n```\n\n### 新建字段映射\n```\n\nvar keyconfig = [\n    {\"destkey\": \"b\", \"originkey\": \"a\"},\n    {\"destkey\": \"bb\", \"originkey\": \"aa\"},\n    {\"destkey\": \"bbb\", \"originkey\": \"aaa\"}\n]\n\n```\n\n\n### 映射\n\n```\nvar temp;\nfor (var originkey in data) {\n    temp = keyconfig.filter((item)=> {\n        return item.originkey == originkey;\n    })[0];\n    data[temp.destkey] = data[originkey];\n    if (temp.destkey != originkey) {\n        delete(data[originkey]);\n    }\n}\n```\n\n### 测试\n\n ![test](/image/nodejs/json.jpeg)\n","tags":["javascript","nodejs"],"categories":["javascript"]},{"title":"mongodb mac软连接限制","url":"/mongo/mongolimit.html","content":"## 说明\n\n如果你在mac上安装了mongodb,在启动后有时候会报一个警告\n** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000\n大概意思是:软连接数太少了,至少是1000个但现在只有256\n当你看到这样的warning时,不必惊慌,两个方案;\n\n### 方案一\n\n不管了,因为我是本地测试用,够用了\n\n\n### 方案二\n\n如果你有强迫症,没事我们也有办法,只需要在启动mondo的命令前搞点事情就完美解决了\n\n```\nulimit -n 1024 && mongo\n./mongod -dbpath = /home/data/mongodb/mongodb_data/ --port 27017\n```\n\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb后台运行","url":"/mongo/mongorun.html","content":"## 说明\n\n在我们之前的[博客](/mongo/mongostart.html)中,我们是通过控制台的方式进行的启动,但这样存在一个问题就是如果不小心或者\n手痒痒不小心给关了,那么恭喜你,你把db服务关掉了,如何防止这个问题呢,答案当然是在后台静默运行\n\n## 第一种方式(推荐)\n\n### 配置启动脚本\n我们起名为mongo.conf\n\n```\nport=27017 #端口号\n\ndbpath=/home/data/mongodb/mongodb_data/ #数据库路径\n\nlogpath=/home/data/mongodb/mongodb_log/mongodb.log #日志输出文件路径\n\npidfilepath=/usr/local/mongodb/mongo.pid\n\nfork=true #设置后台运行\n\nlogappend=true #日志输出方式\n\nshardsvr=true\n\ndirectoryperdb=true\n\n#auth=true  #开启认证\n\n\n```\n\n### 启动\n\n```\n./mongod --config mongo.conf\n\n```\n\n### 配置开机启动\n\n```\nvi /etc/rc.local\n在最后一行加入\n\n/xxx/mongod(mongod的绝对路径) --config /xxx/mongo.conf (mongo.conf的绝对路径)\n```\n\n## 第二种\n直接命令行启动 \n\n```\n/mongod --dbpath = /home/data/mongodb/mongodb_data/ --port 27017 --logpath = /home/data/mongodb/mongodb_log/mongodb.log —log append —fork\n```\n\n### 配置开机启动\n\n```\nvi /etc/rc.local\n在最后一行加入\n\n/xxx/mongod(mongod的绝对路径) --dbpath = /home/data/mongodb/mongodb_data/ --port 27017 --logpath = /home/data/mongodb/mongodb_log/mongodb.log —log append —fork\n```\n","tags":["mongo"],"categories":["mongo"]},{"title":"react项目中实现瀑布流","url":"/reactjs/reactremasonry.html","content":"\n## 说明\n\n熟悉jquery jquery UI的童鞋们都知道,要实现模版式瀑布流很简单,有好多现成的成熟的插件,\n得来全不费功夫,直接根据文档上手套用即可。那么问题来了,我们这是react项目,虽说可以应用jquery,\n但是不到万不得已还是不印的好,因为会有你想不到的坑等着你,毕竟jquery和react原理是不相同的。\n经过项目实践积累,发现了一款比较好用且操作简单的插件:[react-masonry-component(5.0.3)](https://www.npmjs.com/package/react-masonry-component)\n\n## 实现\n\n\n\n### 定义模版,即瀑布流中每个item的布局样式等\n```\nlet lstItem = (item, index)=> {\n      let rand = random.number(1) % 2;\n      return (\n        <div key={item.detailid}\n             className=\"item_left\">\n          <h1>{item.name}</h1>\n          <p>{item.descs}</p>\n          <div className={'item_img ' + (rand === 0 ? 'imgframe' : 'imgframe1')}>\n            <img\n              src={  (item.pictrue ? item.pictrue : default_pic_1)}\n              alt=\"\"/>\n          </div>\n        </div>\n      );\n    }\n\n```\n\n### 引入瀑布流插件\n\n```\n <Masonry\n          className={'my-gallery-class'} // default ''\n          elementType={'div'} // default 'div'\n          options={{transitionDuration: 5, transitionProperty: 'width'}} // default {}\n          disableImagesLoaded={false} // default false\n          updateOnEachImageLoad={false} // default false and works only if disableImagesLoaded is false\n        >\n          {data.map(lstItem);}\n </Masonry>\n```\n\n### so easy\n ![瀑布流](/image/react/liu.jpeg)\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"react项目中实现返回不刷新","url":"/reactjs/reactrefresh.html","content":"\n## 说明\n\n打开京东手机web版,细心的你会发现,当你从首页list页跳到详情页在返回(不论你点的是app的返回还是安卓返回健)的时候列表页位置还是静静的在哪里,\n在我们的react项目里如何实现呢?首先我们的了解清楚react里两个重要的上下文传递对象,props和state,props我们可以理解为全局的,这个很重要,也是我们实现\n不刷新的基础,state可以理解为局部的,只对当前组件有效;\n\n另外补充下react生命周期以及涉及的API\n\n* 实例化\n** 首次实例化\n<code>getDefaultProps</code>\n<code>getInitialState</code>\n<code>componentWillMount</code>\n<code>render</code>\n<code>componentDidMount</code>\n\n* 实例化完成后的更新\n\n<code>getInitialState</code>\n<code>componentWillMount</code>\n<code>render</code>\n<code>componentDidMount</code>\n\n* 存在期\n** 组件已存在时的状态改变\n\n<code>componentWillReceiveProps</code>\n<code>shouldComponentUpdate</code>\n<code>componentWillUpdate</code>\n<code>render</code>\n<code>componentDidUpdate</code>\n\n* 销毁&清理期\n<code>componentWillUnmount</code>\n\n\n可以看出来render是在componentDidUpdate之后,即页面渲染完才会执行,这里也是我下手的地方之一。\n\n## 实现\n\n老规矩,啥也不说了上代码\n\n### 取数据\n```\ncomponentDidMount() {\n    this.props.list.data && this.props.list.data.length <= 0 && this.props.getList.call(this);\n  }\n\n```\n\n<code>this.props.list.data && this.props.list.data.length <= 0</code>  这句的目的就是防止第二次重新加载已有数据,换句话说就是只有第一次访问进来的时候\n才会执行getlist方法;\n\n数据请求了,该怎么接收呢?\n\n### 接收数据\n```\ncomponentWillReceiveProps(newProps) {\n    if (newProps.list.data && newProps.list.data.length > 0) {\n      //第一次加载将数据换存在全局变量Glist中;\n      if (this.props.list.data && this.props.list.data.length <= 0) {\n        let newData = newProps.list.data;\n        Glist = newData;\n      } \n      // 之后数据使用本地缓存即可\n      else {\n        Glist = Glist;\n      }\n    }\n  }\n```\n \nGlist是个全局变量,类似本地缓存,有人问了为什么不用<code>localStorage</code>,因为会有浏览器兼容性问题 \n\n### 定位\n正常情况下应该是可以实现,detail---》list不刷线的功能,但还有问题就是定位,比如list开始是在20条的位置,回来的时候应该还是在20条的位置,\n没做任何处理前,pc和android是可以自动定位的,但是烂苹果就不行,还是在top0的位置,所以呢我们还得再设置个全局变量 scrollTop,默认为0,\n当点击列表的时候,设置scrollTop,回来的时候再设定就可以了,完美的定位了pc、ios和android\n\n```\nlet scrollTop=0;\ncomponentDidUpdate() {\n    /// 判断的目的是为了不让页面其他组件渲染完毕的时候执行定位,如果不设置判断,比如你的页面有好多子组件,每个子组件componentDidUpdate\n    /// 都会执行它,那么问题来了,没有判读所以都会执行以下document.body.scrollTop = scrollTop[默认为0];会看到会有往页面顶部窜动的效果\n    if (scrollTop > 100) {\n      document.body.scrollTop = scrollTop;\n    }\n }\n  \n  \n  \nshowDetail() {\n    scrollTop = document.body.scrollTop;\n }  \n```\n\n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^\n  ","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"react项目中实现音频播放,自定义UI","url":"/reactjs/reactaudio.html","content":"\n## 说明\n\n在html项目中,有一类需求就是音频,有的希望上背景播放,有的希望是有UI的交互式播放,比如微信里H5右上角的播放器等等,本文将介绍带UI的音频播放器的实现步骤。\n功能包括:获取音频时间、当前播放时间、暂停、播放、播放到最后自动停止等\n如何实现呢,让我走起:\n\n## 配置页面\n\n老规矩,啥也不说了上代码\n\n```\nrender() {\n   let divHeight = window.innerHeight - 50 - 30;\n       /*let src = this.props.singText === '' ? this.props.singValue[0] : [];\n        let imgsrc = src.pictrue ? src.pictrue : image_schoolsong;\n        let songsrc = src.descs ? src.descs : '';*/\n       let child = (\n         <div>\n           <div className=\"content\" style={{maxHeight: `${divHeight}px`, overflow: 'auto'}}>\n             <img src={this.state.imgUrl} style={{width: \"100%\"}}/>\n           </div>\n           <div className=\"footer\" onClick={this.play}>\n             <em className={!this.state.showPlay ? 'audioplay' : 'audiopause'}></em>\n             {this.state.showPlay ? this.state.currentTime + '/' + this.state.duration : '点击播放'}\n           </div>\n           /// 音频播放器\n           <audio ref=\"song\" id=\"song\" preload=\"metadata\"\n                  src={this.state.songUrl.length > 0 ? this.state.songUrl : '/source/song.mp3'}>\n           </audio>\n         </div>\n       );\n       return (\n         <ActionBarLayout title='song' children={child}/>\n       );\n  }\n```\n\n## 代码说明\n\n页面刚开始点进来的时候如下图所示,会看到一个播放按钮,当我们点击的时候,会有相应的交互,即点击播放按钮变为 time/time的形式,time的格式为x:xx,\n如何活着音频总长度和当前播放时间,我们可以调用audio的API, \n这功能如何实现呢,上:\n\n```\nplay() {\n    let myVid = this.refs.song;//document.getElementById(\"song\");\n    //控制播放开关显隐\n    this.setState({\n      showPlay: !this.state.showPlay\n    });\n    showPlay = !showPlay;\n    if (showPlay) {\n      // 更新time/time\n      this.timeUpdate();\n    } else {\n      // 暂停\n      clearInterval(timer);\n      myVid.pause();\n    }\n\n  }\n```\n\n暂停好办,直接用pasue() 就行,time怎么更新呢?最简单的实现就是定一个timer,固定频率去获取当前播放进度,然后进行格式化显示;\n```\ntimeUpdate() {\n       let myVid = this.refs.song;//document.getElementById(\"song\");\n       myVid.play();\n       let time;\n       let that = this;\n       let total = parseInt(myVid.duration); // 总时长 单位是s\n       total = total ? parseInt(total / 60) + ':' + (parseInt(total % 60).toString().length === 1 ? '0' + parseInt(total % 60) : parseInt(total % 60)) : '0:00';\n       that.setState({\n         duration: total\n       });\n       // 定时器\n       timer = setInterval(function () {\n         let currentTime = myVid.currentTime;\n         time = currentTime;\n         currentTime = parseInt(currentTime / 60) + ':' + (parseInt(currentTime % 60).toString().length === 1 ? '0' + parseInt(currentTime % 60) : parseInt(currentTime % 60));\n         total = parseInt(myVid.duration);\n         total = total ? parseInt(total / 60) + ':' + (parseInt(total % 60).toString().length === 1 ? '0' + parseInt(total % 60) : parseInt(total % 60)) : '0:00';\n         that.setState({\n           duration: total\n         });\n         // 当前进度和总时间相等是,销毁timer\n         if (parseInt(myVid.duration) != 0 && parseInt(myVid.currentTime) == parseInt(myVid.duration)) {\n           clearInterval(timer);\n           myVid.load();\n           that.setState({\n             showPlay: !that.state.showPlay\n           });\n           showPlay = false;\n           currentTime = 0;\n         }\n \n         that.setState({\n           currentTime: currentTime,\n           duration: total\n         });\n       }, 50);\n     }\n\n```\n## 效果图\n ![audio1](/image/react/audio1.png)\n ![audio2](/image/react/audio2.png)\n \n## 最后\n \n 如有疑问或者更好的方案留言下方……^_^\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"node安装包的时候慢的解决办法","url":"/nodejs/nodetaobao.html","content":"\n\n## 说明\n\n有些包下载比较慢或者需要翻墙才能下载安装,可以设置npm config属性,将node包源地址改到淘宝,具体命令如下:\n\n```\n npm config set registry \"https://registry.npm.taobao.org\"\n npm config list  --检测是否成功\n\n```\n如果成功了可见如下结果:\n\n```\nregistry = \"https://registry.npm.taobao.org/\"\n\n```\n![success](/image/nodejs/landeng.jpeg)\n## 最后\n\n提供一个免费的表好用的翻墙软件 <code>[[蓝灯]]( https://bit.ly/lantern-cn)<code> 邀请码 YHXF8VY\n","tags":["nodejs"],"categories":["nodejs"]},{"title":"react项目中实现视频播放,可自动横屏(二)","url":"/reactjs/reactvedio2.html","content":"\n## 说明\n\n[[上一篇]](/reactjs/reactvedio.html)中我们实现了react项目中的视频播放。\n当然播放是没有问题的,但是会有个小问题,有的视频播放的时候虽然没问题,但是充满不了整个手机宽度, 如图\n\n  ![3](/image/react/vedio3.jpeg)\n正常应该是这样的\n ![2](/image/react/vedio2.jpeg)\n  \n我们该怎么做呢?\n## 样式控制\n\n当然我们得了解清楚为什么会这样:视频都会有自己的分辨率 比如 16:9 4:3 等;而手机也有自己的宽高比,\n那方法就有了,我们可以按照手机的比例来装载video;\n\n上一编,还记得我们有个两个样式 video_container 和 video\n\n```\n<div className=\"video_container\">\n          <video id='media' ref='media' className=\"video\" style={{display: 'none'}} controls='true' webkit-controls\n                 width='100%'\n                 type='video/mp4' height='180px'\n                 src={data} webkit-playsinline playsinline>\n          </video>\n        ...\n</div>\n```\n\n我们将video_container 设置为 宽度100,内容填充按照9/16=56.25%来设置,当然最好根据手机分辨率来设置\n\n```\n.video_container {\n  width: 100%;\n  position: relative;\n  padding-bottom: 56.25%;\n  height: 0;\n  .video {\n    display: block;\n    width: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n}\n```\n\n最后我们看到的应该是这样子的\n![2](/image/react/vedio2.jpeg)\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"react项目中实现视频播放,可自动横屏(一)","url":"/reactjs/reactvedio.html","content":"\n## 说明\n\n在html项目中,有一类需求就是视频除了正常的播放,播放暂停,快进快退,还有一个开挂服务就是自动全屏,如何实现呢,让我走起:\n\n## 配置页面\n\n啥也不说了上代码\n\n```\nrender() {\n    let data = this.props.videoText == '' ? this.props.videoValue : null;\n    let src = '';\n    let divHeight = window.innerHeight - 50 + 44;\n    let child = (\n      <div style={{maxHeight: `${divHeight}px`, overflow: 'auto'}}>\n       // 视频缓冲的时候尤其是ios加载较慢的时候,可以根据loadflush来控制限制loading状态\n        <div className='weui_loading_toast' style={{display: this.state.loading ? 'block' : 'none'}}>\n          <Mask transparent={true} style={{position: 'relative'}}/>\n          <div className=\"weui_toast\" style={{top: '30px'}}>\n            <Icon value='loading'/>\n            <p className=\"weui_toast_content\">加载中...</p>\n          </div>\n        </div>\n        // 视频容器\n        <div className=\"video_container\">\n          // html video视频标签\n          <video id='media' ref='media' className=\"video\" style={{display: 'none'}} controls='true' webkit-controls\n                 width='100%'\n                 type='video/mp4' height='180px'\n                 src={data} webkit-playsinline playsinline>\n          </video>\n          // video 初始进来的时候封面\n          <div className=\"adv\" id=\"adv\" onClick={this.play}>\n            <div className=\"videa_play\"><img src={iconbtn_video} alt=\"\" className=\"videaplay\"/></div>\n            <img src={video_img} style={{width: \"100%\", height: \"180px\"}}/>\n          </div>\n        </div>\n      </div>\n    );\n    return (\n      <ActionBarLayout title='宣传片' children={child}/>\n    );\n  }\n```\n\n## 代码说明\n\n页面刚开始点进来的时候如下图所示,会看到一个播放按钮,当我们点击的时候,会有相应的交互,即封面取消,vedio标签浮现,并自动横屏播放,\n  ![0](/image/react/vedio00.jpeg)\n这功能如何实现呢,上:\n\n```\nplay() {\n    document.getElementById(\"adv\").style.display = \"none\";\n    document.getElementById(\"media\").style.display = \"block\";\n    let video = this.refs.media;\n    video.play();\n    this.setState({\n      loading: true\n    });\n    let that = this;\n    setInterval(function () {\n      if (video.buffered.end(0) > 0) {\n        that.setState({\n          loading: false\n        });\n      }\n    }, 200);\n    requestFullScreen();\n    //进入全屏\n    function requestFullScreen() {\n      var de = document.documentElement;\n      if (de.requestFullscreen) {\n        de.requestFullscreen();\n      } else if (de.mozRequestFullScreen) {\n        de.mozRequestFullScreen();\n      } else if (de.webkitRequestFullScreen) {\n        // screen.orientation.lock('landscape'); 发现小米4或者部分低版本的android会出现假横屏,导致controler里的全屏按钮点击没反应了,为了兼容我们加上这句,这样小米\n        // 4虽然不会自动横屏,但是手动全屏还是可以的,其他手机都ok[ios,android]\n        screen.orientation.lock('landscape');\n        de.webkitRequestFullScreen();\n      }\n    }\n  }\n```\n\n由于react并没有play和pause实践,所以我们得注册下\n```\ncomponentDidMount() {\n    var mmedia = document.getElementById(\"media\");\n    mmedia.addEventListener(\"play\", userPlay);\n    mmedia.addEventListener(\"pause\", userPause);\n    function userPlay() {\n      document.getElementById(\"adv\").style.display = \"none\";\n    }\n\n    function userPause() {\n      this.setState({\n        loading: false\n      });\n      document.getElementById(\"adv\").style.display = \"block\";\n    }\n  }\n\n```\n## 效果图\n\n  ![1](/image/react/vedio1.jpeg)\n  \n## 最后\n  \n当然播放是没有问题的,但是会有个小问题,有的视频播放的时候虽然没问题,但是充满不了整个手机宽度, 如图\n\n  ![3](/image/react/vedio3.jpeg)\n 该怎么破呢,我会在下一篇博客中进行[[说明]](/reactjs/reactvedio2.html)\n","tags":["reactjs","javascript"],"categories":["reactjs"]},{"title":"mongodb快速入门(八)","url":"/mongo/mongoend.html","content":"## 说明\nmongodb驱动实践等,以windows为例\n## 实践\n 作为系列的最后一篇，得要说说C#驱动对mongodb的操作，目前驱动有两种：官方驱动和samus驱动，不过我个人还是喜欢后者，\n因为提供了丰富的linq操作，相当方便。\n \n官方驱动：[官方驱动](https://github.com/mongodb/mongo-csharp-driver/downloads)。下载后，还提供了一个酷似msdn的帮助文档。\nsamus驱动：[samus驱动](https://github.com/samus/mongodb-csharp/downloads)。 \n \n下面就具体看看samus驱动，[戳我](https://github.com/samus/mongodb-csharp/blob/master/examples/Simple/Main.cs)上面提供了\n一个简单的demo，大体上看看我们就知道怎么玩了。\n \n一： 实践\n1：我们建立一个Person实体，MongoAlias特性表示取别名，这里的ID值将会覆盖掉数据库自动生成的_id。\n```\n  #region 数据实体\n \n/// <summary>\n \n/// 数据实体\n  /// \n</summary>\n \n   public classPerson\n{\n \n  [MongoAlias(\"_id\")]\n \n public string ID { get; set; }\n public string Name { get; set; }\n public DateTime CreateTime { get; set; }\n public int Age { get; set; }\n#endregion\n}\n```\n 2：初始化一些变量\n \n```\nstring connectionString = string.Empty;\nstring databaseName = string.Empty;\nstring collectionName = string.Empty;\nstatic MongodbHelper<T> mongodb;\n \n#region 初始化操作\n  /// <summary>\n /// 初始化操作\n/// \n</summary>\n \n public MongodbHelper()\n \n {\n   connectionString = \"Server=.0.0.1:2\";\n    databaseName = \"shopex\";\n \n    collectionName = \"person\";\n }\n \n#endregion\n \n```\n3：为了方便T的继承类使用linq功能，我们还需要映射一下。\n```\n #region 实现linq查询的映射配置\n   /// <summary>\n \n /// 实现linq查询的映射配置\n \n /// \n</summary>\n \n   public\n MongoConfiguration configuration\n{\n \n   get\n \n   {\n \nvar config = new\n MongoConfigurationBuilder();\n \n \n \n  config.Mapping(mapping =>\n \n  {\n \n mapping.DefaultProfile(profile =>\n \n {\n \nprofile.SubClassesAre(t => t.IsSubclassOf(typeof\n(T)));\n \n });\n \n mapping.Map<T>();\n \n mapping.Map<T>();\n \n  });\n \n \n \n  config.ConnectionString(connectionString);\n \n \n \n  return\n config.BuildConfiguration();\n \n   }\n \n    }\n \n    #endregion\n \n```\n4：下面是一些基本的CURD的代码，跟写EF代码很类似，写起来好舒服。\n```\n#region 插入操作\n \n  /// <summary>\n \n  /// 插入操作\n \n  /// </summary>\n \n  /// <param name=\"person\"></param>\n \n   /// \n<returns></returns>\n \n    public void\n Insert(T t)\n \n \n {\n \n   using (Mongo mongo = new\n Mongo(configuration))\n \n \n   {\n \n   try\n \n \n  {\n \n \n mongo.Connect();\n \n \n \n \n  var\n db = mongo.GetDatabase(databaseName);\n \n \n \n \n  var\n collection = db.GetCollection<T>(collectionName);\n \n \n \n \n  collection.Insert(t, true\n);\n \n \n \n \n \n mongo.Disconnect();\n \n \n \n \n \n  }\n \n   catch\n (Exception)\n \n \n  {\n \n \n mongo.Disconnect();\n \n  throw\n;\n \n \n  }\n \n \n   }\n \n \n    }\n \n#endregion\n \n \n \n \n#region 更新操作\n \n/// <summary>\n \n  /// 更新操作\n \n  /// </summary>\n \n  /// <param name=\"person\"></param>\n \n  /// \n<returns></returns>\n \npublic void Update(T t, Expression<Func<T, bool\n>> func)\n \n \n    {\n \n    using (Mongo mongo = new\n Mongo(configuration))\n \n \n   {\n \n   try\n \n \n  {\n \n \n mongo.Connect();\n \n \n \n \n  var\n db = mongo.GetDatabase(databaseName);\n \n \n \n \n  var\n collection = db.GetCollection<T>(collectionName);\n \n \n \n \n  collection.Update<T>(t, func, true\n);\n \n \n \n \n \n mongo.Disconnect();\n \n \n \n \n \n  }\n \n   catch\n (Exception)\n \n \n  {\n \n \n mongo.Disconnect();\n \n  throw\n;\n \n \n  }\n \n \n   }\n \n \n    }\n \n#endregion\n \n \n \n \n#region 获取集合\n \n/// <summary>\n \n  ///获取集合\n \n  /// </summary>\n \n  /// <param name=\"person\"></param>\n \n  /// \n<returns></returns>\n \npublic List<T> List(int pageIndex, int pageSize, Expression<Func<T, bool>> func, out int\n pageCount)\n \n \n    {\n \n    pageCount = 0\n;\n \n \n \n \n    using (Mongo mongo = new\n Mongo(configuration))\n \n \n   {\n \n   try\n \n \n  {\n \n \n mongo.Connect();\n \n \n \n \n  var\n db = mongo.GetDatabase(databaseName);\n \n \n \n \n  var\n collection = db.GetCollection<T>(collectionName);\n \n \n \n \n \n pageCount = Convert.ToInt(collection.Count());\n \n \n \n \n  var personList = collection.Linq().Where(func).Skip(pageSize * (pageIndex - 1\n))\n \n \n  .Take(pageSize).Select(i => i).ToList();\n \n \n \n \n \n mongo.Disconnect();\n \n \n \n \n  return\n personList;\n \n \n \n \n \n  }\n \n   catch\n (Exception)\n \n \n  {\n \n \n mongo.Disconnect();\n \n  throw\n;\n \n \n  }\n \n   }\n \n    }\n \n    #endregion\n \n \n \n    #region 读取单条记录\n \n    /// <summary>\n \n ///读取单条记录\n \n /// </summary>\n \n /// <param name=\"person\"></param>\n \n /// \n<returns></returns>\n \n    public T Single(Expression<Func<T, bool\n>> func)\n \n    {\n \n   using (Mongo mongo = new\n Mongo(configuration))\n \n   {\n \n  try\n \n  {\n \n mongo.Connect();\n \n \n \n var\n db = mongo.GetDatabase(databaseName);\n \n \n \n var\n collection = db.GetCollection<T>(collectionName);\n \n \n \n var\n single = collection.Linq().FirstOrDefault(func);\n \n \n \n mongo.Disconnect();\n \n \n \n return\n single;\n \n \n \n  }\n \n  catch\n (Exception)\n \n  {\n \n mongo.Disconnect();\n \n throw\n;\n \n  }\n \n   }\n \n    }\n \n    #endregion\n \n \n \n    #region 删除操作\n \n    /// <summary>\n \n /// 删除操作\n \n /// </summary>\n \n /// <param name=\"person\"></param>\n \n /// \n<returns></returns>\n \n    public void Delete(Expression<Func<T, bool\n>> func)\n \n    {\n \n   using (Mongo mongo = new\n Mongo(configuration))\n \n   {\n \n  try\n \n  {\n \n mongo.Connect();\n \n \n \n var\n db = mongo.GetDatabase(databaseName);\n \n \n \n var\n collection = db.GetCollection<T>(collectionName);\n \n \n \n //这个地方要注意，一定要加上T参数，否则会当作object类型处理\n \n //导致删除失败\n \n collection.Remove<T>(func);\n \n \n \n mongo.Disconnect();\n \n \n \n  }\n \n  catch\n (Exception)\n \n  {\n \n mongo.Disconnect();\n \n throw\n;\n \n  }\n \n   }\n \n    }\n \n    #endregion\n ```\n   好，我们开一下2端口，由于前前篇我已经把这个mongodb做成了服务，现在就直接连过去了，并做一下对Name的索引。\n  ![mongo81](/image/mongo/81.png)  \n \n 一切准备妥当，我们做下基本的操作，比如这里我添加一千条数据，注意我开启的是安全模式，如果插入不成功，将会抛出异常。\n <1> Add:\n\n```\n static void Main(string[] args)\n  {\n \n  MongodbHelper<Person> helper = new MongodbHelper<Person>();\n   ///插入0条数据\n for (int i = 0; i < 0; i++)\n  {\n   helper.Insert(new Person()\n  {\n ID = Guid.NewGuid().ToString(),\n \nName = \"jack\"+ i,\n Age = i,\n CreateTime = DateTime.Now\n \n  });\n \n   }\n   Console.WriteLine(\"插入成功\");\n   Console.Read();}\n```  \n     \n     \n  ![mongo82](/image/mongo/82.png)  \n\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(六)","url":"/mongo/mongo5.html","content":"## 说明\n\nmongodb分片技术等,以windows为例\n\n## 实践\n\n\n   在mongodb里面存在另一种集群，就是分片技术，跟sql server的表分区类似，我们知道当数据量达到T级别的时候，我们的磁盘，内存\n \n 就吃不消了，针对这样的场景我们该如何应对。\n \n  \n \n 一：分片\n \n mongodb采用将集合进行拆分，然后将拆分的数据均摊到几个片上的一种解决方案。\n ![mongo61](/image/mongo/61.png)\n  \n \n 下面我对这张图解释一下：\n  人脸：       代表客户端，客户端肯定说，你数据库分片不分片跟我没关系，我叫你干啥就干啥，没什么好商量的。\n\n mongos： 首先我们要了解”片键“的概念，也就是说拆分集合的依据是什么？按照什么键值进行拆分集合....\n\n   好了，mongos就是一个路由服务器，它会根据管理员设置的“片键”将数据分摊到自己管理的mongod集群，数据\n\n   和片的对应关系以及相应的配置信息保存在\"config服务器\"上。\n\nmongod:   一个普通的数据库实例，如果不分片的话，我们会直接连上mongod。\n\n  \n \n 二： 实战\n \n 首先我们准备4个mongodb程序，我这里是均摊在C，D，E，F盘上，当然你也可以做多个文件夹的形式。\n \n 1：开启config服务器\n \n  先前也说了，mongos要把mongod之间的配置放到config服务器里面，理所当然首先开启它，我这里就建立2222端口。\n  ![mongo62](/image/mongo/62.png)\n  \n \n 2: 开启mongos服务器\n \n 这里要注意的是我们开启的是mongos，不是mongod，同时指定下config服务器，这里我就开启D盘上的mongodb，端口3333。\n  ![mongo63](/image/mongo/63.png)\n  \n \n 3：启动mongod服务器\n \n 对分片来说，也就是要添加片了，这里开启E，F盘的mongodb，端口为：4444，5555。\n \n  ![mongo64](/image/mongo/64.png) \n \n 4： 服务配置\n \n 哈哈，是不是很兴奋，还差最后一点配置我们就可以大功告成。\n \n  <1> 先前图中也可以看到，我们client直接跟mongos打交道，也就说明我们要连接mongos服务器，然后将4444，5555的mongod\n \n  交给mongos,添加分片也就是addshard()。\n ![mongo65](/image/mongo/65.png)\n \n 这里要注意的是，在addshard中，我们也可以添加副本集，这样能达到更高的稳定性。\n \n  \n \n <2>片已经集群了，但是mongos不知道该如何切分数据，也就是我们先前所说的片键，在mongodb中设置片键要做两步\n \n①：开启数据库分片功能，命令很简单 enablesharding(),这里我就开启test数据库。\n \n ②：指定集合中分片的片键，这里我就指定为person.name字段。\n \n ![mongo66](/image/mongo/66.png)  \n \n 5: 查看效果\n \n 好了，至此我们的分片操作全部结束，接下来我们通过mongos向mongodb插入10w记录，然后通过printShardingStatus命令\n \n 查看mongodb的数据分片情况。\n ![mongo67](/image/mongo/67.png)\n \n  这里主要看三点信息：\n \n   ① shards：     我们清楚的看到已经别分为两个片了，shard0000和shard0001。\n \n   ② databases:  这里有个partitioned字段表示是否分区，这里清楚的看到test已经分区。\n \n   ③ chunks：     这个很有意思，我们发现集合被砍成四段：\n \n  无穷小 —— jack0，jack0 ——jack234813，jack234813——jack9999，jack9999——无穷大。\n \n   分区情况为：3：1，从后面的 on shardXXXX也能看得出。\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(七)","url":"/mongo/mongo6.html","content":"## 说明\n\nmongodb运维技术等,以windows为例\n\n## 实践\n\n\n这一篇我们以管理员的视角来看mongodb，作为一名管理员，我们经常接触到的主要有4个方面：\n\n1．  安装部署\n\n2．  状态监控\n\n3．  安全认证\n\n4．  备份和恢复，\n\n下面我们就一点一点的讲解。\n\n \n\n一：安装部署\n\n 我之前的文章都是采用console程序来承载，不过在生产环境中这并不是最佳实践，谁也不愿意在机器重启后满地找牙似找mongodb，\n\n在mongodb里面提供了一个叫做“服务寄宿”的模式，我想如果大家对wcf比较熟悉的话很容易听懂。好了，我们实践一下，这里我开一下D盘\n\n里面的mongodb。\n\n![mongo71](/image/mongo/71.png) \n\n这里要注意的有两点：\n\n   <1> logpath: 当我们使用服务寄宿的时候，用眼睛都能想明白肯定不会用console来承载日志信息了。\n\n   <2> install:   开启安装服务寄宿，很happy啊，把管理员的手工操作降低到最小，感谢mongodb。\n\n \n\n好了，console程序叫我看log日志，那我就看看，发现mongodb已经提示我们如何开启mongodb，接着我照做就是了。\n\n![mongo72](/image/mongo/72.png)  \n\n还要提醒大家一点的就是，这些命令参数很多很复杂也就很容易忘，不过没关系，数据库给我们提供了一个help方法，我们可以\n\n拿mongod和mongo说事。\n\nmongod：\n\n![mongo73](/image/mongo/73.png)  \n\nmongo：\n\n ![mongo74](/image/mongo/74.png) \n\n二：状态监控\n\n 监控可以让我们实时的了解数据库的健康状况以及性能调优，在mongodb里面给我们提供了三种方式。\n\n1：http监视器\n\n 这个我在先前的文章中也提到了，这里就不赘述了。\n\n2：serverStatus()\n 这个函数可以获取到mongodb的服务器统计信息，其中包括 ：全局锁，索引，用户操作行为等等这些统计信息，对管理员来说非常\n\n 重要，具体的参数含义可以参考园友：[戳我](http://www.cnblogs.com/xuegang/archive/2011/10/13/2210339.html)\n\n 这里还是截个图混个眼熟。\n\n![mongo75](/image/mongo/75.png)  \n\n3：mongostat\n\n 前面那些统计信息再牛X，那也是静态统计，不能让我观看实时数据变化，还好，mongodb里面提供了这里要说的mongodstat\n\n监视器，这玩意会每秒刷新，在实际生产环境中大有用处，还是截张图，很有意思，是不是感觉大军压境了。\n\n ![mongo76](/image/mongo/76.png) \n\n三: 安全认证\n\n 作为数据库软件，我们肯定不想谁都可以访问，为了确保数据的安全，mongodb也会像其他的数据库软件一样可以采用用户\n\n验证的方法，那么该怎么做呢？其实很简单，mongodb提供了addUser方法，还有一个注意点就是如果在admin数据库中添加\n\n将会被视为“超级管理员”。\n![mongo77](/image/mongo/77.png) \n上面的admin用户将会被视为超级管理员，“jack”用户追加的第三个参数表示是否是“只读用户”，好了，该添加的我们都添加了，\n\n我们第一次登录时不是采用验证模式，现在我们使用--reinstall重启服务并以--auth验证模式登录。\n![mongo78](/image/mongo/78.png) \n\n好了，我们进入test集合翻翻数据看看情况，我们发现jack用户始终都是没有写入的权限，不管是授权或者未授权。\n\n ![mongo79](/image/mongo/79.png) \n\n四：备份和恢复\n\n  这玩意的重要性我想都不需要我来说了吧，这玩意要是搞不好会死人的,mongodb里面常用的手段有3种。\n\n1： 直接copy\n\n 这个算是最简单的了，不过要注意一点，在服务器运行的情况下直接copy是很有风险的，可能copy出来时，数据已经遭到\n\n   破坏，唯一能保证的就是要暂时关闭下服务器，copy完后重开。\n\n2：mongodump和mongorestore\n\n  这个是mongo给我们提供的内置工具，很好用，能保证在不关闭服务器的情况下copy数据。\n\n为了操作方便，我们先删除授权用户。\n![mongo711](/image/mongo/711.png) \n \n\n好了，我们转入正题，这里我先在D盘建立一个backup文件夹用于存放test数据库。\n![mongo712](/image/mongo/712.png) \n\n快看，数据已经备份过来了，太爽了，现在我们用mongorestore恢复过去，记住啊，它是不用关闭机器的。\n![mongo713](/image/mongo/713.png) \n提一点的就是 drop选项，这里是说我将test数据恢复之前先删除原有数据库里面的数据，同样大家可以通过help查看。\n\n \n\n3：主从复制\n\n  这个我在上上篇有所介绍，这里也不赘述了。\n\n  其实上面的1，2两点都不能保证获取数据的实时性，因为我们在备份的时候可能还有数据灌在内存中不出来，那么我们\n\n想说能不能把数据暴力的刷到硬盘上，当然是可以的,mongodb给我们提供了fsync+lock机制就能满足我们提的需求。\n\nfsync+lock首先会把缓冲区数据暴力刷入硬盘，然后给数据库一个写入锁，其他实例的写入操作全部被阻塞，直到fsync\n\n+lock释放锁为止。\n\n这里就不测试了。\n\n 加锁：    db.runCommand({\"fsync\":1,\"lock\":1})\n\n 释放锁： db.$cmd.unlock.findOne()\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(五)","url":"/mongo/mongo4.html","content":"\n\n## 说明\n\nmongodb主从复制等,以windows为例\n\n## 实践\n\n\n \n \n 我们主要讨论mongodb的部署技术。\n \n  我们知道sql server能够做到读写分离，双机热备份和集群部署，当然mongodb也能做到，实际应用中我们不希望数据库采用单点部署，\n \n 如果碰到数据库宕机或者被毁灭性破坏那是多么的糟糕。\n \n  \n \n 一：主从复制\n \n 1： 首先看看模型图\n \n  ![mongo51](/image/mongo/51.png) \n \n 2: 从上面的图形中我们可以分析出这种架构有如下的好处：\n \n  <1>  数据备份。\n \n  <2>  数据恢复。\n \n  <3>  读写分离。\n \n  \n \n 3：下面我们就一一实践\n \n  实际应用中我们肯定是多服务器部署，限于自己懒的装虚拟机，就在一台机器上实践了。\n \n 第一步：我们把mongodb文件夹放在D盘和E盘，模拟放在多服务器上。\n \n 第二步：启动D盘上的mongodb，把该数据库指定为主数据库，其实命令很简单：>mongodb --dbpath='XXX' --master，\n \n  端口还是默认的27017.\n  ![mongo52](/image/mongo/52.png)\n \n 第三步：同样的方式启动E盘上的mongodb，指定该数据库为从属数据库，命令也很简单，当然我们要换一个端口，比如：8888。\n \n source 表示主数据库的地址。\n \n  >mongod --dbpath=xxxx --port=8888 --slave --source=127.0.0.1:27017\n ![mongo53](/image/mongo/53.png)\n 第四步：从图中的红色区域我们发现了一条：“applied 1 operations\"这样的语句，并且发生的时间相隔10s，也就说明从属数据库每10s\n \n 就向主数据库同步数据，同步依据也就是寻找主数据库的”OpLog“日志，可以在图中红色区域内发现”sync_pullOpLog“字样。\n \n  接下来我们要做的就是测试，惊讶的发现数据已经同步更新，爽啊。\n ![mongo54](/image/mongo/54.png)\n  \n 4：  如果我还想增加一台从属数据库，但是我不想在启动时就指定，而是后期指定，那么mongodb可否做的到呢？答案肯定是可以的。\n \n我们的主或者从属数据库中都有一个叫做local的集合，主要是用于存放内部复制信息。\n \n 好，那么我们就试一下，我在F盘再拷贝一份mongodb的运行程序，cmd窗口好多啊，大家不要搞乱了。\n ![mongo56](/image/mongo/56.png)\n \n  看上面的log，提示没有主数据库，没关系，某一天我们良心发现，给他后期补贴一下，哈哈，再开一个cmd窗口，语句也就是\n \n  在sources中add一个host地址，最后发现数据也同步到127.0.0.1:5555这台从属数据库中....\n \n ![mongo57](/image/mongo/57.png)    \n \n  \n \n 5: 读写分离\n \n  这种手段在大一点的架构中都有实现，在mongodb中其实很简单，在默认的情况下，从属数据库不支持数据的读取，但是没关系，\n \n 在驱动中给我们提供了一个叫做“slaveOkay\"来让我们可以显示的读取从属数据库来减轻主数据库的性能压力，这里就不演示了。\n \n  \n \n 二：副本集\n \n 这个也是很牛X的主从集群，不过跟上面的集群还是有两点区别的。\n  <1>:  该集群没有特定的主数据库。\n\n <2>:  如果哪个主数据库宕机了，集群中就会推选出一个从属数据库作为主数据库顶上，这就具备了自动故障恢复功能，很牛X的啊。\n\n   好，我们现在就来试一下，首先把所有的cmd窗口关掉重新来，清掉db下的所有文件。\n\n  \n \n 第一步:  既然我们要建立集群，就得取个集群名字，这里就取我们的公司名shopex, --replSet表示让服务器知道shopex下还有其他数据库，\n \n  这里就把D盘里面的mongodb程序打开，端口为2222。指定端口为3333是shopex集群下的另一个数据库服务器。\n \n  ![mongo58](/image/mongo/58.png)\n \n 第二步:  既然上面说3333是另一个数据库服务器，不要急，现在就来开，这里把E盘的mongodb程序打开。\n ![mongo59](/image/mongo/59.png)\n  \n \n 第三步：  ok，看看上面的日志红色区域，似乎我们还没有做完，是的，log信息告诉我们要初始化一下“副本集“，既然日志这么说，那我也就\n \n 这么做，随便连接一下哪个服务器都行，不过一定要进入admin集合。\n \n ![mongo60](/image/mongo/60.png) \n \n 第四步： 开启成功后，我们要看看谁才能成为主数据库服务器，可以看到端口为2222的已经成为主数据库服务器。\n \n ![mongo511](/image/mongo/511.png) \n \n 第五步：我们知道sql server里面有一个叫做仲裁服务器，那么mongodb中也是有的，跟sql server一样，仲裁只参与投票选举，这里我们\n \n  把F盘的mongodb作为仲裁服务器，然后指定shopex集群中的任一个服务器端口，这里就指定2222。\n ![mongo512](/image/mongo/512.png)\n  \n \n 然后我们在admin集合中使用rs.addArb()追加即可。\n ![mongo513](/image/mongo/513.png)\n 追加好了之后，我们使用rs.status()来查看下集群中的服务器状态，图中我们可以清楚的看到谁是主，还是从，还是仲裁。\n ![mongo514](/image/mongo/514.png)\n  \n \n 不是说该集群有自动故障恢复吗？那么我们就可以来试一下，在2222端口的cmd服务器按Ctrl+C来KO掉该服务器，立马我们发现\n \n 在3333端口的从属服务器即可顶上，最后大家也可以再次使用rs.status()来看下集群中服务器的状态。\n![mongo515](/image/mongo/515.png)\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(四)","url":"/mongo/mongo2.html","content":"## 说明\n\nmongodb索引操作等,以windows为例\n\n## 实践\n\n\n \n \n 好，今天分享下mongodb中关于索引的基本操作，我们日常做开发都避免不了要对程序进行性能优化，而程序的操作无非就是CURD，通常我们\n \n 又会花费50%的时间在R上面，因为Read操作对用户来说是非常敏感的，处理不好就会被人唾弃，呵呵。\n 从算法上来说有5种经典的查找，具体的可以参见我的算法速成系列，这其中就包括我们今天所说的“索引查找”，如果大家对sqlserver比较了解\n \n 的话，相信索引查找能给我们带来什么样的性能提升吧。\n \n 我们首先插入10w数据，上图说话：\n \n ![mongo41](/image/mongo/41.png) \n \n 一：性能分析函数（explain）\n \n 好了，数据已经插入成功，既然我们要做分析，肯定要有分析的工具，幸好mongodb中给我们提供了一个关键字叫做“explain\"，那么怎么用呢？\n \n 还是看图，注意，这里的name字段没有建立任何索引，这里我就查询一个“name10000”的姓名。\n  ![mongo42](/image/mongo/42.png) \n  仔细看红色区域，有几个我们关心的key。\n \n  cursor:       这里出现的是”BasicCursor\",什么意思呢，就是说这里的查找采用的是“表扫描”，也就是顺序查找，很悲催啊。\n \n  nscanned:  这里是10w，也就是说数据库浏览了10w个文档，很恐怖吧，这样玩的话让人受不了啊。\n \n  n:             这里是1，也就是最终返回了1个文档。\n \n  millis:        这个就是我们最最最....关心的东西，总共耗时114毫秒。 \n \n  \n \n 二：建立索引（ensureIndex）\n \n  在10w条这么简单的集合中查找一个文档要114毫秒有一点点让人不能接收，好，那么我们该如何优化呢？mongodb中给\n \n 我们带来了索引查找，看看能不能让我们的查询一飞冲天.....\n  ![mongo43](/image/mongo/43.png) \n      \n \n   这里我们使用了ensureIndex在name上建立了索引。”1“：表示按照name进行升序，”-1“：表示按照name进行降序。\n \n 我的神啊，再来看看这些敏感信息。\n \n  cursor:       这里出现的是”BtreeCursor\"，这么牛X，mongodb采用B树的结构来存放索引，索引名为后面的“name_1\"。\n  nscanned:  我擦，数据库只浏览了一个文档就OK了。\n  n:             直接定位返回。\n  millis:        看看这个时间真的不敢相信，秒秒杀。\n \n  \n \n 通过这个例子相信大家对索引也有了感官方面的认识了吧。\n \n  \n \n 三：唯一索引\n \n 和sqlserver一样都可以建立唯一索引，重复的键值自然就不能插入，在mongodb中的使用方法是：\n \n db.person.ensureIndex({\"name\":1},{\"unique\":true})。\n \n ![mongo44](/image/mongo/44.png) \n \n 四：组合索引\n \n  有时候我们的查询不是单条件的，可能是多条件，比如查找出生在‘1989-3-2’名字叫‘jack’的同学，那么我们可以建立“姓名”和\"生日“\n \n 的联合索引来加速查询。\n  ![mongo45](/image/mongo/45.png) \n \n 看到上图，大家或者也知道name跟birthday的不同，建立的索引也不同，升序和降序的顺序不同都会产生不同的索引，\n \n 那么我们可以用getindexes来查看下person集合中到底生成了那些索引。\n \n  ![mongo46](/image/mongo/46.png)  \n \n 此时我们肯定很好奇，到底查询优化器会使用哪个查询作为操作，呵呵，还是看看效果图：\n  ![mongo47](/image/mongo/47.png) \n \n 看完上图我们要相信查询优化器，它给我们做出的选择往往是最优的，因为我们做查询时，查询优化器会使用我们建立的这些索引来创建查询方案，\n \n 如果某一个先执行完则其他查询方案被close掉，这种方案会被mongodb保存起来，当然如果非要用自己指定的查询方案，这也是\n \n 可以的，在mongodb中给我们提供了hint方法让我们可以暴力执行。\n  ![mongo48](/image/mongo/49.png) \n  \n \n 五： 删除索引\n \n 可能随着业务需求的变化，原先建立的索引可能没有存在的必要了，可能有的人想说没必要就没必要呗，但是请记住，索引会降低CUD这三\n \n 种操作的性能，因为这玩意需要实时维护，所以啥问题都要综合考虑一下，这里就把刚才建立的索引清空掉来演示一下:dropIndexes的使用。\n  ![mongo49](/image/mongo/411.png) \n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(三)","url":"/mongo/mongo3.html","content":"## 说明\n\nmongodb高级操作等,以windows为例\n\n## 实践\n 今天跟大家分享一下mongodb中比较好玩的知识，主要包括：聚合，游标。\n\n## 聚合\n\n 常见的聚合操作跟sql server一样，有：count，distinct，group，mapReduce。\n\n### count\n\n  count是最简单，最容易，也是最常用的聚合工具，它的使用跟我们C#里面的count使用简直一模一样。\n\n ![mongo31](/image/mongo/31.png) \n\n### distinct\n\n 这个操作相信大家也是非常熟悉的，指定了谁，谁就不能重复，直接上图。\n\n ![mongo32](/image/mongo/32.png) \n\n### group\n\n 在mongodb里面做group操作有点小复杂，不过大家对sql server里面的group比较熟悉的话还是一眼\n\n能看的明白的，其实group操作本质上形成了一种“k-v”模型，就像C#中的Dictionary，好，有了这种思维，\n\n我们来看看如何使用group。\n\n   下面举的例子就是按照age进行group操作，value为对应age的姓名。下面对这些参数介绍一下：\n\n   key：  这个就是分组的key，我们这里是对年龄分组。\n\n   initial: 每组都分享一个”初始化函数“，特别注意：是每一组，比如这个的age=20的value的list分享一个\n\ninitial函数，age=22同样也分享一个initial函数。\n\n $reduce: 这个函数的第一个参数是当前的文档对象，第二个参数是上一次function操作的累计对象，第一次\n\n为initial中的{”perosn“：[]}。有多少个文档， $reduce就会调用多少次。\n\n ![mongo33](/image/mongo/33.png) \n\n  看到上面的结果，是不是有点感觉，我们通过age查看到了相应的name人员，不过有时我们可能有如下的要求：\n\n ①：想过滤掉age>25一些人员。\n\n ②：有时person数组里面的人员太多，我想加上一个count属性标明一下。\n\n 针对上面的需求，在group里面还是很好办到的，因为group有这么两个可选参数: condition 和 finalize。\n\n condition:  这个就是过滤条件。\n\n\n finalize:这是个函数，每一组文档执行完后，多会触发此方法，那么在每组集合里面加上count也就是它的活了。\n\n \n ![mongo34](/image/mongo/34.png) \n\n### mapReduce\n\n 这玩意算是聚合函数中最复杂的了，不过复杂也好，越复杂就越灵活。\n\n mapReduce其实是一种编程模型，用在分布式计算中，其中有一个“map”函数，一个”reduce“函数。\n\n  ① map：\n\n   这个称为映射函数，里面会调用emit(key,value)，集合会按照你指定的key进行映射分组。\n\n  ② reduce：\n\n   这个称为简化函数，会对map分组后的数据进行分组简化，注意：在reduce(key,value)中的key就是\n  emit中的key，vlaue为emit分组后的emit(value)的集合，这里也就是很多{\"count\":1}的数组。\n\n  ③ mapReduce:\n\n  这个就是最后执行的函数了，参数为map，reduce和一些可选参数。具体看图可知：\n\n \n ![mongo35](/image/mongo/35.png) \n\n从图中我们可以看到如下信息：\n\n result: \"存放的集合名“；\n\n  input:传入文档的个数。\n\n  emit：此函数被调用的次数。\n\n  reduce：此函数被调用的次数。\n\n  output:最后返回文档的个数。\n\n最后我们看一下“collecton”集合里面按姓名分组的情况。\n\n ![mongo36](/image/mongo/36.png) \n \n\n ![mongo37](/image/mongo/37.png) \n \n\n ![mongo38](/image/mongo/38.png) \n \n二：游标\n\n mongodb里面的游标有点类似我们说的C#里面延迟执行，比如：\n\n  var list=db.person.find();\n\n针对这样的操作，list其实并没有获取到person中的文档，而是申明一个“查询结构”，等我们需要的时候通过\n\nfor或者next()一次性加载过来，然后让游标逐行读取，当我们枚举完了之后，游标销毁，之后我们在通过list获取时，\n\n发现没有数据返回了。\n ![mongo39](/image/mongo/39.png) \n\n \n\n当然我们的“查询构造”还可以搞的复杂点，比如分页，排序都可以加进去。\n\n var single=db.person.find().sort({\"name\",1}).skip(2).limit(2);\n\n那么这样的“查询构造”可以在我们需要执行的时候执行，大大提高了不必要的花销。\n\n ![mongo311](/image/mongo/311.png) \n ![mongo312](/image/mongo/312.png) \n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb快速入门(二)","url":"/mongo/mongo1.html","content":"## 说明\n\nmongodb细说增删查改等,以windows为例\n\n## 实践\n\n看过上一篇，相信大家都会知道如何开启mongodb了，这篇就细说下其中的增删查改，首先当我们用上一篇同样的方式打开mongodb，突然\n\n傻眼了，擦，竟然开启不了，仔细观察“划线区域“的信息，发现db文件夹下有一个类似的”lock file”阻止了mongodb的开启，接下来我们要做的就\n\n是干掉它，之后，开启成功，关于mongodb的管理方式将在后续文章分享。\n ![mongo21](/image/mongo/21.png)\n \n\n### Insert操作\n\n上一篇也说过,文档是采用“K-V”格式存储的，如果大家对JSON比较熟悉的话，我相信学mongodb是手到擒来，我们知道JSON里面Value\n\n可能是“字符串”，可能是“数组”，又有可能是内嵌的一个JSON对象，相同的方式也适合于BSON。\n\n常见的插入操作也就两种形式存在：“单条插入”和“批量插入”。\n\n①  单条插入\n\n  先前也说了，mongo命令打开的是一个javascript shell。所以js的语法在这里面都行得通。      \n ![mongo22](/image/mongo/22.png)\n    \n\n ② 批量插入\n\n这玩意跟“单条插入”的差异相信大家应该知道，由于mongodb中没有提供给shell的“批量插入方法”，没关系，各个语言的driver都打通\n\n了跟mongodb内部的批量插入方法，因为该方法是不可或缺的，如果大家非要模拟下批量插入的话，可以自己写了for循环，里面就是insert。\n\n \n\n### Find操作\n  \n   日常开发中，我们玩查询，玩的最多的也就是二类：\n\n  \n   ①： >, >=, <, <=, !=, =。\n\n  \n   ②：And，OR，In，NotIn\n\n这些操作在mongodb里面都封装好了，下面就一一介绍：\n\n*  \"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"没有特殊关键字\"，这些跟上面是一一对应的，举几个例子。\n ![mongo23](/image/mongo/23.png)\n*  \"无关键字“, \"$or\", \"$in\"，\"$nin\" 同样我也是举几个例子\n ![mongo24](/image/mongo/24.png)\n*  在mongodb中还有一个特殊的匹配，那就是“正则表达式”，这玩意威力很强的。\n ![mongo25](/image/mongo/25.png)\n*  有时查询很复杂，很蛋疼，不过没关系，mongodb给我们祭出了大招，它就是$where，为什么这么说，是因为$where中的value\n\n  就是我们非常熟悉，非常热爱的js来助我们一马平川。\n ![mongo26](/image/mongo/26.png)\n \n\n###  Update操作\n\n   更新操作无非也就两种，整体更新和局部更新，使用场合相信大家也清楚。\n\n*  整体更新\n\n    不知道大家可还记得，我在上一篇使用update的时候，其实那种update是属于整体更新。\n ![mongo27](/image/mongo/27.png)\n* 局部更新\n    \n    有时候我们仅仅需要更新一个字段，而不是整体更新，那么我们该如何做呢？easy的问题，mongodb中已经给我们提供了两个\n\n   修改器： $inc 和 $set。\n\n   ①  $inc修改器\n\n   $inc也就是increase的缩写，学过sql server 的同学应该很熟悉，比如我们做一个在线用户状态记录，每次修改会在原有的基础上\n\n   自增$inc指定的值，如果“文档”中没有此key，则会创建key，下面的例子一看就懂。\n\n  ![mongo28](/image/mongo/28.png)\n\n   ② $set修改器\n\n     \n  ![mongo29](/image/mongo/29.png)\n\n*  upsert操作\n\n     这个可是mongodb创造出来的“词”，大家还记得update方法的第一次参数是“查询条件”吗？，那么这个upsert操作就是说：如果我\n\n没有查到，我就在数据库里面新增一条，其实这样也有好处，就是避免了我在数据库里面判断是update还是add操作，使用起来很简单\n\n将update的第三个参数设为true即可。\n\n  ![mongo211](/image/mongo/211.png) \n\n* 批量更新\n\n     在mongodb中如果匹配多条，默认的情况下只更新第一条，那么如果我们有需求必须批量更新，那么在mongodb中实现也是很简单的，在update的第四个参数中设为true即可。例子就不举了。\n\n \n\n### Remove操作\n\n这个操作在上一篇简单的说过，这里就不赘述了。\n","tags":["mongo"],"categories":["mongo"]},{"title":"mongodb入门(一)","url":"/mongo/mongostart.html","content":"## 说明\n\nmongodb快速搭建入门,以windows为例\n\n## 实践\n\n关于mongodb的好处，优点之类的这里就不说了，唯一要讲的一点就是mongodb中有三元素：数据库，集合，文档，其中“集合”\n\n就是对应关系数据库中的“表”，“文档”对应“行”。\n\n## 安装\n\n进入官网[mongo]http://www.mongodb.org/downloads 下载你所需要的版本按照官方指南进行安装\n我们发现有32bit和64bit，这个就要看你系统了，不过这里有两点注意：\n\n  ①：根据业界规则，偶数为“稳定版”（如：1.6.X，1.8.X），奇数为“开发版”（如：1.7.X，1.9.X)，这两个版本的区别相信大家都知道吧。\n\n  ②：32bit的mongodb最大只能存放2G的数据，64bit就没有限制。\n\n  我这里就下载\"2.0.2版本，32bit“，ok，下载之后我就放到”E盘“，改下文件夹名字为”mongodb“。\n\n\n## 启动\n\n   ①：启动之前，我们要给mongodb指定一个文件夹，这里取名为”db\",用来存放mongodb的数据。\n   ![mongo1](/image/mongo/1.png)\n   ②：微软徽标+R，输入cmd，首先找到“mongodb”的路径，然后运行mongod开启命令，同时用--dbpath指定数据存放地点为“db”文件夹。\n    ![mongo2](/image/mongo/2.png)\n   ③：最后要看下是否开启成功，从图中的信息中获知，mongodb采用27017端口，那么我们就在浏览器里面键入“http://localhost:27017/”，\n\n   打开后，mongodb告诉我们在27017上Add 1000可以用http模式查看mongodb的管理信息。\n    ![mongo3](/image/mongo/3.png)\n           \n\n               \n\n \n\n## 基本操作\n\n  由于是开篇，就大概的说下基本的“增删查改“，我们再开一个cmd，输入mongo命令打开shell，其实这个shell就是mongodb的客户端，\n\n同时也是一个js的编译器，默认连接的是“test”数据库。\n\n \n\n ![mongo4](/image/mongo/4.png)\n\n \n\n###  insert 操作\n\n  好，数据库有了，下一步就是集合，这里就取集合名为“person”，要注意的就是文档是一个json的扩展（Bson)形式。\n\n  ![mongo5](/image/mongo/5.png)\n\n### find 操作\n\n  我们将数据插入后，肯定是要find出来，不然插了也白插，这里要注意两点：\n\n   ① “_id\"： 这个字段是数据库默认给我们加的GUID，目的就是保证数据的唯一性。\n\n   ② 严格的按照Bson的形式书写文档，不过也没关系，错误提示还是很强大的。\n  ![mongo6](/image/mongo/6.png)\n  \n\n### update操作\n    \n  update方法的第一个参数为“查找的条件”，第二个参数为“更新的值”，学过C#，相信还是很好理解的。\n  ![mongo7](/image/mongo/7.png)\n  \n\n### remove操作\n\n  remove中如果不带参数将删除所有数据，呵呵，很危险的操作，在mongodb中是一个不可撤回的操作，三思而后行。\n  \n ![mongo8](/image/mongo/8.png)\n","tags":["mongo"],"categories":["mongo"]},{"title":"Hexo分页","url":"/hexo/hexofenye.html","content":"## 说明\n\n由于博客量的增加,单页给人的体验不太友好,加载缓慢,因此需要分页来提升用户的体验效果,怎么做呢,\n我以TKL主题为例给大家说明,因为这个主题只有首页是带分页的,其他分类啊,标签,archive是不带分页的,默认只加载config.per_page条博客,具体实现如下:\n我们可以参考首页的实现来修改\n\n## 实现\n* 进入casper/index.ejs\n\n进入之后我们可以看到这样的类似代码\n\n```\n<nav class=\"pagination\" role=\"pagination\">\n          <% if (page.prev) { %><a class=\"pull-left\" href=\"<%- url_for(page.prev_link) %>\">← 上一页</a><% } %>\n          <% if (page.next) { %><a class=\"pull-right\" href=\"<%- url_for(page.next_link) %>\">下一页 →</a><% } %>\n</nav>\n```\n\n很明显这事分页的html和css\n\n* 其他分类啊,标签,archive是如何渲染的\n\n打开源码我们发现,他们几个模版都用的是casper/archive.ejs这个模版\n\n```\n<%- partial('casper/archive', {pagination: config.tag}) %>\n<%- partial('casper/archive', {pagination: config.category}) %>\n<%- partial('casper/archive', {pagination: config.archive}) %>\n```\n\n好那我们就放心了,改一个地方就行,我们把上面的分页代码copy到archive.ejs,看看会不会生效呢?\n\n![copy](/image/hexo/WechatIMG13.jpeg)\n\n## 见证奇迹的时刻\n\n![bingo](/image/hexo/WechatIMG14.jpeg)\n\n 这样我们就很简单的实现了hexo博客中所有的分页设置,包括首页、分类啊,标签,archive等\n","tags":["hexo"],"categories":["hexo"]},{"title":"Hexo 增加百度统计","url":"/hexo/hexobaidu.html","content":"\n为了更好的运营博客,关注自己博客的运行情况,我们需要一个监控统计平台,hexo 有的主题里自带google分析的组件,但是神州大地你懂的,所以本人改用百度统计,具体步骤如下:\n\n## 登录百度统计\n\n登录[百度统计](https://tongji.baidu.com/sc-web/7322263/home/site/index?from=3)\n\n## 添加网站 如图\n\n![添加](/image/hexo/WechatIMG8.jpeg)\n\n## 获取统计代码\n\n![代码](/image/hexo/WechatIMG9.jpeg)\n\n![代码](/image/hexo/WechatIMG10.jpeg)\n\n## 复制到项目中\n\n将上面百度生成的代码复制到footer中,因为每个页面都要用到footer,所以这里再好不过了\n![代码](/image/hexo/WechatIMG11.jpeg)\n说明footer位于theme文件下路径如下,用什么主题就在那个主题的文件里加!!\nlandscape主题\n```\n/themes/landscape/layout/_partical/footer.ejs\n```\nTKL主题\n```\n/themes/TKL/layout/casper/footer.ejs\n```\n\n## 最后代码检测\n\n![代码](/image/hexo/WechatIMG12.jpeg)\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"Hexo域名绑定","url":"/hexo/hexopublish.html","content":"## 说明\n\n根据上文[点我](http://www.icafebolger.com/hexo/hexonewartice.html)引导,我们成功的搭建的自己的博客,并发不到git上的静态托管服务器上,\n但是如大家看到的,域名显示的 **your_user_name.github.io** ,很不和谐,对于有强迫症的我们该怎么办呢?\n答案是:we can do this\n我们可以上阿里购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。因为，github pages是支持域名绑定的。\n\n## 申请域名\n注册登录[阿里云(戳)](https://wanwang.aliyun.com/domain/com?spm=5176.8142029.388261.147.QftNkk),花点小钱买个com域名,\n本人为例 www.icafebolger.com,之后必须要进行实名制,否则DNS解析会有问题\n\n## 域名解析\n\n进入控制台[戳我](https://netcn.console.aliyun.com/core/domain/tclist?spm=5176.2020520001.1001.199.mcYBW3)即可看到刚才买的域名,\n![图0](/image/hexo/WechatIMG3.jpeg)\n点击新增解析,添加如图两条纪录,保存即可\n\n![图1](/image/hexo/WechatIMG4.jpeg)\n\n##  进入git setting CNAME\n\n进入git 项目跟目录\n\nhttps://github.com/you_git_username/you_git_username.github.io/settings\n\n在如图位置填写刚申请的域名\n\n![图2](/image/hexo/WechatIMG5.jpeg)\n点击保存,如果成功了,会看到上面的GitHub Pages信息发生了神奇的变化\n\n## 最后\n\n为了避免以后每次发布的时候CNAME丢失还得重新配置,我们将git项目最后生成的CNAME文件下载到本地项目的source文件夹下,这样以后就不用再处理了,是不是很方便\n\n![图2](/image/hexo/WechatIMG6.jpeg)\n![图2](/image/hexo/WechatIMG7.jpeg)\n\n## 最后的最后\n\n整个域名绑定的工作结束了,访问[戳我](www.icafebolger.com)即可看到你的杰作。\n","tags":["hexo"],"categories":["hexo"]},{"title":"react 自定义modal组件","url":"/reactjs/reactmodal.html","content":"基于es6语法,我们可以自定自己的弹出组件modal,适用于web/mobile,项目中实际会用到,以下都是本人项目demo\n本文分以下几个部分:\n* 样式\n* 组件定义\n* 组件引用\n* 组件调用\n\n## 设置样式\n\n```\n/*蒙版部分*/\n.page_mask {\n  width: 100%;\n  height: 100%;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 9991;\n  background-color: #000;\n  opacity: 0.6;\n}\n\n.coverShow {\n  position: fixed;\n  top: 35%;\n  left: 0;\n  width: 68%;\n  height: auto;\n  z-index: 99999;\n  background-color: #ffffff;\n  text-align: center;\n  border-radius: 15px;\n  right: 0;\n  margin: 0 auto;\n}\n\n.coverShow h4 {\n  padding-top: 27px;\n  color: #3e4852;\n}\n\n.man_number {\n  padding: 12px 3% 0 3%;\n  font-size: 0.82em;\n  color: #6a6e7a;\n}\n\n.btn {\n  border-top: 1px solid #e2e2e2;\n  margin-top: 10px;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n}\n\n.btn_1 {\n  display: inline;\n  float: left;\n  text-align: center;\n  margin: 0 auto;\n  width: 49%;\n  line-height: 50px;\n  border-right: 1px solid #d7d7d7;\n  color: #383838;\n  font-size: 0.93em;\n}\n\n.btn_1:hover {\n  color: #3a94ed;\n}\n\n.btn_2 {\n  display: inline;\n  float: left;\n  text-align: center;\n  margin: 0 auto;\n  width: 49%;\n  line-height: 50px;\n  color: #383838;\n  font-size: 0.93em;\n}\n\n.btn_2:hover {\n  color: #3a94ed;\n}\n```\n\n## 自定义modal\n\n确定需要的参数:\n\n* show:是否显示\n* children:modal内容支持html\n* title: modal标题\n* btn: modal按钮;支持1个或者2个按钮\n\n### 上干货\n\n```\nimport React from 'react';\nimport Mask from 'components/Mask';\nclass Modal extends React.Component {\n\n  getBtnMenu() {\n    return this.props.btn.map((menu, idx) => {\n      const {label, ...others} = menu;\n      let cls = this.props.btn.length === 1 ? '' : (idx == 0 ? 'btn_1' : 'btn_2');\n      return (\n        <div key={idx} {...others} className={cls}>{label}</div>\n      );\n    });\n  }\n\n  render() {\n    const {show, children, title} = this.props;\n\n    return (\n      <div>\n        {show && (\n          <div>\n            <Mask />\n\n            <div className='coverShow'>\n              <h4>{title}</h4>\n\n              <div className='man_number'>{children}</div>\n              <div className='btn'>\n                {this.getBtnMenu()}\n              </div>\n            </div>\n          </div>)}\n\n      </div>\n    );\n  }\n}\nModal.propTypes = {\n  show: React.PropTypes.bool,\n  children: React.PropTypes.any,\n  title: React.PropTypes.string,\n  btn: React.PropTypes.array};\n\nexport default Modal;\n```\n\n\n## using\n\n### 引用\n\n```\nimport Modal from 'components/Modal';\n\n```\n\n### 定义按钮\n一个按钮\n```\nlet btnMark = [\n  {\n    label: '确定',\n    onClick: ()=> {\n      func();\n    }\n  }\n];\n```\n两个按钮\n```\nlet btnMark = [\n  {\n    label: '取消',\n    onClick: ()=> {\n      func1();\n    }\n  }, {\n    label: '确定',\n    onClick: ()=> {\n      func2();\n    }\n  }\n];\n\n```\n\n### 调用\n\n```\n<Modal title='是否删除' show={this.state.showQuickMark} btn={btnMark}>\n  是否全部删除?\n</Modal>\n```\n\n## 效果图\n![bingo](/image/react/WechatIMG10.jpeg)\n","tags":["reactjs","组件"],"categories":["reactjs"]},{"title":"react中router说明","url":"/reactjs/reactrouter.html","content":"\n* Root\n是一个包含了所有匹配组件的一个组件，它用来渲染你的组件。\n* state\n一个包含了匹配状态的对象。\n* state.path\n带有查询参数的当前URL\n* state.action\n一个触发路由改变的操作\n* state.pathname\n不带查询参数的URL\n* state.params\n当前被激活路由匹配路径对应的参数 如 /:id 对应的id值.\n\n* state.query\n\n当前被激活路由匹配路径对应的查询参数\n* state.routes\n包含了匹配路由的数组，在组件渲染之前获取数据会显得很有帮助。\n\n项目中代码实例;\n\n```\nexport default (store) => (\n  <Route path='/' component={CoreLayout}>\n    <IndexRoute component={HomeView} />\n    <Route path='teacher' component={CoreLayout}>\n      <IndexRoute component={TeacherClassList} />\n      <Route name='点名' path='calling' component={TeacherCallingView} />\n      <Route name='点名记录' path='called' component={TeacherCalledView} />\n    </Route>\n    <Route path='student' component={CoreLayout}>\n      <IndexRedirect to='called' />\n      <Route name='点名记录' path='called' component={StudentCalledView} />\n      <Route name='点名记录详情' path='called/detail' component={StudentCalledDetailView} />\n    </Route>\n    <Redirect from='*' to='/404' />\n  </Route>\n);\n```","tags":["reactjs"],"categories":["reactjs"]},{"title":"node在线升级","url":"/nodejs/nodenpm.html","content":"\n## node在线升级攻略\n 由于项目需要或者某个node包的依赖,需要将低版本的nodejs升级到最新版本的或者指定版本,该怎么做?\n \n ### npm 升级\n \n ```\n npm install npm -g\n ```\n \n ### 执行npm命令\n \n```\nnpm install -g n \n\n```\n\n### 升级\n\n```\n n 0.8.11   --升级到固定版本\n或者\nn stable   -- 升级到最新版本\n```\n\n\n### 攻略\n\n有些包下载比较慢或者需要翻墙才能下载安装,可以设置npm config属性,将node包源地址改到淘宝,具体命令如下:\n\n```\n npm config set registry \"https://registry.npm.taobao.org\"\n npm config list  --检测是否成功\n\n```\n如果成功了可见如下结果:\n\n```\nregistry = \"https://registry.npm.taobao.org/\"\n\n```","tags":["javascript","nodejs"],"categories":["nodejs"]},{"title":"react项目中集成jquery","url":"/reactjs/reactjquery.html","content":"\n## 单页面引用 \n\n### main.jsx\n```\nconst $ = require('jquery');\n$(‘#h1').text('Hello World’);\n\nrender() {\nreturn <div id=\"h1\"></div>\n}\n```\n\n### 配置webpack.config.js\n![a](/image/react1.png)\n![b](/image/react2.png)\n\n## 全局引用\n\n\n### main.jsx\n```\n$(‘#h1').text('Hello World’);\n```\n\n\n### 配置webpack.config.js\n\n```\n// ------------------------------------// Plugins// ------------------------------------webpackConfig.plugins = [\n  new webpack.DefinePlugin(config.globals),\n \n new webpack.ProvidePlugin({\n    $: \"jquery\",\n    jQuery: \"jquery\",\n    \"window.jQuery\": \"jquery\"  }),\n  new HtmlWebpackPlugin({\n    template: paths.client('index.html'),\n    hash: false,\n    filename: 'index.html',\n    inject: 'body',\n    minify: {\n      collapseWhitespace: true    }\n  })\n];\n```\n","tags":["reactjs","jquery"],"categories":["reactjs"]},{"title":"es6","url":"/javascript/es6.html","content":"\n## async 函数\n\n含义\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n前文有一个 Generator 函数，依次读取两个文件。\n\n```\nvar fs = require('fs');\n\nvar readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) reject(error);\n      resolve(data);\n    });\n  });\n};\n\nvar gen = function* () {\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n```\n\n写成async函数，就是下面这样。\n\n```\nvar asyncReadFile = async function () {\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n\nasync函数对 Generator 函数的改进，体现在以下四点。\n\n（1）内置执行器。\n\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n\nvar result = asyncReadFile();\n上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n\n（2）更好的语义。\n\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n（3）更广的适用性。\n\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n（4）返回值是 Promise。\n\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n用法\n\n基本用法\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n下面是一个例子。\n\n```\nasync function getStockPriceByName(name) {\n  var symbol = await getStockSymbol(name);\n  var stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。\n\n下面是另一个例子，指定多少毫秒后输出一个值。\n\n```\nfunction timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value)\n}\n\nasyncPrint('hello world', 50);\n上面代码指定50毫秒以后，输出hello world。\n```\n\nasync 函数有多种使用形式。\n\n// 函数声明\n```\nasync function foo() {}\n\n```\n// 函数表达式\n```\nconst foo = async function () {};\n```\n\n// 对象的方法\n```\nlet obj = { async foo() {} };\nobj.foo().then(...)\n```\n// Class 的方法\n```\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n```\n// 箭头函数\n\n```\nconst foo = async () => {};\n```\n\n语法\n\nasync函数的语法规则总体上比较简单，难点是错误处理机制。\n\n返回 Promise 对象\n\nasync函数返回一个 Promise 对象。\n\nasync函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n```\nasync function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n```\n上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。\n\nasync函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\n```\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n```\n// Error: 出错了\nPromise 对象的状态变化\n\nasync函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n下面是一个例子。\n\n```\nasync function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n\n```\n// \"ECMAScript 2017 Language Specification\"\n上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。\n\nawait 命令\n\n正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。\n\n```\nasync function f() {\n  return await 123;\n}\n\nf().then(v => console.log(v))\n```\n\n// 123\n上面代码中，await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。\n\nawait命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\n```\nasync function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n\n```\n\n// 出错了\n注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。\n\n只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。\n\nasync function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。\n\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n\n```\nasync function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n```\n\n// hello world\n另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\n\n```\nasync function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n```\n\n// 出错了\n// hello world\n错误处理\n\n如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\n\n```\nasync function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n\n```\n// Error：出错了\n上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。\n\n防止出错的方法，也是将其放在try...catch代码块之中。\n\n```\nasync function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n```\n\n如果有多个await命令，可以统一放在try...catch结构中。\n\n```\nasync function main() {\n  try {\n    var val1 = await firstStep();\n    var val2 = await secondStep(val1);\n    var val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n```\n\n使用注意点\n\n第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\n\n```\nasync function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n```\n// 另一种写法\n\n```\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  };\n}\n```\n\n第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n```\nlet foo = await getFoo();\nlet bar = await getBar();\n```\n\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n// 写法一\n```\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n```\n// 写法二\n\n```\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n\n```\n上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\n\n第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n```\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n```\n\n上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。\n\n```\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\n\n```\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n```\n\n如果确实希望多个请求并发执行，可以使用Promise.all方法。\n\n```\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n```\n\n// 或者使用下面的写法\n\n\n```\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\nasync 函数的实现原理\n\nasync 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n```\nasync function fn(args) {\n  // ...\n}\n```\n// 等同于\n\n```\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n```\n所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n\n下面给出spawn函数的实现，基本就是前文自动执行器的翻版。\n\n\n```\nfunction spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n```\n\n与其他异步处理方法的比较\n\n我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。\n\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n首先是 Promise 的写法。\n\n```\nfunction chainAnimationsPromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  var ret = null;\n\n  // 新建一个空的Promise\n  var p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(var anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n```\n虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。\n\n接着是 Generator 函数的写法。\n\n```\nfunction chainAnimationsGenerator(elem, animations) {\n\n  return spawn(function*() {\n    var ret = null;\n    try {\n      for(var anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n```\n\n上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的spawn函数就是自动执行器，它返回一个 Promise 对象，而且必须保证yield语句后面的表达式，必须返回一个 Promise。\n\n最后是 async 函数的写法。\n\n\n```\nasync function chainAnimationsAsync(elem, animations) {\n  var ret = null;\n  try {\n    for(var anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n```\n可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。\n\n实例：按顺序完成异步操作\n\n实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\nPromise 的写法如下。\n```\nfunction logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) => {\n    return chain.then(() => textPromise)\n      .then(text => console.log(text));\n  }, Promise.resolve());\n}\n```\n上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。\n\n这种写法不太直观，可读性比较差。下面是 async 函数实现。\n\n```\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n```\n\n上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。\n\n\n```\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n\n上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。\n\n异步遍历器\n\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。\n\n这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行next方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。\n\n目前，有一个提案，为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。\n\n异步遍历的接口\n\n异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。\n\nasyncIterator\n  .next()\n  .then(\n    ({ value, done }) => /* ... */\n  );\n上面代码中，asyncIterator是一个异步遍历器，调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。\n\n我们知道，一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。\n\n下面是一个异步遍历器的例子。\n\n```\nconst asyncIterable = createAsyncIterable(['a', 'b']);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\nasyncIterator\n.next()\n.then(iterResult1 => {\n  console.log(iterResult1); // { value: 'a', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult2 => {\n  console.log(iterResult2); // { value: 'b', done: false }\n  return asyncIterator.next();\n})\n.then(iterResult3 => {\n  console.log(iterResult3); // { value: undefined, done: true }\n});\n上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。\n\n由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在await命令后面。\n\nasync function f() {\n  const asyncIterable = createAsyncIterable(['a', 'b']);\n  const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\n  // { value: 'a', done: false }\n  console.log(await asyncIterator.next());\n  // { value: 'b', done: false }\n  console.log(await asyncIterator.next());\n  // { value: undefined, done: true }\n}\n```\n上面代码中，next方法用await处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。\n\n注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的Promise对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。\n\n```\nconst asyncGenObj = createAsyncIterable(['a', 'b']);\nconst [{value: v1}, {value: v2}] = await Promise.all([\n  asyncGenObj.next(), asyncGenObj.next()\n]);\n\nconsole.log(v1, v2); // a b\n```\n另一种用法是一次性调用所有的next方法，然后await最后一步操作。\n\n\n```\nconst writer = openFile('someFile.txt');\nwriter.next('hello');\nwriter.next('world');\nawait writer.return();\nfor await...of\n```\n前面介绍过，for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。\n\n```\nasync function f() {\n  for await (const x of createAsyncIterable(['a', 'b'])) {\n    console.log(x);\n  }\n}\n\n```\n// a\n// b\n上面代码中，createAsyncIterable()返回一个异步遍历器，for...of循环自动调用这个遍历器的next方法，会得到一个Promise对象。await用来处理这个Promise对象，一旦resolve，就把得到的值（x）传入for...of的循环体。\n\nfor await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。\n\n```\n\nlet body = '';\nfor await(const data of req) body += data;\nconst parsed = JSON.parse(body);\nconsole.log('got', parsed);\n```\n\n上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。\n\n如果next方法返回的Promise对象被reject，那么就要用try...catch捕捉。\n\n```\nasync function () {\n  try {\n    for await (const x of createRejectingIterable()) {\n      console.log(x);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n```\n注意，for await...of循环也可以用于同步遍历器。\n\n```\n(async function () {\n  for await (const x of ['a', 'b']) {\n    console.log(x);\n  }\n})();\n```\n\n// a\n// b\n异步Generator函数\n\n就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。\n\n在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。\n\n```\nasync function* readLines(path) {\n  let file = await fileOpen(path);\n\n  try {\n    while (!file.EOF) {\n      yield await file.readLine();\n    }\n  } finally {\n    await file.close();\n  }\n}\n```\n上面代码中，异步操作前面使用await关键字标明，即await后面的操作，应该返回Promise对象。凡是使用yield关键字的地方，就是next方法的停下来的地方，它后面的表达式的值（即await file.readLine()的值），会作为next()返回对象的value属性，这一点是于同步Generator函数一致的。\n\n可以像下面这样，使用上面代码定义的异步Generator函数。\n\n```\nfor await (const line of readLines(filePath)) {\n  console.log(line);\n}\n```\n异步 Generator 函数可以与for await...of循环结合起来使用。\n\n\n```\nasync function* prefixLines(asyncIterable) {\n  for await (const line of asyncIterable) {\n    yield '> ' + line;\n  }\n}\n```\nyield命令依然是立刻返回的，但是返回的是一个Promise对象。\n\n\n```\nasync function* asyncGenerator() {\n  console.log('Start');\n  const result = await doSomethingAsync(); // (A)\n  yield 'Result: '+ result; // (B)\n  console.log('Done');\n}\n```\n上面代码中，调用next方法以后，会在B处暂停执行，yield命令立刻返回一个Promise对象。这个Promise对象不同于A处await命令后面的那个 Promise 对象。主要有两点不同，一是A处的Promise对象resolve以后产生的值，会放入result变量；二是B处的Promise对象resolve以后产生的值，是表达式'Result： ' + result的值；二是A处的 Promise 对象一定先于B处的 Promise 对象resolve。\n\n如果异步 Generator 函数抛出错误，会被 Promise 对象reject，然后抛出的错误被catch方法捕获。\n\n```\nasync function* asyncGenerator() {\n  throw new Error('Problem!');\n}\n\nasyncGenerator()\n.next()\n.catch(err => console.log(err)); \n```\n// Error: Problem!\n注意，普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步Iterator对象。基本上，可以这样理解，async函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过for await...of执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。\n\n```\nasync function takeAsync(asyncIterable, count=Infinity) {\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value,done} = await iterator.next();\n    if (done) break;\n    result.push(value);\n  }\n  return result;\n}\n\n```\n上面代码中，异步Generator函数产生的异步遍历器，会通过while循环自动执行，每当await iterator.next()完成，就会进入下一轮循环。\n\n下面是这个自动执行器的一个使用实例。\n\n\n```\nasync function f() {\n  async function* gen() {\n    yield 'a';\n    yield 'b';\n    yield 'c';\n  }\n\n  return await takeAsync(gen());\n}\n\nf().then(function (result) {\n  console.log(result); // ['a', 'b', 'c']\n})\n\n```\n\n异步 Generator 函数出现以后，JavaScript就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。请注意区分每种函数的不同之处。\n\n最后，同步的数据结构，也可以使用异步 Generator 函数。\n\n\n```\nasync function* createAsyncIterable(syncIterable) {\n  for (const elem of syncIterable) {\n    yield elem;\n  }\n}\n```\n\n上面代码中，由于没有异步操作，所以也就没有使用await关键字。\n\nyield* 语句\n\nyield*语句也可以跟一个异步遍历器。\n\n```\nasync function* gen1() {\n  yield 'a';\n  yield 'b';\n  return 2;\n}\n\nasync function* gen2() {\n  const result = yield* gen1();\n}\n```\n\n上面代码中，gen2函数里面的result变量，最后的值是2。\n\n与同步Generator函数一样，for await...of循环会展开yield*。\n\n```\n(async function () {\n  for await (const x of gen2()) {\n    console.log(x);\n  }\n})();\nstyle={Object.assign({}, styles.slide, styles.slide3)}\n```","tags":["es6"],"categories":["javascript"]},{"title":"antdmobile","url":"/reactjs/antdmobile.html","content":"\n# 将支付宝react-mobile组件antdmobile集成到react+redux+router+webpack项目中\n\n## 安装 antd-mobile\n\n```\nnpm install antd-mobile\n```\n\n## 安装 babel-plugin-import\n\n```\nnpm install babel-plugin-import --save-dev\n```\n\n## 设置 webpack 的 resolve\n\n```\nresolve: {\n  extensions: ['', '.web.js', '.js', '.json'],\n}\n```\n\n## 设置.bable.rc\n\n```\n{\"plugins\": [[\"import\", { \"style\": \"css\", \"libraryName\": \"antd-mobile\" }]]}\n注意：style:’css’ 默认加载antd less文件 不设置该属性，可以将antd-mobile/dist/antd-mobile.css 文件copy到项目\n```\n\n## 如果业务要使用 Icon 组件，需要配置 svn-sprite-loader\n\n### svn-sprite-loader\n\n```\nnam install svn-sprite-loader\n\n```\n\n### 设置 webpack\n\n```\nwebpackConfig.module.loaders.push(\n{test: /\\.svg(\\?.*)?$/, loader: 'url?prefix=fonts/&name=[path][name].[ext]&limit=10000&mimetype=image/svg+xml',exclude:[require.resolve('antd-mobile').replace(/warn\\.js$/, '')]},\n{test: /\\.svg(\\?.*)?$/, loader: 'svg-sprite',include:[require.resolve('antd-mobile').replace(/warn\\.js$/, '')]},\n)\n```\n\n## Use\n\nclick [ant-mobile](https://mobile.ant.design/docs/react/introduce-cn)","tags":["reactjs","组件"],"categories":["reactjs"]},{"title":"loadmore","url":"/javascript/loadmore.html","content":"\n# 基于onscroll事件实现的loadmore(es6)\n\n## func\n\n```\n loadmore(e) {\n    let element = e.target;\n    try {\n      e.stopPropagation();\n    } catch (ex) {\n\n    }\n    let clientHeight = element.clientHeight; //可视区域高度\n    let scrollTop = element.scrollTop;  //滚动条滚动高度\n    let scrollHeight = element.scrollHeight; //滚动内容高度\n    if (scrollTop > 0 && (clientHeight + scrollTop) >= scrollHeight) { //如果滚动到底部\n      this.getlist('more');\n    }\n  }\n```\n\n## html\n\n```\n<div className=\"content_all\" style={{maxHeight: `${divHeight}px`, height: `${divHeight}px`, overflow: 'auto'}}\n               onScroll={this.loadmore}>\n</div>\n               \n```","tags":["reactjs","javascript"],"categories":["javascript"]},{"title":"reactjs-mobile常用组件","url":"/reactjs/reactcomponent.html","content":"# reactjs 网站建设中常用的组件,基本涵盖了项目日常所需\n\n1. griddle-react\n2. react-bootstrap\n3. react-cropper\n4. core-js\nModular standard library for JavaScript. Includes polyfills for ECMAScript 5, ECMAScript 6: promises, symbols, collections, iterators, typed arrays, ECMAScript 7+ proposals, setImmediate, etc\n5. Material UI\n6. superagent\n7. restful-error-es6\n8. browserify\n9. react-select-popover\n\n10. react-infinite-scroll\n11. semantic-ui\n12. react-date-range日期选择\n13. react-scroll  快速定位滚动\n14. react-timer-mixin suer timer\n15. react-autosuggest auto input\n16. react-native-swiper轮播\n17. react-split-container分割线拖拽\n18. reactjs-iscroll下拉上拉刷新\n19. react-hammerjs触屏事件库\n20. react-emoji-react emoji表情库\n21. react-ace在线编辑器\n22. react-highcharts highchart\n23. react-dropzone 上传\n24. react-fileupload-progress文件上传带processor\n25. react-fontawesome 字体icon库\n26. react-pdf pdf文档操作\n27. react-desktop桌面UI\n28. react-intl  Internationalize React apps\n29. react-image-gallery图片轮播\n30. react-s-alert  alert\n31. react-event-calendar事件日历\n32. react-color-picker 颜色选择器\n33. react-lazy-load 延迟加载\n34. react-tag-input  tag input\n35. revalidator格式验证\n36. react-bootstrap-daterangepicker时间范围\n37. react-transitive-number增减数\n38. react-css-transition-replace动画\n39. react-images image list\n40. react-clockwall 时间画布\n41. react-autobind fun auto bind\n42. react-simple-markdown-editor markdown编辑\n43. react-remarkable markdown 显示\n44. random-gem 随机数\n45. react-masonry-component 瀑布流\n46. react-alap 高德地图\n47. react-baidu-map 百度地图\n48. react-swipeable-views views滑动\n49. react-swipnable-tabs 可横向滚动的tab\n50. react-motion 动画\n51. react-image-fallback 图片lazy加载\n52. react-mobile-datepicker 滚动选择时间\n53. react-images 幻灯片灯箱\n54. react-image-magnify 图片细节放大\n55. urlencode node encode编码\n56. react-mobile-datepicker 滚动选择时间 年月日\n57. react-mobile-datetimepicker滚动选择时间 年月日时分\n58. react-fastclick消除touch click 300ms延迟\n59. react-sortable react-anything-sortable 拖动排序\n/*6-20补充*/\n60. react-autosuggest 自动提示\n61. react-image-crop 图片裁剪\n62. ua-device  ua判断系统及版本\n63. react-debounce-input 输入延迟，适合做autocomplete\n64. react-big-calendar 基于fullcalendar的日程组件\n\n","tags":["reactjs","组件"],"categories":["reactjs"]},{"title":"Hexo新建文章","url":"/hexo/hexonewartice.html","content":"## 1、cd到项目根目录\n\n```\nhexo new \"hexo新建文章\"\n\n```\n\n### 2、成功\n\n会在/source/_post下生成 hexo新建文章.md,格式如下\n\n```\n---\ntitle: hexo新建文章 #文章标题\ndate: 2017-05-16 18:11:45 #文章生成时间\ncategories: \"hexo\" #文章分类\ntags: #文章标签\n     - 标签1\n     - 标签2\n description: #文章简介\n---\n\n```\n\n### 3、结束","tags":["hexo"],"categories":["hexo"]},{"title":"Frist博客日记by hexo","url":"/hexo/hello-world.html","content":"欢迎来到 [Hexo](https://hexo.io/)! 这是我的第一个博客日记. 如果你也想搭建自己的博客,可以参考访问 [documentation](https://hexo.io/docs/) 来获取更多的信息。\n# 本地项目搭建\n\n## 下载git\n```\n[本人环境mac xcode自带git不需要再安装,windows请自行安装]\n```\n\n## 申请GitHub sshkey\n\n```\n\n不再赘述,请前往 \n\n```\n[github](https://github.com/settings/keys)\n\n## 安装nodejs\n\n```\nMore info: \n```\n[nodejs](https://nodejs.org/en/)\n\n## 安装hexo\n\n``` \nnpm install hexo -g\n```\n\n\n## 初始化项目\n\n``` \nhexo init\n```\n\n## 安装最新node包\n\n```\nnpm install hexo-renderer-ejs --save\nnpm install hexo-renderer-stylus --save\nnpm install hexo-renderer-marked --save\nnpm install hexo-deployer-git --save\n```\n\n## 生成静态页面\n\n``` \nhexo generate （hexo g  也可以）   \n```\n\n## 启动\n\n``` \nhexo server  \n浏览器输入http://localhost:4000 则可正常访问\n```\n\n# 配置Github\n\n## 建立Repository代码库\n\n```\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】\n```\n\n## 配置_config.yml (项目根目录下)\n\n```\ndeploy:\n  type: git\n  repository: https://github.com/your_user_name/your_user_name.github.io.git\n  branch: master\n```\n\n## 发布到git部署\n\n```\nhexo deploy\n\n```\n\n## 访问网站\n\n```\nyour_user_name.github.io\n```\n\n# 之后每次部署步骤\n\n```\nhexo clean\nhexo generate\nhexo deploy\n\n```\n\n# hexo一些常用命令：\n  \n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  #查看帮助\nhexo version  #查看Hexo的版本\n```\n\n\n# hexo 插件\n\n[戳我获取插件](https://hexo.io/plugins/)\n","tags":["hexo"],"categories":["hexo"]}]